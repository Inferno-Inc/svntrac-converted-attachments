<?xml version="1.0" encoding="utf-8"?>
<!-- name="GENERATOR" content="github.com/mmarkdown/mmark Mmark Markdown Processor - mmark.miek.nl" -->
<rfc version="3" ipr="trust200902" docName="draft-ietf-cellar-flac-02" submissionType="IETF" category="info" xml:lang="en" xmlns:xi="http://www.w3.org/2001/XInclude" indexInclude="false" consensus="true">

<front>
<title abbrev="FLAC">Free Lossless Audio Codec</title><seriesInfo value="draft-ietf-cellar-flac-02" stream="IETF" status="informational" name="Internet-Draft"></seriesInfo>
<author initials="M." surname="Richardson" fullname="Michael Richardson"><organization></organization><address><postal><street></street>
</postal><email>mcr@sandelman.ca</email>
</address></author><author initials="A." surname="Weaver" fullname="Andrew Weaver"><organization></organization><address><postal><street></street>
</postal><email>theandrewjw@gmail.com</email>
</address></author><date/>
<area>art</area>
<workgroup>cellar</workgroup>
<keyword>free,lossless,audio,codec,encoder,decoder,compression,compressor,archival,archive,archiving,backup,music</keyword>

<abstract>
<t>This document defines FLAC, which stands for Free Lossless Audio Codec, a free, open source codec for lossless audio compression and decompression.</t>
</abstract>

</front>

<middle>

<section anchor="introduction"><name>Introduction</name>
<t>This is a detailed description of the FLAC format. There is also a companion document that describes <eref target="https://xiph.org/flac/ogg_mapping.html">FLAC-to-Ogg mapping</eref>.</t>
<t>For a user-oriented overview, see <eref target="https://xiph.org/flac/documentation_format_overview.html">About the FLAC Format</eref>.</t>
</section>

<section anchor="notation-and-conventions"><name>Notation and Conventions</name>
<t>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP 14 <xref target="RFC2119"></xref> <xref target="RFC8174"></xref> when, and only when, they appear in all capitals, as shown here.</t>
</section>

<section anchor="acknowledgments"><name>Acknowledgments</name>
<t>FLAC owes much to the many people who have advanced the audio compression field so freely. For instance:
- <eref target="http://svr-www.eng.cam.ac.uk/~ajr/">A. J. Robinson</eref> for his work on <eref target="http://svr-www.eng.cam.ac.uk/reports/abstracts/robinson_tr156.html">Shorten</eref>; his paper is a good starting point on some of the basic methods used by FLAC. FLAC trivially extends and improves the fixed predictors, LPC coefficient quantization, and Exponential-Golomb coding used in Shorten.
- <eref target="https://web.archive.org/web/20040215005354/http://csi.usc.edu/faculty/golomb.html">S. W. Golomb</eref> and Robert F. Rice; their universal codes are used by FLAC's entropy coder.
- N. Levinson and J. Durbin; the reference encoder uses an algorithm developed and refined by them for determining the LPC coefficients from the autocorrelation coefficients.
- And of course, <eref target="http://en.wikipedia.org/wiki/Claude_Shannon">Claude Shannon</eref></t>
</section>

<section anchor="scope"><name>Scope</name>
<t>FLAC stands for Free Lossless Audio Codec: it is designed to reduce the amount of computer storage space needed to store digital audio signals without needing to remove information in doing so (i.e. lossless). FLAC is free in the sense that its specification is open, its reference implementation is open-source and it is not encumbered by any known patent.</t>
<t>FLAC is able to achieve lossless compression because samples in audio signals tend to be highly correlated with their close neighbors. In contrast with general purpose compressors, which often use dictionaries, do run-length coding or exploit long-term repetition, FLAC removes redundancy solely in the very short term, looking back at most 32 samples.</t>
<t>The FLAC format is suited for pulse-code modulated (PCM) audio with 1 to 8 channels, sample rates from 1 to 1048576 Hertz and bit depths between 4 and 32 bits. Most tools for reading and writing the FLAC format have been optimized for CD-audio, which is PCM audio with 2 channels, a sample rate of 44.1 kHz and a bit depth of 16 bits.</t>
<t>Compared to other lossless (audio) coding formats, FLAC is a format with low complexity and can be coded to and from with little computing resources. Decoding of FLAC has seen many independent implementations on many different platforms, and both encoding and decoding can be implemented without needing floating-point arithmetic.</t>
<t>The coding methods provided by the FLAC format works best on PCM audio signals of which the samples have a signed representation and are centered around zero. Audio signals in which samples have an unsigned representation must be transformed to a signed representation as described in this document in order to achieve reasonable compression. The FLAC format is not suited to compress audio that is not PCM. Pulse-density modulated audio, e.g. DSD, cannot be compressed by FLAC.</t>
</section>

<section anchor="architecture"><name>Architecture</name>
<t>Similar to many audio coders, a FLAC encoder has the following stages:</t>

<ul>
<li><t><tt>Blocking</tt> (see <eref target="#blocking">section on Blocking</eref>). The input is broken up into many contiguous blocks. With FLAC, the blocks MAY vary in size. The optimal size of the block is usually affected by many factors, including the sample rate, spectral characteristics over time, etc. Though FLAC allows the block size to vary within a stream, the reference encoder uses a fixed block size.</t>
</li>
<li><t><tt>Interchannel Decorrelation</tt> (see <eref target="#interchannel-decorrelation">section on Interchannel Decorrelation</eref>). In the case of stereo streams, the encoder will create mid and side signals based on the average and difference (respectively) of the left and right channels. The encoder will then pass the best form of the signal to the next stage.</t>
</li>
<li><t><tt>Prediction</tt> (see <eref target="#prediction">section on Prediction</eref>). The block is passed through a prediction stage where the encoder tries to find a mathematical description (usually an approximate one) of the signal. This description is typically much smaller than the raw signal itself. Since the methods of prediction are known to both the encoder and decoder, only the parameters of the predictor need be included in the compressed stream. FLAC currently uses four different classes of predictors, but the format has reserved space for additional methods. FLAC allows the class of predictor to change from block to block, or even within the channels of a block.</t>
</li>
<li><t><tt>Residual Coding</tt> (See <eref target="#residual-coding">section on Residual Coding</eref>). If the predictor does not describe the signal exactly, the difference between the original signal and the predicted signal (called the error or residual signal) MUST be coded losslessly. If the predictor is effective, the residual signal will require fewer bits per sample than the original signal. FLAC currently uses only one method for encoding the residual, but the format has reserved space for additional methods. FLAC allows the residual coding method to change from block to block, or even within the channels of a block.</t>
</li>
</ul>
<t>In addition, FLAC specifies a metadata system, which allows arbitrary information about the stream to be included at the beginning of the stream.</t>
</section>

<section anchor="definitions"><name>Definitions</name>

<ul>
<li><t><strong>Block</strong>: A (short) section of linear pulse-code modulated audio, with one or more channels.</t>
</li>
<li><t><strong>Subblock</strong>: All samples within a corresponding block for 1 channel. One or more subblocks form a block, and all subblocks in a certain block contain the same number of samples.</t>
</li>
<li><t><strong>Frame</strong>: A frame header plus one or more subframes. It encodes the contents of a corresponding block.</t>
</li>
<li><t><strong>Subframe</strong>: An encoded subblock. All subframes within a frame code for the same number of samples. A subframe MAY correspond to a subblock, else it corresponds to either the addition or subtraction of two subblocks, see <eref target="#interchannel-decorrelation">section on interchannel decorrelation</eref>.</t>
</li>
<li><t><strong>Blocksize</strong>: The total number of samples contained in a block or coded in a frame, divided by the number of channels. In other words, the number of samples in any subblock of a block, or any subframe of a frame. This is also called <strong>interchannel samples</strong>.</t>
</li>
<li><t><strong>Bit depth</strong> or <strong>bits per sample</strong>: the number of bits used to contain each sample. This MUST be the same for all subblocks in a block but MAY be different for different subframes in a frame because of <eref target="#interchannel-decorrelation">interchannel decorrelation</eref>.</t>
</li>
<li><t><strong>Predictor</strong>: a model used to predict samples in an audio signal based on past samples. FLAC uses such predictors to remove redundancy in a signal in order to be able to compress it.</t>
</li>
<li><t><strong>Linear predictor</strong>: a predictor using <eref target="https://en.wikipedia.org/wiki/Linear_prediction">linear prediction</eref>. This is also called <strong>linear predictive coding (LPC)</strong>. With a linear predictor each prediction is a linear combination of past samples, hence the name. A linear predictor has a <eref target="https://en.wikipedia.org/wiki/Finite_impulse_response">causal discrete-time finite impulse response</eref>.</t>
</li>
<li><t><strong>Fixed predictor</strong>: a linear predictor in which the model parameters are the same across all FLAC files, and thus not need to be stored.</t>
</li>
<li><t><strong>Predictor order</strong>: the number of past samples that a predictor uses. For example, a 4th order predictor uses the 4 samples directly preceding a certain sample to predict it. In FLAC, samples used in a predictor are always consecutive, and are always the samples directly before the sample that is being predicted</t>
</li>
<li><t><strong>Residual</strong>: The audio signal that remains after a predictor has been subtracted from a subblock. If the predictor has been able to remove redundancy from the signal, the samples of the remaining signal (the <strong>residual samples</strong>) will have, on average, a smaller numerical value than the original signal.</t>
</li>
<li><t><strong>Rice code</strong>: A <eref target="https://en.wikipedia.org/wiki/Variable-length_code">variable-length code</eref> which compresses data by making use of the observation that, after using an effective predictor, most residual samples are closer to zero than the original samples, while still allowing for a small part of the samples to be much larger.</t>
</li>
</ul>
</section>

<section anchor="blocking"><name>Blocking</name>
<t>The size used for blocking the audio data has a direct effect on the compression ratio. If the block size is too small, the resulting large number of frames mean that excess bits will be wasted on frame headers. If the block size is too large, the characteristics of the signal MAY vary so much that the encoder will be unable to find a good predictor. In order to simplify encoder/decoder design, FLAC imposes a minimum block size of 16 samples, and a maximum block size of 65535 samples. This range covers the optimal size for all of the audio data FLAC supports.</t>
<t>Currently the reference encoder uses a fixed block size, optimized on the sample rate of the input. Future versions MAY vary the block size depending on the characteristics of the signal.</t>
<t>Blocked data is passed to the predictor stage one subblock (channel) at a time. Each subblock is independently coded into a subframe, and the subframes are concatenated into a frame. Because each channel is coded separately, one channel of a stereo frame MAY be encoded as a constant subframe, and the other an LPC subframe.</t>
</section>

<section anchor="interchannel-decorrelation"><name>Interchannel Decorrelation</name>
<t>In many audio files, channels are correlated. The FLAC format can exploit this correlation in stereo files by not directly coding subblocks into subframes, but instead coding an average of all samples in both subblocks (a mid channel) or the difference between all samples in both subblocks (a side channel). The following combinations are possible:</t>

<ul>
<li><t><strong>Independent</strong>. All channels are coded independently. All non-stereo files MUST be encoded this way.</t>
</li>
<li><t><strong>Mid-side</strong>. A left and right subblock are converted to mid and side subframes. To calculate a sample for a mid subframe, the corresponding left and right samples are summed and the result is shifted right by 1 bit. To calculate a sample for a side subframe, the corresponding right sample is subtracted from the corresponding left sample. On decoding, the mid channel has to be shifted left by 1 bit. Also, if the side channel is uneven, 1 has to be added to the mid channel after the left shift. To reconstruct the left channel, the corresponding samples in the mid and side subframes are added and the result shifted right by 1 bit, while for the right channel the side channel has to be subtracted from the mid channel and the result shifted right by 1 bit.</t>
</li>
<li><t><strong>Left-side</strong>. The left subblock is coded and the left and right subblock are used to code a side subframe. The side subframe is constructed in the same way as for mid-side. To decode, the right subblock is restored by subtracting the samples in the side subframe from the corresponding samples the left subframe.</t>
</li>
<li><t><strong>Right-side</strong>. The right subblock is coded and the left and right subblock are used to code a side subframe. Note that the actual coded subframe order is side-right. The side subframe is constructed in the same way as for mid-side. To decode, the left subblock is restored by adding the samples in the side subframe to the corresponding samples in the left subframe.</t>
</li>
</ul>
<t>The side channel needs one extra bit of bit depth as the subtraction can produce sample values twice as large as the maximum possible in any given bit depth. The mid channel in mid-side stereo does not need one extra bit, as it is shifted left one bit. The left shift of the mid channel does not lead to non-lossless behavior, because an uneven sample in the mid subframe must always be accompanied by a corresponding uneven sample in the side subframe, which means the lost least significant bit can be restored by taking it from the sample in the side subframe.</t>
</section>

<section anchor="prediction"><name>Prediction</name>
<t>FLAC uses four methods for modeling the input signal:</t>

<ol>
<li><t><strong>Verbatim</strong>. This is essentially a zero-order predictor of the signal. The predicted signal is zero, meaning the residual is the signal itself, and the compression is zero. This is the baseline against which the other predictors are measured. If you feed random data to the encoder, the verbatim predictor will probably be used for every subblock. Since the raw signal is not actually passed through the residual coding stage (it is added to the stream 'verbatim'), the encoding results will not be the same as a zero-order linear predictor.</t>
</li>
<li><t><strong>Constant</strong>. This predictor is used whenever the subblock is pure DC (&quot;digital silence&quot;), i.e. a constant value throughout. The signal is run-length encoded and added to the stream.</t>
</li>
<li><t><strong>Fixed linear predictor</strong>. FLAC uses a class of computationally-efficient fixed linear predictors (for a good description, see <eref target="http://www.hpl.hp.com/techreports/1999/HPL-1999-144.pdf">audiopak</eref> and <eref target="http://svr-www.eng.cam.ac.uk/reports/abstracts/robinson_tr156.html">shorten</eref>). FLAC adds a fourth-order predictor to the zero-to-third-order predictors used by Shorten. Since the predictors are fixed, the predictor order is the only parameter that needs to be stored in the compressed stream. The error signal is then passed to the residual coder.</t>
</li>
<li><t><strong>FIR Linear prediction</strong>. For more accurate modeling (at a cost of slower encoding), FLAC supports up to 32nd order FIR linear prediction (again, for information on linear prediction, see <eref target="http://www.hpl.hp.com/techreports/1999/HPL-1999-144.pdf">audiopak</eref> and <eref target="http://svr-www.eng.cam.ac.uk/reports/abstracts/robinson_tr156.html">shorten</eref>). The reference encoder uses the Levinson-Durbin method for calculating the LPC coefficients from the autocorrelation coefficients, and the coefficients are quantized before computing the residual. Whereas encoders such as Shorten used a fixed quantization for the entire input, FLAC allows the quantized coefficient precision to vary from subframe to subframe. The FLAC reference encoder estimates the optimal precision to use based on the block size and dynamic range of the original signal.</t>
</li>
</ol>
</section>

<section anchor="residual-coding"><name>Residual Coding</name>
<t>FLAC uses Exponential-Golomb (a variant of Rice) coding as its residual encoder. You can learn more about <eref target="https://en.wikipedia.org/wiki/Exponential-Golomb_coding">exp-golomb coding</eref> on Wikipedia.</t>
<t>FLAC currently defines two similar methods for the coding of the error signal from the prediction stage. The error signal is coded using Exponential-Golomb codes in one of two ways:</t>

<ol>
<li><t>the encoder estimates a single exp-golomb parameter based on the variance of the residual and exp-golomb codes the entire residual using this parameter;</t>
</li>
<li><t>the residual is partitioned into several equal-length regions of contiguous samples, and each region is coded with its own exp-golomb parameter based on the region's mean.</t>
</li>
</ol>
<t>(Note that the first method is a special case of the second method with one partition, except the exp-golomb parameter is based on the residual variance instead of the mean.)</t>
<t>The FLAC format has reserved space for other coding methods. Some possibilities for volunteers would be to explore better context-modeling of the exp-golomb parameter, or Huffman coding. See <eref target="http://www.hpl.hp.com/techreports/98/HPL-98-193.html">LOCO-I</eref> and <eref target="http://web.archive.org/web/20140827133312/http://www.cs.tut.fi/~albert/Dev/pucrunch/packing.html">pucrunch</eref> for descriptions of several universal codes.</t>
</section>

<section anchor="format"><name>Format</name>
<t>This section specifies the FLAC bitstream format.</t>

<section anchor="principles"><name>Principles</name>
<t>FLAC has no format version information, but it does contain reserved space in several places. Future versions of the format MAY use this reserved space safely without breaking the format of older streams. Older decoders MAY choose to abort decoding or skip data encoded with newer methods. Apart from reserved patterns, in places the format specifies invalid patterns, meaning that the patterns MAY never appear in any valid bitstream, in any prior, present, or future versions of the format. These invalid patterns are usually used to make the synchronization mechanism more robust.</t>
<t>All numbers used in a FLAC bitstream MUST be integers; there are no floating-point representations. All numbers MUST be big-endian coded, except the length field used in Vorbis comments, which MUST be little-endian coded. All numbers MUST be unsigned except linear predictor coefficients, the linear prediction shift and numbers which directly represent samples, which MUST be signed. None of these restrictions apply to application metadata blocks.</t>
<t>All samples encoded to and decoded from the FLAC format MUST be in a signed representation.</t>
<t>There are several ways to convert unsigned sample representations to signed sample representations, but the coding methods provided by the FLAC format work best on audio signals of which the numerical values of the samples are centered around zero, i.e. have no DC offset. In most unsigned audio formats, signals are centered around halfway the range of the unsigned integer type used. If that is the case, all sample representations SHOULD be converted by first copying the number to a signed integer with sufficient range and then subtracting half of the range of the unsigned integer type, which should result in a signal with samples centered around 0.</t>
</section>

<section anchor="overview"><name>Overview</name>
<t>Before the formal description of the stream, an overview might be helpful.</t>

<ul>
<li>A FLAC bitstream consists of the &quot;fLaC&quot; (i.e. 0x664C6143) marker at the beginning of the stream, followed by a mandatory metadata block (called the STREAMINFO block), any number of other metadata blocks, then the audio frames.</li>
<li><t>FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:</t>

<ul>
<li><tt>STREAMINFO</tt>: This block has information about the whole stream, like sample rate, number of channels, total number of samples, etc. It MUST be present as the first metadata block in the stream. Other metadata blocks MAY follow, and ones that the decoder doesn't understand, it will skip.</li>
<li><tt>PADDING</tt>: This block allows for an arbitrary amount of padding. The contents of a PADDING block have no meaning. This block is useful when it is known that metadata will be edited after encoding; the user can instruct the encoder to reserve a PADDING block of sufficient size so that when metadata is added, it will simply overwrite the padding (which is relatively quick) instead of having to insert it into the right place in the existing file (which would normally require rewriting the entire file).</li>
<li><tt>APPLICATION</tt>: This block is for use by third-party applications. The only mandatory field is a 32-bit identifier. This ID is granted upon request to an application by the FLAC maintainers. The remainder is of the block is defined by the registered application. Visit the <eref target="https://xiph.org/flac/id.html">registration page</eref> if you would like to register an ID for your application with FLAC.</li>
<li><tt>SEEKTABLE</tt>: This is an OPTIONAL block for storing seek points. It is possible to seek to any given sample in a FLAC stream without a seek table, but the delay can be unpredictable since the bitrate MAY vary widely within a stream. By adding seek points to a stream, this delay can be significantly reduced. Each seek point takes 18 bytes, so 1% resolution within a stream adds less than 2K. There can be only one SEEKTABLE in a stream, but the table can have any number of seek points. There is also a special 'placeholder' seekpoint which will be ignored by decoders but which can be used to reserve space for future seek point insertion.</li>
<li><tt>VORBIS_COMMENT</tt>: This block is for storing a list of human-readable name/value pairs. Values are encoded using UTF-8. It is an implementation of the <eref target="http://xiph.org/vorbis/doc/v-comment.html">Vorbis comment specification</eref> (without the framing bit). This is the only officially supported tagging mechanism in FLAC. There MUST be only zero or one VORBIS_COMMENT blocks in a stream. In some external documentation, Vorbis comments are called FLAC tags to lessen confusion.</li>
<li><tt>CUESHEET</tt>: This block is for storing various information that can be used in a cue sheet. It supports track and index points, compatible with Red Book CD digital audio discs, as well as other CD-DA metadata such as media catalog number and track ISRCs. The CUESHEET block is especially useful for backing up CD-DA discs, but it can be used as a general purpose cueing mechanism for playback.</li>
<li><tt>PICTURE</tt>: This block is for storing pictures associated with the file, most commonly cover art from CDs. There MAY be more than one PICTURE block in a file. The picture format is similar to the <eref target="http://www.id3.org/id3v2.4.0-frames">APIC frame in ID3v2</eref>. The PICTURE block has a type, MIME type, and UTF-8 description like ID3v2, and supports external linking via URL (though this is discouraged). The differences are that there is no uniqueness constraint on the description field, and the MIME type is mandatory. The FLAC PICTURE block also includes the resolution, color depth, and palette size so that the client can search for a suitable picture without having to scan them all.</li>
</ul></li>
<li><t>The audio data is composed of one or more audio frames. Each frame consists of a frame header, which contains a sync code, information about the frame like the block size, sample rate, number of channels, et cetera, and an 8-bit CRC. The frame header also contains either the sample number of the first sample in the frame (for variable-blocksize streams), or the frame number (for fixed-blocksize streams). This allows for fast, sample-accurate seeking to be performed. Following the frame header are encoded subframes, one for each channel, and finally, the frame is zero-padded to a byte boundary. Each subframe has its own header that specifies how the subframe is encoded.</t>
</li>
<li><t>Since a decoder MAY start decoding in the middle of a stream, there MUST be a method to determine the start of a frame. A 14-bit sync code begins each frame. The sync code will not appear anywhere else in the frame header. However, since it MAY appear in the subframes, the decoder has two other ways of ensuring a correct sync. The first is to check that the rest of the frame header contains no invalid data. Even this is not foolproof since valid header patterns can still occur within the subframes. The decoder's final check is to generate an 8-bit CRC of the frame header and compare this to the CRC stored at the end of the frame header.</t>
</li>
<li><t>Again, since a decoder MAY start decoding at an arbitrary frame in the stream, each frame header MUST contain some basic information about the stream because the decoder MAY not have access to the STREAMINFO metadata block at the start of the stream. This information includes sample rate, bits per sample, number of channels, etc. Since the frame header is pure overhead, it has a direct effect on the compression ratio. To keep the frame header as small as possible, FLAC uses lookup tables for the most commonly used values for frame parameters. For instance, the sample rate part of the frame header is specified using 4 bits. Eight of the bit patterns correspond to the commonly used sample rates of 8, 16, 22.05, 24, 32, 44.1, 48 or 96 kHz. However, odd sample rates can be specified by using one of the 'hint' bit patterns, directing the decoder to find the exact sample rate at the end of the frame header. The same method is used for specifying the block size and bits per sample. In this way, the frame header size stays small for all of the most common forms of audio data.</t>
</li>
<li><t>Individual subframes (one for each channel) are coded separately within a frame, and appear serially in the stream. In other words, the encoded audio data is NOT channel-interleaved. This reduces decoder complexity at the cost of requiring larger decode buffers. Each subframe has its own header specifying the attributes of the subframe, like prediction method and order, residual coding parameters, etc. The header is followed by the encoded audio data for that channel.</t>
</li>
</ul>
</section>

<section anchor="subset"><name>Subset</name>
<t><tt>FLAC</tt> specifies a subset of itself as the Subset format. The purpose of this is to ensure that any streams encoded according to the Subset are truly &quot;streamable&quot;, meaning that a decoder that cannot seek within the stream can still pick up in the middle of the stream and start decoding. It also makes hardware decoder implementations more practical by limiting the encoding parameters such that decoder buffer sizes and other resource requirements can be easily determined. <strong>flac</strong> generates Subset streams by default unless the &quot;--lax&quot; command-line option is used. The Subset makes the following limitations on what MAY be used in the stream:</t>

<ul>
<li>The blocksize bits in the <tt>FRAME_HEADER</tt> (see <eref target="#frameheader">FRAME_HEADER section</eref>) MUST be 0b0001-0b1110. The blocksize MUST be &lt;= 16384; if the sample rate is &lt;= 48000 Hz, the blocksize MUST be &lt;= 4608 = 2^9 * 3^2.</li>
<li>The sample rate bits in the <tt>FRAME_HEADER</tt> MUST be 0b0001-0b1110.</li>
<li>The bits-per-sample bits in the <tt>FRAME_HEADER</tt> MUST be 0b001-0b111.</li>
<li>If the sample rate is &lt;= 48000 Hz, the filter order in <tt>LPC subframes</tt> (see <eref target="#subframelpc">SUBFRAME_LPC section</eref>) MUST be less than or equal to 12, i.e. the subframe type bits in the <tt>SUBFRAME_HEADER</tt> (see <eref target="#subframeheader">SUBFRAME_HEADER section</eref>) SHOULD NOT be 0b101100-0b111111.</li>
<li>The Rice partition order (see <eref target="#coded-residual">Coded residual section</eref>) MUST be less than or equal to 8.</li>
</ul>
</section>

<section anchor="conventions"><name>Conventions</name>
<t>The following tables constitute a formal description of the FLAC format. Values expressed as <tt>u(n)</tt> represent unsigned big-endian integer using <tt>n</tt> bits. <tt>n</tt> may be expressed as an equation using <tt>*</tt> (multiplication), <tt>/</tt> (division), <tt>+</tt> (addition), or <tt>-</tt> (subtraction). An inclusive range of the number of bits expressed may be represented with an ellipsis, such as <tt>u(m...n)</tt>. The name of a value followed by an asterisk <tt>*</tt> indicates zero or more occurrences of the value. The name of a value followed by a plus sign <tt>+</tt> indicates one or more occurrences of the value.</t>
</section>

<section anchor="stream"><name>STREAM</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">&quot;fLaC&quot;, the FLAC stream marker in ASCII, meaning byte 0 of the stream is 0x66, followed by 0x4C 0x61 0x43</td>
</tr>

<tr>
<td align="left"><tt>METADATA_BLOCK_STREAMINFO</tt></td>
<td align="left">This is the mandatory STREAMINFO metadata block that has the basic properties of the stream.</td>
</tr>

<tr>
<td align="left"><tt>METADATA_BLOCK</tt>*</td>
<td align="left">Zero or more metadata blocks</td>
</tr>

<tr>
<td align="left"><tt>FRAME</tt>+</td>
<td align="left">One or more audio frames</td>
</tr>
</tbody>
</table></section>

<section anchor="metadata-block"><name>METADATA_BLOCK</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>METADATA_BLOCK_HEADER</tt></td>
<td align="left">A block header that specifies the type and size of the metadata block data.</td>
</tr>

<tr>
<td align="left"><tt>METADATA_BLOCK_DATA</tt></td>
<td align="left"></td>
</tr>
</tbody>
</table></section>

<section anchor="metadata-block-header"><name>METADATA<em>BLOCK</em>HEADER</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(1)</tt></td>
<td align="left">Last-metadata-block flag: '1' if this block is the last metadata block before the audio blocks, '0' otherwise.</td>
</tr>

<tr>
<td align="left"><tt>u(7)</tt></td>
<td align="left"><tt>BLOCK_TYPE</tt></td>
</tr>

<tr>
<td align="left"><tt>u(24)</tt></td>
<td align="left">Length (in bytes) of metadata to follow (does not include the size of the <tt>METADATA_BLOCK_HEADER</tt>)</td>
</tr>
</tbody>
</table></section>

<section anchor="block-type"><name>BLOCK_TYPE</name>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">0</td>
<td align="left">STREAMINFO</td>
</tr>

<tr>
<td align="left">1</td>
<td align="left">PADDING</td>
</tr>

<tr>
<td align="left">2</td>
<td align="left">APPLICATION</td>
</tr>

<tr>
<td align="left">3</td>
<td align="left">SEEKTABLE</td>
</tr>

<tr>
<td align="left">4</td>
<td align="left">VORBIS_COMMENT</td>
</tr>

<tr>
<td align="left">5</td>
<td align="left">CUESHEET</td>
</tr>

<tr>
<td align="left">6</td>
<td align="left">PICTURE</td>
</tr>

<tr>
<td align="left">7 - 126</td>
<td align="left">reserved</td>
</tr>

<tr>
<td align="left">127</td>
<td align="left">invalid, to avoid confusion with a frame sync code</td>
</tr>
</tbody>
</table></section>

<section anchor="metadata-block-data"><name>METADATA<em>BLOCK</em>DATA</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>METADATA_BLOCK_STREAMINFO</tt> || <tt>METADATA_BLOCK_PADDING</tt> || <tt>METADATA_BLOCK_APPLICATION</tt> || <tt>METADATA_BLOCK_SEEKTABLE</tt> || <tt>METADATA_BLOCK_VORBIS_COMMENT</tt> || <tt>METADATA_BLOCK_CUESHEET</tt> || <tt>METADATA_BLOCK_PICTURE</tt></td>
<td align="left">The block data MUST match the block type in the block header.</td>
</tr>
</tbody>
</table></section>

<section anchor="metadata-block-streaminfo"><name>METADATA<em>BLOCK</em>STREAMINFO</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(16)</tt></td>
<td align="left">The minimum block size (in samples) used in the stream.</td>
</tr>

<tr>
<td align="left"><tt>u(16)</tt></td>
<td align="left">The maximum block size (in samples) used in the stream. (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.</td>
</tr>

<tr>
<td align="left"><tt>u(24)</tt></td>
<td align="left">The minimum frame size (in bytes) used in the stream. A value of <tt>0</tt> signifies that the value is not known.</td>
</tr>

<tr>
<td align="left"><tt>u(24)</tt></td>
<td align="left">The maximum frame size (in bytes) used in the stream. A value of <tt>0</tt> signifies that the value is not known.</td>
</tr>

<tr>
<td align="left"><tt>u(20)</tt></td>
<td align="left">Sample rate in Hz. Though 20 bits are available, the maximum sample rate is limited by the structure of frame headers to 655350 Hz. Also, a value of 0 is invalid.</td>
</tr>

<tr>
<td align="left"><tt>u(3)</tt></td>
<td align="left">(number of channels)-1. FLAC supports from 1 to 8 channels</td>
</tr>

<tr>
<td align="left"><tt>u(5)</tt></td>
<td align="left">(bits per sample)-1. FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.</td>
</tr>

<tr>
<td align="left"><tt>u(36)</tt></td>
<td align="left">Total samples in stream. 'Samples' means inter-channel sample, i.e. one second of 44.1 kHz audio will have 44100 samples regardless of the number of channels. A value of zero here means the number of total samples is unknown.</td>
</tr>

<tr>
<td align="left"><tt>u(128)</tt></td>
<td align="left">MD5 signature of the unencoded audio data. This allows the decoder to determine if an error exists in the audio data even when the error does not result in an invalid bitstream.</td>
</tr>
</tbody>
</table><t>FLAC specifies a minimum block size of 16 and a maximum block size of 65535, meaning the bit patterns corresponding to the numbers 0-15 in the minimum blocksize and maximum blocksize fields are invalid.</t>
<t>The MD5 signature is made by performing an MD5 transformation on the samples of all channels interleaved, represented in signed, little-endian form. This interleaving is on a per-sample basis, so for a stereo file this means first the first sample of the first channel, then the first sample of the second channel, then the second sample of the first channel etc. Before performing the MD5 transformation, all samples must be byte-aligned. So, in case the bit depth is not a whole number of bytes, additional zero bits are inserted at the most-significant position until each sample representation is a whole number of bytes.</t>
</section>

<section anchor="metadata-block-padding"><name>METADATA<em>BLOCK</em>PADDING</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(n)</tt></td>
<td align="left">n '0' bits (n MUST be a multiple of 8)</td>
</tr>
</tbody>
</table></section>

<section anchor="metadata-block-application"><name>METADATA<em>BLOCK</em>APPLICATION</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">Registered application ID. (Visit the <eref target="https://xiph.org/flac/id.html">registration page</eref> to register an ID with FLAC.)</td>
</tr>

<tr>
<td align="left"><tt>u(n)</tt></td>
<td align="left">Application data (n MUST be a multiple of 8)</td>
</tr>
</tbody>
</table></section>

<section anchor="metadata-block-seektable"><name>METADATA<em>BLOCK</em>SEEKTABLE</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>SEEKPOINT</tt>+</td>
<td align="left">One or more seek points.</td>
</tr>
</tbody>
</table><t>NOTE
- The number of seek points is implied by the metadata header 'length' field, i.e. equal to length / 18.</t>
</section>

<section anchor="seekpoint"><name>SEEKPOINT</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(64)</tt></td>
<td align="left">Sample number of first sample in the target frame, or <tt>0xFFFFFFFFFFFFFFFF</tt> for a placeholder point.</td>
</tr>

<tr>
<td align="left"><tt>u(64)</tt></td>
<td align="left">Offset (in bytes) from the first byte of the first frame header to the first byte of the target frame's header.</td>
</tr>

<tr>
<td align="left"><tt>u(16)</tt></td>
<td align="left">Number of samples in the target frame.</td>
</tr>
</tbody>
</table><t>NOTES</t>

<ul>
<li>For placeholder points, the second and third field values are undefined.</li>
<li>Seek points within a table MUST be sorted in ascending order by sample number.</li>
<li>Seek points within a table MUST be unique by sample number, with the exception of placeholder points.</li>
<li>The previous two notes imply that there MAY be any number of placeholder points, but they MUST all occur at the end of the table.</li>
</ul>
</section>

<section anchor="metadata-block-vorbis-comment"><name>METADATA<em>BLOCK</em>VORBIS_COMMENT</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(n)</tt></td>
<td align="left">Also known as FLAC tags, the contents of a vorbis comment packet as specified <eref target="http://www.xiph.org/vorbis/doc/v-comment.html">here</eref> (without the framing bit). Note that the vorbis comment spec allows for on the order of 2^64 bytes of data where as the FLAC metadata block is limited to 2^24 bytes. Given the stated purpose of vorbis comments, i.e. human-readable textual information, this limit is unlikely to be restrictive. Also note that the 32-bit field lengths are little-endian coded according to the vorbis spec, as opposed to the usual big-endian coding of fixed-length integers in the rest of FLAC.</td>
</tr>
</tbody>
</table></section>

<section anchor="metadata-block-cuesheet"><name>METADATA<em>BLOCK</em>CUESHEET</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(128*8)</tt></td>
<td align="left">Media catalog number, in ASCII printable characters 0x20-0x7E. In general, the media catalog number SHOULD be 0 to 128 bytes long; any unused characters SHOULD be right-padded with NUL characters. For CD-DA, this is a thirteen digit number, followed by 115 NUL bytes.</td>
</tr>

<tr>
<td align="left"><tt>u(64)</tt></td>
<td align="left">The number of lead-in samples. This field has meaning only for CD-DA cuesheets; for other uses it SHOULD be 0. For CD-DA, the lead-in is the TRACK 00 area where the table of contents is stored; more precisely, it is the number of samples from the first sample of the media to the first sample of the first index point of the first track. According to the Red Book, the lead-in MUST be silence and CD grabbing software does not usually store it; additionally, the lead-in MUST be at least two seconds but MAY be longer. For these reasons the lead-in length is stored here so that the absolute position of the first track can be computed. Note that the lead-in stored here is the number of samples up to the first index point of the first track, not necessarily to INDEX 01 of the first track; even the first track MAY have INDEX 00 data.</td>
</tr>

<tr>
<td align="left"><tt>u(1)</tt></td>
<td align="left"><tt>1</tt> if the CUESHEET corresponds to a Compact Disc, else <tt>0</tt>.</td>
</tr>

<tr>
<td align="left"><tt>u(7+258*8)</tt></td>
<td align="left">Reserved. All bits MUST be set to zero.</td>
</tr>

<tr>
<td align="left"><tt>u(8)</tt></td>
<td align="left">The number of tracks. Must be at least 1 (because of the requisite lead-out track). For CD-DA, this number MUST be no more than 100 (99 regular tracks and one lead-out track).</td>
</tr>

<tr>
<td align="left"><tt>CUESHEET_TRACK</tt>+</td>
<td align="left">One or more tracks. A CUESHEET block is REQUIRED to have a lead-out track; it is always the last track in the CUESHEET. For CD-DA, the lead-out track number MUST be 170 as specified by the Red Book, otherwise it MUST be 255.</td>
</tr>
</tbody>
</table></section>

<section anchor="cuesheet-track"><name>CUESHEET_TRACK</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(64)</tt></td>
<td align="left">Track offset in samples, relative to the beginning of the FLAC audio stream. It is the offset to the first index point of the track. (Note how this differs from CD-DA, where the track's offset in the TOC is that of the track's INDEX 01 even if there is an INDEX 00.) For CD-DA, the offset MUST be evenly divisible by 588 samples (588 samples = 44100 samples/s * 1/75 s).</td>
</tr>

<tr>
<td align="left"><tt>u(8)</tt></td>
<td align="left">Track number. A track number of 0 is not allowed to avoid conflicting with the CD-DA spec, which reserves this for the lead-in. For CD-DA the number MUST be 1-99, or 170 for the lead-out; for non-CD-DA, the track number MUST for 255 for the lead-out. It is not REQUIRED but encouraged to start with track 1 and increase sequentially. Track numbers MUST be unique within a CUESHEET.</td>
</tr>

<tr>
<td align="left"><tt>u(12*8)</tt></td>
<td align="left">Track ISRC. This is a 12-digit alphanumeric code; see <eref target="http://isrc.ifpi.org/">here</eref> and <eref target="http://www.disctronics.co.uk/technology/cdaudio/cdaud_isrc.htm">here</eref>. A value of 12 ASCII NUL characters MAY be used to denote absence of an ISRC.</td>
</tr>

<tr>
<td align="left"><tt>u(1)</tt></td>
<td align="left">The track type: 0 for audio, 1 for non-audio. This corresponds to the CD-DA Q-channel control bit 3.</td>
</tr>

<tr>
<td align="left"><tt>u(1)</tt></td>
<td align="left">The pre-emphasis flag: 0 for no pre-emphasis, 1 for pre-emphasis. This corresponds to the CD-DA Q-channel control bit 5; see <eref target="http://www.chipchapin.com/CDMedia/cdda9.php3">here</eref>.</td>
</tr>

<tr>
<td align="left"><tt>u(6+13*8)</tt></td>
<td align="left">Reserved. All bits MUST be set to zero.</td>
</tr>

<tr>
<td align="left"><tt>u(8)</tt></td>
<td align="left">The number of track index points. There MUST be at least one index in every track in a CUESHEET except for the lead-out track, which MUST have zero. For CD-DA, this number SHOULD NOT be more than 100.</td>
</tr>

<tr>
<td align="left"><tt>CUESHEET_TRACK_INDEX</tt>+</td>
<td align="left">For all tracks except the lead-out track, one or more track index points.</td>
</tr>
</tbody>
</table></section>

<section anchor="cuesheet-track-index"><name>CUESHEET<em>TRACK</em>INDEX</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(64)</tt></td>
<td align="left">Offset in samples, relative to the track offset, of the index point. For CD-DA, the offset MUST be evenly divisible by 588 samples (588 samples = 44100 samples/s * 1/75 s). Note that the offset is from the beginning of the track, not the beginning of the audio data.</td>
</tr>

<tr>
<td align="left"><tt>u(8)</tt></td>
<td align="left">The index point number. For CD-DA, an index number of 0 corresponds to the track pre-gap. The first index in a track MUST have a number of 0 or 1, and subsequently, index numbers MUST increase by 1. Index numbers MUST be unique within a track.</td>
</tr>

<tr>
<td align="left"><tt>u(3*8)</tt></td>
<td align="left">Reserved. All bits MUST be set to zero.</td>
</tr>
</tbody>
</table></section>

<section anchor="metadata-block-picture"><name>METADATA<em>BLOCK</em>PICTURE</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">The PICTURE_TYPE according to the ID3v2 APIC frame.</td>
</tr>

<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">The length of the MIME type string in bytes.</td>
</tr>

<tr>
<td align="left"><tt>u(n*8)</tt></td>
<td align="left">The MIME type string, in printable ASCII characters 0x20-0x7E. The MIME type MAY also be <tt>--&gt;</tt> to signify that the data part is a URL of the picture instead of the picture data itself.</td>
</tr>

<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">The length of the description string in bytes.</td>
</tr>

<tr>
<td align="left"><tt>u(n*8)</tt></td>
<td align="left">The description of the picture, in UTF-8.</td>
</tr>

<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">The width of the picture in pixels.</td>
</tr>

<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">The height of the picture in pixels.</td>
</tr>

<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">The color depth of the picture in bits-per-pixel.</td>
</tr>

<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">For indexed-color pictures (e.g. GIF), the number of colors used, or <tt>0</tt> for non-indexed pictures.</td>
</tr>

<tr>
<td align="left"><tt>u(32)</tt></td>
<td align="left">The length of the picture data in bytes.</td>
</tr>

<tr>
<td align="left"><tt>u(n*8)</tt></td>
<td align="left">The binary picture data.</td>
</tr>
</tbody>
</table></section>

<section anchor="picture-type"><name>PICTURE_TYPE</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0</td>
<td align="left">Other</td>
</tr>

<tr>
<td align="right">1</td>
<td align="left">32x32 pixels 'file icon' (PNG only)</td>
</tr>

<tr>
<td align="right">2</td>
<td align="left">Other file icon</td>
</tr>

<tr>
<td align="right">3</td>
<td align="left">Cover (front)</td>
</tr>

<tr>
<td align="right">4</td>
<td align="left">Cover (back)</td>
</tr>

<tr>
<td align="right">5</td>
<td align="left">Leaflet page</td>
</tr>

<tr>
<td align="right">6</td>
<td align="left">Media (e.g. label side of CD)</td>
</tr>

<tr>
<td align="right">7</td>
<td align="left">Lead artist/lead performer/soloist</td>
</tr>

<tr>
<td align="right">8</td>
<td align="left">Artist/performer</td>
</tr>

<tr>
<td align="right">9</td>
<td align="left">Conductor</td>
</tr>

<tr>
<td align="right">10</td>
<td align="left">Band/Orchestra</td>
</tr>

<tr>
<td align="right">11</td>
<td align="left">Composer</td>
</tr>

<tr>
<td align="right">12</td>
<td align="left">Lyricist/text writer</td>
</tr>

<tr>
<td align="right">13</td>
<td align="left">Recording Location</td>
</tr>

<tr>
<td align="right">14</td>
<td align="left">During recording</td>
</tr>

<tr>
<td align="right">15</td>
<td align="left">During performance</td>
</tr>

<tr>
<td align="right">16</td>
<td align="left">Movie/video screen capture</td>
</tr>

<tr>
<td align="right">17</td>
<td align="left">A bright colored fish</td>
</tr>

<tr>
<td align="right">18</td>
<td align="left">Illustration</td>
</tr>

<tr>
<td align="right">19</td>
<td align="left">Band/artist logotype</td>
</tr>

<tr>
<td align="right">20</td>
<td align="left">Publisher/Studio logotype</td>
</tr>
</tbody>
</table><t>Other values are reserved and SHOULD NOT be used. There MAY only be one each of picture type 1 and 2 in a file.</t>
</section>

<section anchor="frame"><name>FRAME</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>FRAME_HEADER</tt></td>
<td align="left"></td>
</tr>

<tr>
<td align="left"><tt>SUBFRAME</tt>+</td>
<td align="left">One SUBFRAME per channel.</td>
</tr>

<tr>
<td align="left"><tt>u(?)</tt></td>
<td align="left">Zero-padding to byte alignment.</td>
</tr>

<tr>
<td align="left"><tt>FRAME_FOOTER</tt></td>
<td align="left"></td>
</tr>
</tbody>
</table></section>

<section anchor="frame-header"><name>FRAME_HEADER</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(14)</tt></td>
<td align="left">Sync code '0b11111111111110'</td>
</tr>

<tr>
<td align="left"><tt>u(1)</tt></td>
<td align="left"><tt>FRAME HEADER RESERVED</tt></td>
</tr>

<tr>
<td align="left"><tt>u(1)</tt></td>
<td align="left"><tt>BLOCKING STRATEGY</tt></td>
</tr>

<tr>
<td align="left"><tt>u(4)</tt></td>
<td align="left"><tt>INTERCHANNEL SAMPLE BLOCK SIZE</tt></td>
</tr>

<tr>
<td align="left"><tt>u(4)</tt></td>
<td align="left"><tt>SAMPLE RATE</tt></td>
</tr>

<tr>
<td align="left"><tt>u(4)</tt></td>
<td align="left"><tt>CHANNEL ASSIGNMENT</tt></td>
</tr>

<tr>
<td align="left"><tt>u(3)</tt></td>
<td align="left"><tt>SAMPLE SIZE</tt></td>
</tr>

<tr>
<td align="left"><tt>u(1)</tt></td>
<td align="left"><tt>FRAME HEADER RESERVED2</tt></td>
</tr>

<tr>
<td align="left"><tt>u(?)</tt></td>
<td align="left"><tt>CODED NUMBER</tt></td>
</tr>

<tr>
<td align="left"><tt>u(?)</tt></td>
<td align="left"><tt>BLOCK SIZE INT</tt></td>
</tr>

<tr>
<td align="left"><tt>u(?)</tt></td>
<td align="left"><tt>SAMPLE RATE INT</tt></td>
</tr>

<tr>
<td align="left"><tt>u(8)</tt></td>
<td align="left"><tt>FRAME CRC</tt></td>
</tr>
</tbody>
</table>
<section anchor="frame-header-reserved"><name>FRAME HEADER RESERVED</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0</td>
<td align="left">mandatory value</td>
</tr>

<tr>
<td align="right">1</td>
<td align="left">reserved for future use</td>
</tr>
</tbody>
</table><t>FRAME HEADER RESERVED MUST remain reserved for <tt>0</tt> in order for a FLAC frame's initial 15 bits to be distinguishable from the start of an MPEG audio frame (<eref target="http://lists.xiph.org/pipermail/flac-dev/2008-December/002607.html">see also</eref>).</t>
</section>

<section anchor="blocking-strategy"><name>BLOCKING STRATEGY</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0</td>
<td align="left">fixed-blocksize stream; frame header encodes the frame number</td>
</tr>

<tr>
<td align="right">1</td>
<td align="left">variable-blocksize stream; frame header encodes the sample number</td>
</tr>
</tbody>
</table><t>The <tt>BLOCKING STRATEGY</tt> bit MUST be the same throughout the entire stream.</t>
<t>The <tt>BLOCKING STRATEGY</tt> bit determines how to calculate the sample number of the first sample in the frame. If the bit is <tt>0</tt> (fixed-blocksize), the frame header encodes the frame number as above, and the frame's starting sample number will be the frame number times the blocksize. If it is <tt>1</tt> (variable-blocksize), the frame header encodes the frame's starting sample number itself. (In the case of a fixed-blocksize stream, only the last block MAY be shorter than the stream blocksize; its starting sample number will be calculated as the frame number times the previous frame's blocksize, or zero if it is the first frame).</t>
</section>

<section anchor="interchannel-sample-block-size"><name>INTERCHANNEL SAMPLE BLOCK SIZE</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0b0000</td>
<td align="left">reserved</td>
</tr>

<tr>
<td align="right">0b0001</td>
<td align="left">192 samples</td>
</tr>

<tr>
<td align="right">0b0010 - 0b0101</td>
<td align="left">576 * (2^(n-2)) samples, i.e. 576, 1152, 2304 or 4608</td>
</tr>

<tr>
<td align="right">0b0110</td>
<td align="left">get 8 bit (blocksize-1) from end of header</td>
</tr>

<tr>
<td align="right">0b0111</td>
<td align="left">get 16 bit (blocksize-1) from end of header</td>
</tr>

<tr>
<td align="right">0b1000 - 0b1111</td>
<td align="left">256 * (2^(n-8)) samples, i.e. 256, 512, 1024, 2048, 4096, 8192, 16384 or 32768</td>
</tr>
</tbody>
</table></section>

<section anchor="sample-rate"><name>SAMPLE RATE</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0b0000</td>
<td align="left">get from STREAMINFO metadata block</td>
</tr>

<tr>
<td align="right">0b0001</td>
<td align="left">88.2 kHz</td>
</tr>

<tr>
<td align="right">0b0010</td>
<td align="left">176.4 kHz</td>
</tr>

<tr>
<td align="right">0b0011</td>
<td align="left">192 kHz</td>
</tr>

<tr>
<td align="right">0b0100</td>
<td align="left">8 kHz</td>
</tr>

<tr>
<td align="right">0b0101</td>
<td align="left">16 kHz</td>
</tr>

<tr>
<td align="right">0b0110</td>
<td align="left">22.05 kHz</td>
</tr>

<tr>
<td align="right">0b0111</td>
<td align="left">24 kHz</td>
</tr>

<tr>
<td align="right">0b1000</td>
<td align="left">32 kHz</td>
</tr>

<tr>
<td align="right">0b1001</td>
<td align="left">44.1 kHz</td>
</tr>

<tr>
<td align="right">0b1010</td>
<td align="left">48 kHz</td>
</tr>

<tr>
<td align="right">0b1011</td>
<td align="left">96 kHz</td>
</tr>

<tr>
<td align="right">0b1100</td>
<td align="left">get 8 bit sample rate (in kHz) from end of header</td>
</tr>

<tr>
<td align="right">0b1101</td>
<td align="left">get 16 bit sample rate (in Hz) from end of header</td>
</tr>

<tr>
<td align="right">0b1110</td>
<td align="left">get 16 bit sample rate (in daHz) from end of header</td>
</tr>

<tr>
<td align="right">0b1111</td>
<td align="left">invalid, to prevent sync-fooling string of 1s</td>
</tr>
</tbody>
</table></section>

<section anchor="channel-assignment"><name>CHANNEL ASSIGNMENT</name>
<t>Values 0b0000-0b0111 represent the (number of independent channels)-1 coded independently, channel order follows SMPTE/ITU-R recommendations. Values 0b1000-0b1010 represent 2 channel (stereo) audio where the signal has been mapped to a different representation, see <eref target="#interchannel-decorrelation">section on Interchannel Decorrelation</eref>.</t>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0b0000</td>
<td align="left">1 channel: mono</td>
</tr>

<tr>
<td align="right">0b0001</td>
<td align="left">2 channels: left, right</td>
</tr>

<tr>
<td align="right">0b0010</td>
<td align="left">3 channels: left, right, center</td>
</tr>

<tr>
<td align="right">0b0011</td>
<td align="left">4 channels: front left, front right, back left, back right</td>
</tr>

<tr>
<td align="right">0b0100</td>
<td align="left">5 channels: front left, front right, front center, back/surround left, back/surround right</td>
</tr>

<tr>
<td align="right">0b0101</td>
<td align="left">6 channels: front left, front right, front center, LFE, back/surround left, back/surround right</td>
</tr>

<tr>
<td align="right">0b0110</td>
<td align="left">7 channels: front left, front right, front center, LFE, back center, side left, side right</td>
</tr>

<tr>
<td align="right">0b0111</td>
<td align="left">8 channels: front left, front right, front center, LFE, back left, back right, side left, side right</td>
</tr>

<tr>
<td align="right">0b1000</td>
<td align="left">left/side stereo: channel 0 is the left channel, channel 1 is the side(difference) channel</td>
</tr>

<tr>
<td align="right">0b1001</td>
<td align="left">right/side stereo: channel 0 is the side(difference) channel, channel 1 is the right channel</td>
</tr>

<tr>
<td align="right">0b1010</td>
<td align="left">mid/side stereo: channel 0 is the mid(average) channel, channel 1 is the side(difference) channel</td>
</tr>

<tr>
<td align="right">0b1011 - 0b1111</td>
<td align="left">reserved</td>
</tr>
</tbody>
</table><t>Please note that the actual coded subframe order for right/side stereo is side-right.</t>
</section>

<section anchor="sample-size"><name>SAMPLE SIZE</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0b000</td>
<td align="left">get from STREAMINFO metadata block</td>
</tr>

<tr>
<td align="right">0b001</td>
<td align="left">8 bits per sample</td>
</tr>

<tr>
<td align="right">0b010</td>
<td align="left">12 bits per sample</td>
</tr>

<tr>
<td align="right">0b011</td>
<td align="left">reserved</td>
</tr>

<tr>
<td align="right">0b100</td>
<td align="left">16 bits per sample</td>
</tr>

<tr>
<td align="right">0b101</td>
<td align="left">20 bits per sample</td>
</tr>

<tr>
<td align="right">0b110</td>
<td align="left">24 bits per sample</td>
</tr>

<tr>
<td align="right">0b111</td>
<td align="left">reserved</td>
</tr>
</tbody>
</table><t>For subframes that encode a difference channel, the sample size is one bit larger than the sample size of the frame, in order to be able to encode the difference between extreme values.</t>
</section>

<section anchor="frame-header-reserved2"><name>FRAME HEADER RESERVED2</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0</td>
<td align="left">mandatory value</td>
</tr>

<tr>
<td align="right">1</td>
<td align="left">reserved for future use</td>
</tr>
</tbody>
</table></section>

<section anchor="coded-number"><name>CODED NUMBER</name>
<t>Frame/Sample numbers are encoded using the UTF-8 format, from BEFORE it was limited to 4 bytes by RFC3629, this variant supports the original 7 byte maximum.</t>
<t>Note to implementors: All Unicode compliant UTF-8 decoders and encoders are limited to 4 bytes, it's best to just write your own one off solution.</t>

<artwork>if(variable blocksize)
  `u(8...56)`: &quot;UTF-8&quot; coded sample number (decoded number is 36 bits)
else
  `u(8...48)`: &quot;UTF-8&quot; coded frame number (decoded number is 31 bits)
</artwork>
</section>

<section anchor="block-size-int"><name>BLOCK SIZE INT</name>

<artwork>if(`INTERCHANNEL SAMPLE BLOCK SIZE` == 0b0110)
  8 bit (blocksize-1)
else if(`INTERCHANNEL SAMPLE BLOCK SIZE` == 0b0111)
  16 bit (blocksize-1)
</artwork>
</section>

<section anchor="sample-rate-int"><name>SAMPLE RATE INT</name>

<artwork>if(`SAMPLE RATE` == 0b1100)
  8 bit sample rate (in kHz)
else if(`SAMPLE RATE` == 0b1101)
  16 bit sample rate (in Hz)
else if(`SAMPLE RATE` == 0b1110)
  16 bit sample rate (in daHz)
</artwork>
</section>

<section anchor="frame-crc"><name>FRAME CRC</name>
<t>CRC-8 (polynomial = x^8 + x^2 + x^1 + x^0, initialized with 0) of everything before the CRC, including the sync code</t>
</section>
</section>

<section anchor="frame-footer"><name>FRAME_FOOTER</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(16)</tt></td>
<td align="left">CRC-16 (polynomial = x^16 + x^15 + x^2 + x^0, initialized with 0) of everything before the CRC, back to and including the frame header sync code</td>
</tr>
</tbody>
</table></section>

<section anchor="subframe"><name>SUBFRAME</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>SUBFRAME_HEADER</tt></td>
<td align="left"></td>
</tr>

<tr>
<td align="left"><tt>SUBFRAME_CONSTANT</tt> || <tt>SUBFRAME_FIXED</tt> || <tt>SUBFRAME_LPC</tt> || <tt>SUBFRAME_VERBATIM</tt></td>
<td align="left">The SUBFRAME_HEADER specifies which one.</td>
</tr>
</tbody>
</table></section>

<section anchor="subframe-header"><name>SUBFRAME_HEADER</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(1)</tt></td>
<td align="left">Zero bit padding, to prevent sync-fooling string of 1s</td>
</tr>

<tr>
<td align="left"><tt>u(6)</tt></td>
<td align="left"><tt>SUBFRAME TYPE</tt> (see <eref target="#subframe-type">section on SUBFRAME TYPE</eref>)</td>
</tr>

<tr>
<td align="left"><tt>u(1+k)</tt></td>
<td align="left"><tt>WASTED BITS PER SAMPLE FLAG</tt> (see <eref target="#wasted-bits-per-sample-flag">section on WASTED BITS PER SAMPLE FLAG</eref>)</td>
</tr>
</tbody>
</table>
<section anchor="subframe-type"><name>SUBFRAME TYPE</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0b000000</td>
<td align="left"><tt>SUBFRAME_CONSTANT</tt></td>
</tr>

<tr>
<td align="right">0b000001</td>
<td align="left"><tt>SUBFRAME_VERBATIM</tt></td>
</tr>

<tr>
<td align="right">0b00001x</td>
<td align="left">reserved</td>
</tr>

<tr>
<td align="right">0b0001xx</td>
<td align="left">reserved</td>
</tr>

<tr>
<td align="right">0b001xxx</td>
<td align="left">if(xxx &lt;= 4) <tt>SUBFRAME_FIXED</tt>, xxx=order; else reserved</td>
</tr>

<tr>
<td align="right">0b01xxxx</td>
<td align="left">reserved</td>
</tr>

<tr>
<td align="right">0b1xxxxx</td>
<td align="left"><tt>SUBFRAME_LPC</tt>, xxxxx=order-1</td>
</tr>
</tbody>
</table></section>

<section anchor="wasted-bits-per-sample-flag"><name>WASTED BITS PER SAMPLE FLAG</name>
<t>Certain file formats, like AIFF, can store audio samples with a bit depth that is not an integer number of bytes by padding them with least significant zero bits to a bit depth that is an integer number of bytes. For example, shifting a 14-bit sample right by 2 pads it to a 16-bit sample, which then has two zero least-significant bits. In this specification, these least-significant zero bits are referred to as wasted bits-per-sample or simply wasted bits. They are wasted in a sense that they contain no information, but are stored anyway.</t>
<t>The wasted bits-per-sample flag in a subframe header is set to 1 if a certain number of least-significant bits of all samples in the current subframe are zero. If this is the case, the number of wasted bits-per-sample (k) minus 1 follows the flag in an unary encoding. For example, if k is 3, 0b001 follows. If k = 0, the wasted bits-per-sample flag is 0 and no unary coded k follows.</t>
<t>In case k is not equal to 0, samples are coded ignoring k least-significant bits. For example, if the preceding frame header specified a sample size of 16 bits per sample and k is 3, samples in the subframe are coded as 13 bits per sample. A decoder MUST add k least-significant zero bits by shifting left (padding) after decoding a subframe sample. In case the frame has left/side, right/side or mid/side stereo, padding MUST happen to a sample before it is used to reconstruct a left or right sample.</t>
<t>Besides audio files that have a certain number of wasted bits for the whole file, there exist audio files in which the number of wasted bits varies. There are DVD-Audio discs in which blocks of samples have had their least-significant bits selectively zeroed, as to slightly improve the compression of their otherwise lossless Meridian Lossless Packing codec. There are also audio processors like lossyWAV that enable users to improve compression of their files by a lossless audio codec in a non-lossless way. Because of this the number of wasted bits k MAY change between frames and MAY differ between subframes.</t>
</section>
</section>

<section anchor="subframe-constant"><name>SUBFRAME_CONSTANT</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(n)</tt></td>
<td align="left">Unencoded constant value of the subblock, n = frame's bits-per-sample.</td>
</tr>
</tbody>
</table></section>

<section anchor="subframe-fixed"><name>SUBFRAME_FIXED</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(n)</tt></td>
<td align="left">Unencoded warm-up samples (n = frame's bits-per-sample * predictor order).</td>
</tr>

<tr>
<td align="left"><tt>RESIDUAL</tt></td>
<td align="left">Encoded residual</td>
</tr>
</tbody>
</table></section>

<section anchor="subframe-lpc"><name>SUBFRAME_LPC</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(n)</tt></td>
<td align="left">Unencoded warm-up samples (n = frame's bits-per-sample * lpc order).</td>
</tr>

<tr>
<td align="left"><tt>u(4)</tt></td>
<td align="left">(quantized linear predictor coefficients' precision in bits)-1 (NOTE: 0b1111 is invalid).</td>
</tr>

<tr>
<td align="left"><tt>u(5)</tt></td>
<td align="left">Quantized linear predictor coefficient shift needed in bits (NOTE: this number is signed two's-complement).</td>
</tr>

<tr>
<td align="left"><tt>u(n)</tt></td>
<td align="left">Unencoded predictor coefficients (n = qlp coeff precision * lpc order) (NOTE: the coefficients are signed two's-complement).</td>
</tr>

<tr>
<td align="left"><tt>RESIDUAL</tt></td>
<td align="left">Encoded residual</td>
</tr>
</tbody>
</table></section>

<section anchor="subframe-verbatim"><name>SUBFRAME_VERBATIM</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(n\*i)</tt></td>
<td align="left">Unencoded subblock, where <tt>n</tt> is frame's bits-per-sample and <tt>i</tt> is frame's blocksize.</td>
</tr>
</tbody>
</table></section>

<section anchor="residual"><name>RESIDUAL</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(2)</tt></td>
<td align="left"><tt>RESIDUAL_CODING_METHOD</tt></td>
</tr>

<tr>
<td align="left"><tt>RESIDUAL_CODING_METHOD_PARTITIONED_EXP_GOLOMB</tt> || <tt>RESIDUAL_CODING_METHOD_PARTITIONED_EXP_GOLOMB2</tt></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<section anchor="residual-coding-method"><name>RESIDUAL<em>CODING</em>METHOD</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0b00</td>
<td align="left">partitioned Exp-Golomb coding with 4-bit Exp-Golomb parameter; RESIDUAL<em>CODING</em>METHOD<em>PARTITIONED</em>EXP_GOLOMB follows</td>
</tr>

<tr>
<td align="right">0b01</td>
<td align="left">partitioned Exp-Golomb coding with 5-bit Exp-Golomb parameter; RESIDUAL<em>CODING</em>METHOD<em>PARTITIONED</em>EXP_GOLOMB2 follows</td>
</tr>

<tr>
<td align="right">0b10 - 0b11</td>
<td align="left">reserved</td>
</tr>
</tbody>
</table></section>

<section anchor="residual-coding-method-partitioned-exp-golomb"><name>RESIDUAL<em>CODING</em>METHOD<em>PARTITIONED</em>EXP_GOLOMB</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(4)</tt></td>
<td align="left">Partition order.</td>
</tr>

<tr>
<td align="left"><tt>EXP_GOLOMB_PARTITION</tt>+</td>
<td align="left">There will be 2^order partitions.</td>
</tr>
</tbody>
</table>
<section anchor="exp-golomb-partition"><name>EXP<em>GOLOMB</em>PARTITION</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(4(+5))</tt></td>
<td align="left"><tt>EXP-GOLOMB PARTITION ENCODING PARAMETER</tt> (see <eref target="#exp-golomb-partition-encoding-parameter">section on EXP-GOLOMB PARTITION ENCODING PARAMETER</eref>)</td>
</tr>

<tr>
<td align="left"><tt>u(?)</tt></td>
<td align="left"><tt>ENCODED RESIDUAL</tt> (see <eref target="#encoded-residual">section on ENCODED RESIDUAL</eref>)</td>
</tr>
</tbody>
</table></section>

<section anchor="exp-golomb-partition-encoding-parameter"><name>EXP GOLOMB PARTITION ENCODING PARAMETER</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0b0000 - 0b1110</td>
<td align="left">Exp-golomb parameter.</td>
</tr>

<tr>
<td align="right">0b1111</td>
<td align="left">Escape code, meaning the partition is in unencoded binary form using n bits per sample; n follows as a 5-bit number.</td>
</tr>
</tbody>
</table></section>
</section>

<section anchor="residual-coding-method-partitioned-exp-golomb2"><name>RESIDUAL<em>CODING</em>METHOD<em>PARTITIONED</em>EXP_GOLOMB2</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(4)</tt></td>
<td align="left">Partition order.</td>
</tr>

<tr>
<td align="left"><tt>EXP-GOLOMB2_PARTITION</tt>+</td>
<td align="left">There will be 2^order partitions.</td>
</tr>
</tbody>
</table>
<section anchor="exp-golomb2-partition"><name>EXP<em>GOLOMB2</em>PARTITION</name>
<table>
<thead>
<tr>
<th align="left">Data</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><tt>u(5(+5))</tt></td>
<td align="left"><tt>EXP-GOLOMB2 PARTITION ENCODING PARAMETER</tt> (see <eref target="#expgolomb2-partition-encoding-parameter">section on EXP-GOLOMB2 PARTITION ENCODING PARAMETER</eref>)</td>
</tr>

<tr>
<td align="left"><tt>u(?)</tt></td>
<td align="left"><tt>ENCODED RESIDUAL</tt> (see <eref target="#encoded-residual">section on ENCODED RESIDUAL</eref>)</td>
</tr>
</tbody>
</table></section>

<section anchor="exp-golomb2-partition-encoding-parameter"><name>EXP-GOLOMB2 PARTITION ENCODING PARAMETER</name>
<table>
<thead>
<tr>
<th align="right">Value</th>
<th align="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td align="right">0b00000 - 0b11110</td>
<td align="left">Exp-golomb parameter.</td>
</tr>

<tr>
<td align="right">0b11111</td>
<td align="left">Escape code, meaning the partition is in unencoded binary form using n bits per sample; n follows as a 5-bit number.</td>
</tr>
</tbody>
</table></section>
</section>

<section anchor="encoded-residual"><name>ENCODED RESIDUAL</name>
<t>The number of samples (n) in the partition is determined as follows:</t>

<ul>
<li>if the partition order is zero, n = frame's blocksize - predictor order</li>
<li>else if this is not the first partition of the subframe, n = (frame's blocksize / (2^partition order))</li>
<li>else n = (frame's blocksize / (2^partition order)) - predictor order</li>
</ul>
</section>
</section>
</section>

<section anchor="security-considerations"><name>Security Considerations</name>
<t>Like any other codec (such as <xref target="RFC6716"></xref>), FLAC should not be used with insecure ciphers or cipher modes that are vulnerable to known plaintext attacks. Some of the header bits as well as the padding are easily predictable.</t>
<t>Implementations of the FLAC codec need to take appropriate security considerations into account. Those related to denial of service are outlined in Section 2.1 of <xref target="RFC4732"></xref>. It is extremely important for the decoder to be robust against malicious payloads. Malicious payloads <bcp14>MUST NOT</bcp14> cause the decoder to overrun its allocated memory or to take an excessive amount of resources to decode. An overrun in allocated memory could lead to arbitrary code execution by an attacker. The same applies to the encoder, even though problems in encoders are typically rarer. Malicious audio streams <bcp14>MUST NOT</bcp14> cause the encoder to misbehave because this would allow an attacker to attack transcoding gateways. An example is allocating more memory than available especially with blocksizes of more than 10000 or with big metadata blocks, or not allocating enough memory before copying data, which lead to execution of malicious code, crashes, freezes or reboots on some known implementations.
See the <eref target="https://wiki.hydrogenaud.io/index.php?title=FLAC_decoder_testbench">FLAC decoder testbench</eref> for a non-exhaustive list of FLAC files with extreme configurations which lead to crashes or reboots on some known implementations.</t>
<t>None of the content carried in FLAC is intended to be executable.</t>
</section>

</middle>

<back>
<references><name>Normative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4732.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
</references>
<references><name>Informative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6716.xml"/>
</references>

</back>

</rfc>

