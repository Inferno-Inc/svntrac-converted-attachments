<?xml version="1.0" encoding="utf-8"?>
<!-- name="GENERATOR" content="github.com/mmarkdown/mmark markdown processor for Go" -->
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>
<rfc ipr="trust200902" submissionType="IETF" category="info" xml:lang="en" consensus="no" docName="draft-learning-go-00">
<?rfc toc="yes"?><?rfc symrefs="yes"?><?rfc sortrefs="yes"?><?rfc compact="yes"?><?rfc subcompact="no"?><?rfc comments="no"?>
<front>
<title abbrev="Learning Go">Learning Go</title><author initials="R." surname="Gieben" fullname="R. (Miek) Gieben"><organization></organization><address><postal><street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal><phone></phone>
<email>miek@miek.nl</email>
<uri></uri>
</address></author>
<date year="2018" month="8" day="25"></date>
<area>Application</area><workgroup>Go Working Group</workgroup><keyword>Go</keyword>
<keyword>Language</keyword>
<keyword>Computer</keyword>

</front>

<middle>

<section anchor="preface" title="Preface">
<t>The <eref target="https://github.com/miekg/learninggo">source of this book</eref> is written in
<eref target="https://github.com/mmarkdown/mmark">mmark</eref> and is converted from the <eref target="https://github.com/miekg/gobook">original
LaTeX source</eref>.</t>
<t><spanx style="emph">All example code used in this book is hereby licensed under the Apache License version 2.0.</spanx></t>
<t>
<list style="empty">
<t>This work is licensed under the Attribution-NonCommercial-ShareAlike 3.0 Unported License. To
view a copy of this license, visit <eref target="http://creativecommons.org/licenses/by-nc-sa/3.0/">http://creativecommons.org/licenses/by-nc-sa/3.0/</eref>
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.</t>
</list></t>
<t>The following people made large or small contributions to earlier versions of this book:</t>
<t>Adam J. Gray,
Alexander Katasonov,
Alexey Chernenkov,
Alex Sychev,
Andrea Spadaccini,
Andrey Mirtchovski,
Anthony Magro,
Babu Sreekanth,
Ben Bullock,
Bob Cunningham,
Brian Fallik,
Cecil New,
Cobold,
Damian Gryski,
Daniele Pala,
Dan Kortschak,
David Otton,
Fabian Becker,
Filip Zaludek,
Hadi Amiri,
Haiping Fan,
Iaroslav Tymchenko,
Jaap Akkerhuis,
JC van Winkel,
Jeroen Bulten,
Jinpu Hu,
John Shahid,
Jonathan Kans,
Joshua Stein,
Makoto Inoue,
Marco Ynema,
Mayuresh Kathe,
Mem,
Michael Stapelberg,
Nicolas Kaiser,
Olexandr Shalakhin,
Paulo Pinto,
Peter Kleiweg,
Philipp Schmidt,
Robert Johnson,
Russel Winder,
Simoc,
Sonia Keys,
Stefan Schroeder,
Thomas Kapplet,
T.J. Yang,
Uriel<spanx style="verb">\dagger</spanx>,
Vrai Stacey,
Xing Xing.</t>
<t>&quot;Learning Go&quot; has been translated into (note that this used the original LaTeX source).</t>
<t>
<list style="symbols">
<t>Chinese, by Xing Xing, 这里是中文译本: <eref target="http://www.mikespook.com/learning-go/">http://www.mikespook.com/learning-go/</eref></t>
</list>
</t>
<t>I hope this book is useful.</t>
<t>Miek Gieben, London, 2015.</t>
<t>This book still sees development, small incremental improvements trickle in from Github.</t>
<t>Miek Gieben, London, 2017.</t>
<t>Learning Go's source has been rewritten in <eref target="https://github.com/mmarkdown/mmark">mmark2</eref>, but did not see any
other changes. This books translates cleanly into an <eref target="learninggo-2.txt">RFC-like document</eref>.</t>
<t>Miek Gieben, London, 2018.</t>
</section>

<section anchor="learning-go" title="Learning Go">
<figure></figure>
</section>

<section anchor="introduction" title="Introduction">
<t>
<list style="empty">
<t>Is Go an object-oriented language? Yes and no.</t>
<t>Frequently asked questions, Go Authors
</t>
</list></t>
<t>The Go programming language is an open source project language to make programmers more productive.</t>
<t>According to the website <xref target="go_web"></xref> &quot;Go is expressive, concise, clean, and efficient&quot;. And indeed it
is. My initial interest was piqued when I read early announcements about this new language that had
built-in concurreny and a C-like syntax (Erlang also has built-in concurrency, but I could never get
used to its syntax). Go is a compiled statically typed language that feels like a dynamically typed,
interpreted language. My go to (scripting!) language Perl has taken a back seat now that Go is
around.</t>
<t>The unique Go language is defined by these principles:</t>
<t>
<list style="hanging">
<t hangText="Clean and Simple">
<vspace />Go strives to keep things small and beautiful. You should be able to do a lot in only a few
lines of code.</t>
<t hangText="Concurrent">
<vspace />Go makes it easy to &quot;fire off&quot; functions to be run as <spanx style="emph">very</spanx> lightweight threads. These threads
are called goroutines <iref item="goroutine"/> in Go.</t>
<t hangText="Channels">
<vspace />Communication with these goroutines is done, either via shared state or via <iref item="channels"/>
channels <xref target="csp"></xref>.</t>
<t hangText="Fast">
<vspace />Compilation is fast and execution is fast. The aim is to be as fast as C. Compilation time is
measured in seconds.</t>
<t hangText="Safe">
<vspace />Explicit casting and strict rules when converting one type to another. Go has garbage
collection. No more <spanx style="verb">free()</spanx> in Go: the language takes care of this.</t>
<t hangText="Standard format">
<vspace />A Go program can be formatted in (almost) any way the programmers want, but an official format
exists. The rule is very simple: The output of the filter <spanx style="verb">gofmt</spanx> <spanx style="emph">is the officially endorsed
format</spanx>.</t>
<t hangText="Postfix types">
<vspace />Types are given <spanx style="emph">after</spanx> the variable name, thus <spanx style="verb">var a int</spanx>, instead of <spanx style="verb">int a</spanx>.</t>
<t hangText="UTF-8">
<vspace />UTF-8 is everywhere, in strings <spanx style="emph">and</spanx> in the program code. Finally you can use <spanx style="verb">\Phi = \Phi + 1</spanx>
in your source code.</t>
<t hangText="Open Source">
<vspace />The Go license is completely open source.</t>
<t hangText="Fun">
<vspace />Programming with Go should be fun!</t>
</list>
</t>
<t>As I mentioned Erlang also shares some features of Go. A notable difference between Erlang and Go is
that Erlang borders on being a functional language, while Go is imperative. And Erlang runs in
a virtual machine, while Go is compiled.</t>

<section anchor="how-to-read-this-book" title="How to Read this Book">
<t>I've written this book for people who already know some programming languages and how to program. In
order to use this book, you (of course) need Go installed on your system, but you can easily try
examples online in the Go playground. All exercises in this book work
with Go 1, the first stable release of Go -- if not, it's a bug.</t>
<t>The best way to learn Go is to create your own programs. Each chapter therefore includes exercises
(and answers to exercises) to acquaint you with the language. Each exercise is either <spanx style="emph">easy</spanx>,
<spanx style="emph">intermediate</spanx>, or <spanx style="emph">difficult</spanx>. The answers are included after the exercises on a new page. Some
exercises don't have an answer; these are marked with an asterisk.</t>
<t>Here's what you can expect from each chapter:</t>
<t>
<list style="hanging">
<t hangText="basics">
<vspace />We'll look at the basic types, variables, and control structures available in the language.</t>
<t hangText="functions">
<vspace />Here we look at functions, the basic building blocks of Go programs.</t>
<t hangText="packages">
<vspace />We'll see that functions and data can be grouped together in packages. We'll also see how to
document and test our packages.</t>
<t hangText="beyond-the-basics">
<vspace />We'll create our own types. We'll also look at memory allocations in Go.</t>
<t hangText="interfaces">
<vspace />We'll learn how to use interfaces. Interfaces are the central concept in Go,
as Go does not support object orientation in the traditional sense.</t>
<t hangText="concurrency">
<vspace />We'll learn the <spanx style="verb">go</spanx> keyword, which can be used to start function in separate routines (called
goroutines). Communication with those goroutines is done via channels.</t>
<t hangText="communication">
<vspace />Finally we'll see how to interface with the rest of the world from within a Go program. We'll
see how to create files and read and write to and from them. We'll also briefly look into
networking.</t>
</list>
</t>
</section>

<section anchor="official-documentation" title="Official Documentation">
<t>There is a substantial amount of documentation written about Go. The Go Tutorial <xref target="go_tutorial"></xref>, the
Go Tour (with lots of exercises) and the Effective Go <xref target="effective_go"></xref> are helpful resources. The
website <eref target="http://golang.org/doc/">http://golang.org/doc/</eref> is a very good starting point for reading up on
Go. Reading these documents is certainly not
required, but it is recommended.</t>
<t>
<list style="empty">
<t>When searching on the internet use the term &quot;golang&quot; instead of plain &quot;go&quot;.</t>
</list></t>
<t>Go comes with its own documentation in the form of a program called <spanx style="verb">godoc</spanx>. If you are
interested in the documentation for the built-ins, simply do this:</t>

<figure><artwork>% godoc builtin
</artwork></figure>

<t>To get the documentation of the <spanx style="verb">hash</spanx> package, just:</t>

<figure><artwork>% godoc hash
</artwork></figure>

<t>To read the documentation of <spanx style="verb">fnv</spanx> contained in <spanx style="verb">hash</spanx>, you'll need to issue <spanx style="verb">godoc hash/fnv</spanx> as
<spanx style="verb">fnv</spanx> is a subdirectory of <spanx style="verb">hash</spanx>.</t>

<figure><artwork type="go">PACKAGE DOCUMENTATION

package fnv
    import &quot;hash/fnv&quot;

    Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash
    ...
</artwork></figure>

</section>
</section>

<section anchor="basics" title="Basics">
<t>
<list style="empty">
<t>I am interested in this and hope to do something.</t>
<t>On adding complex numbers to Go, Ken Thompson
</t>
</list></t>
<t>In this chapter we will look at the basic building blocks of the Go programming
language.</t>

<section anchor="hello-world" title="Hello World">
<t>In the Go tutorial, you get started with Go in the typical manner: printing
&quot;Hello World&quot; (Ken Thompson and Dennis Ritchie started this when they presented
the C language in the 1970s). That's a great way to start, so here it is, &quot;Hello
World&quot; in Go.</t>

<figure><artwork type="go">package main &lt;1&gt;

import &quot;fmt&quot; &lt;2&gt; // Implements formatted I/O.

/* Print something */ &lt;3&gt;
func main() {         &lt;4&gt;
	fmt.Printf(&quot;Hello, world.&quot;) &lt;5&gt;
}
</artwork></figure>

<t>Lets look at the program line by line. This first line is just required <spanx style="emph">1</spanx>. All
Go files start with <spanx style="verb">package &lt;something&gt;</spanx>, and <spanx style="verb">package main</spanx> is required for
a standalone executable.</t>
<t><spanx style="verb">import &quot;fmt&quot;</spanx> says we need <spanx style="verb">fmt</spanx> in addition to <spanx style="verb">main</spanx> <spanx style="emph">2</spanx>. A package other
than <spanx style="verb">main</spanx> is commonly called a library, a familiar concept in many programming
languages (see <xref target="packages"></xref>). The line ends with a comment that begins with <spanx style="verb">//</spanx>.</t>
<t>Next we another comment, but this one is enclosed in <spanx style="verb">/*</spanx> <spanx style="verb">*/</spanx> <spanx style="emph">3</spanx>. When your Go
program is executed, the first function called will be <spanx style="verb">main.main()</spanx>, which
mimics the behavior from C. Here we declare that function <spanx style="emph">4</spanx>.</t>
<t>Finally we call a function from the package <spanx style="verb">fmt</spanx> to print a string to the
screen. The string is enclosed with <spanx style="verb">&quot;</spanx> and may contain non-ASCII characters
<spanx style="emph">5</spanx>.</t>
</section>

<section anchor="compiling-and-running-code" title="Compiling and Running Code">
<t>To build a Go program, use the <spanx style="verb">go</spanx> tool.<iref item="tooling" subitem="go"/>
To build <spanx style="verb">helloworld</spanx> we just enter:</t>

<figure><artwork>% go build helloworld.go
</artwork></figure>

<t><iref item="tooling" subitem="go build"/>
This results in an executable called <spanx style="verb">helloworld</spanx>. <iref item="tooling" subitem="go run"/></t>

<figure><artwork>% ./helloworld
Hello, world.
</artwork></figure>

<t>You can combine the above and just call <spanx style="verb">go run helloworld.go</spanx>.</t>
</section>

<section anchor="variables-types-and-keywords" title="Variables, Types and Keywords">
<t>In the next few sections we will look at the variables, basic types, keywords,
and control structures of our new language.</t>
<t>Go is different from (most) other languages in that the type of a variable is
specified <spanx style="emph">after</spanx> the variable name. So not: <spanx style="verb">int a</spanx>, but <spanx style="verb">a int</spanx>. When you
declare a variable it is assigned the &quot;natural&quot; null value for the type. This
means that after <spanx style="verb">var a int</spanx>, <spanx style="verb">a</spanx> has a value of 0. With <spanx style="verb">var s string</spanx>, <spanx style="verb">s</spanx> is
assigned the zero string, which is <spanx style="verb">&quot;&quot;</spanx>. Declaring and assigning in Go is a two
step process, but they may be combined. Compare the following pieces of code
which have the same effect. <iref item="variables" subitem="declaring"/> <iref item="variables" subitem="assigning"/></t>

<figure><artwork type="go">var a int                           a := 15
var b bool                          b := false
a = 15
b = false
</artwork></figure>

<t>On the left we use the <spanx style="verb">var</spanx> keyword to declare a variable and <spanx style="emph">then</spanx> assign
a value to it. The code on the right uses <spanx style="verb">:=</spanx> to do this in one step (this form
may only be used <spanx style="emph">inside</spanx> functions). In that case the variable type is
<spanx style="emph">deduced</spanx> from the value. A value of 15 indicates an <spanx style="verb">int</spanx>. A value of <spanx style="verb">false</spanx>
tells Go that the type should be <spanx style="verb">bool</spanx>. Multiple <spanx style="verb">var</spanx> declarations may also
be grouped; <spanx style="verb">const</spanx> (see <xref target="constants"></xref>) and <spanx style="verb">import</spanx> also allow this. Note the
use of parentheses instead of braces:</t>

<figure><artwork type="go">var (
    x int
    b bool
)
</artwork></figure>

<t>Multiple variables of the same type can also be declared on a single line: <spanx style="verb">var
x, y int</spanx> makes <spanx style="verb">x</spanx> and <spanx style="verb">y</spanx> both <spanx style="verb">int</spanx> variables. You can also make use of
<spanx style="emph">parallel assignment</spanx><iref item="variables" subitem="parallel assignment"/> <spanx style="verb">a, b := 20, 16</spanx>.
This makes <spanx style="verb">a</spanx> and <spanx style="verb">b</spanx> both integer variables and assigns
20 to <spanx style="verb">a</spanx> and 16 to <spanx style="verb">b</spanx>.</t>
<t>A special name for a variable is <spanx style="verb">_</spanx>. <iref item="variables" subitem="underscore"/> Any value
assigned to it is discarded (it's similar to <spanx style="verb">/dev/null</spanx> on Unix). In this
example we only assign the integer value of 35 to <spanx style="verb">b</spanx> and discard the value 34:
<spanx style="verb">_, b := 34, 35</spanx>. Declared but otherwise <spanx style="emph">unused</spanx> variables are a compiler error
in Go.</t>

<section anchor="boolean-types" title="Boolean Types">
<t>A boolean type represents the set of boolean truth values denoted by the
predeclared constants <spanx style="emph">true</spanx> and <spanx style="emph">false</spanx>. The boolean type is <spanx style="verb">bool</spanx>.</t>
</section>

<section anchor="numerical-types" title="Numerical Types">
<t>Go has most of the well-known types such as <spanx style="verb">int</spanx>. The <spanx style="verb">int</spanx> type has the
appropriate length for your machine, meaning that on a 32-bit machine it is 32
bits and on a 64-bit machine it is 64 bits. Note: an <spanx style="verb">int</spanx> is either 32 or 64
bits, no other values are defined. Same goes for <spanx style="verb">uint</spanx>, the unsigned int.</t>
<t>If you want to be explicit about the length, you can have that too, with
<spanx style="verb">int32</spanx>, or <spanx style="verb">uint32</spanx>. The full list for (signed and unsigned) integers is
<spanx style="verb">int8</spanx>, <spanx style="verb">int16</spanx>, <spanx style="verb">int32</spanx>, <spanx style="verb">int64</spanx> and <spanx style="verb">byte</spanx>, <spanx style="verb">uint8</spanx>, <spanx style="verb">uint16</spanx>, <spanx style="verb">uint32</spanx>,
<spanx style="verb">uint64</spanx>, with <spanx style="verb">byte</spanx> being an alias for <spanx style="verb">uint8</spanx>. For floating point values
there is <spanx style="verb">float32</spanx> and <spanx style="verb">float64</spanx> (there is no <spanx style="verb">float</spanx> type). A 64 bit integer or
floating point value is <spanx style="emph">always</spanx> 64 bit, also on 32 bit architectures.</t>
<t>Note that these types are all distinct and assigning variables which mix these
types is a compiler error, like in the following code:</t>

<figure><artwork type="go">package main

func main() {
	var a int
	var b int32
	b = a + a
	b = b + 5
}
</artwork></figure>

<t>We declare two different integers, a and b where a is an <spanx style="verb">int</spanx> and b is an
<spanx style="verb">int32</spanx>. We want to set b to the sum of a and a. This fails and gives the error:
<spanx style="verb">cannot use a + a (type int)  as type int32 in assignment</spanx>. Adding the constant
5 to b <spanx style="emph">does</spanx> succeed, because constants are not typed.</t>
</section>

<section anchor="constants" title="Constants">
<t>Constants in Go are just that --- constant. They are created at compile time,
and can only be numbers, strings, or booleans; <spanx style="verb">const x = 42</spanx> makes <spanx style="verb">x</spanx>
a constant. You can use
<spanx style="emph">iota</spanx><iref item="keywords" subitem="iota"/>  to enumerate values.</t>

<figure><artwork type="go">const (
    a = iota
    b
)
</artwork></figure>

<t>The first use of <spanx style="verb">iota</spanx> will yield 0, so <spanx style="verb">a</spanx> is equal to 0. Whenever <spanx style="verb">iota</spanx> is
used again on a new line its value is incremented with 1, so <spanx style="verb">b</spanx> has a value of 1.
Or, as shown here, you can even let Go repeat the use of <spanx style="verb">iota</spanx>. You may also
explicitly type a constant: <spanx style="verb">const b string = &quot;0&quot;</spanx>. Now <spanx style="verb">b</spanx> is a <spanx style="verb">string</spanx> type
constant.</t>
</section>

<section anchor="strings" title="Strings">
<t>Another important built-in type is <spanx style="verb">string</spanx>. Assigning a string is as simple as:</t>

<figure><artwork type="go">s := &quot;Hello World!&quot;
</artwork></figure>

<t>Strings in Go are a sequence of UTF-8 characters enclosed in double quotes (&quot;).
If you use the single quote (') you mean one character (encoded in UTF-8) ---
which is <spanx style="emph">not</spanx> a <spanx style="verb">string</spanx> in Go.</t>
<t>Once assigned to a variable, the string cannot be changed: strings in Go are
immutable. If you are coming from C, note that the following is not legal in Go:</t>

<figure><artwork type="go">var s string = &quot;hello&quot;
s[0] = 'c'
</artwork></figure>

<t>To do this in Go you will need the following:</t>

<figure><artwork type="go">s := &quot;hello&quot;
c := []rune(s)	    &lt;1&gt;
c[0] = 'c'	        &lt;2&gt;
s2 := string(c)     &lt;3&gt;
fmt.Printf(&quot;%s\n&quot;, s2) &lt;4&gt;
</artwork></figure>

<t>Here we convert <spanx style="verb">s</spanx> to an array of runes <spanx style="emph">1</spanx>. We change the first element of
this array <spanx style="emph">2</spanx>. Then we create a <spanx style="emph">new</spanx> string <spanx style="verb">s2</spanx> with the alteration <spanx style="emph">3</spanx>.
Finally, we print the string with <spanx style="verb">fmt.Printf</spanx> <spanx style="emph">4</spanx>.</t>
</section>

<section anchor="runes" title="Runes">
<t><spanx style="verb">Rune</spanx> is an alias for <spanx style="verb">int32</spanx>. It is an UTF-8 encoded code point. When is this
type useful? <iref item="runes"/> One example is when you're iterating over characters in
a string. You could loop over each byte (which is only equivalent to a character
when strings are encoded in 8-bit ASCII, which they are <spanx style="emph">not</spanx> in Go!). But to
get the actual characters you should use the <spanx style="verb">rune</spanx> type.</t>
</section>

<section anchor="complex-numbers" title="Complex Numbers">
<t>Go has native support for complex numbers. To use them you need a variable of
type <spanx style="verb">complex128</spanx> (64 bit real and imaginary parts) or <spanx style="verb">complex64</spanx> (32 bit real
and imaginary parts). Complex numbers are written as <spanx style="verb">re + im</spanx><spanx style="verb">i</spanx>, where <spanx style="verb">re</spanx>
is the real part, <spanx style="verb">im</spanx> is the imaginary part and <spanx style="verb">i</spanx> is the literal '<spanx style="verb">i</spanx>'
(<spanx style="verb">\sqrt{-1}</spanx>).</t>
</section>

<section anchor="errors" title="Errors">
<t>Any non-trivial program will have the need for error reporting sooner or later.
Because of this Go has a builtin type specially for errors, called <spanx style="verb">error</spanx>. <spanx style="verb">var
e error</spanx> creates a variable <spanx style="verb">e</spanx> of type <spanx style="verb">error</spanx> with the value <spanx style="verb">nil</spanx>. This error
type is an interface -- we'll look more at interfaces in <xref target="interfaces"></xref>. For
now you can just assume that <spanx style="verb">error</spanx> is a type just like all other types.</t>
</section>
</section>

<section anchor="operators-and-built-in-functions" title="Operators and Built-in Functions">
<t>Go supports the normal set of numerical operators. See <xref target="tab-op-precedence"></xref>
for lists the current ones and their relative precedence. They all associate from
left to right.</t>
<texttable anchor="tab-op-precedence" title="Operator precedence.">
<ttcol>Precedence</ttcol>
<ttcol>Operator(s)</ttcol>


<c>Highest</c>
<c>	<spanx style="verb">*  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</spanx></c>

<c></c>
<c>	`+  -</c>

<c></c>
<c>	<spanx style="verb">==  !=  &lt;  &lt;=  &gt;  &gt;=</spanx></c>

<c></c>
<c>	<spanx style="verb">&lt;-</spanx></c>

<c></c>
<c>	<spanx style="verb">&amp;&amp;</spanx></c>

<c>Lowest</c>
<c>	||</c>

</texttable><t><spanx style="verb">+ - * /</spanx> and <spanx style="verb">%</spanx> all do what you would expect, <spanx style="verb">&amp; | ^</spanx> and <spanx style="verb">&amp;^</spanx> are bit
operators for bitwise <spanx style="emph">and</spanx><iref item="operators" subitem="bitwise and"/> bitwise
<spanx style="emph">or</spanx><iref item="operators" subitem="bitwise or"/> bitwise <spanx style="emph">xor</spanx><iref item="operators" subitem="bit wise xor"/> and
bit clear <iref item="operators" subitem="bitwise clear"/> respectively. The <spanx style="verb">&amp;&amp;</spanx> and <spanx style="verb">||</spanx>
operators are logical <spanx style="emph">and</spanx> <iref item="operators" subitem="and"/> and logical <spanx style="emph">or</spanx> <iref item="operators" subitem="or"/> Not listed in the table is the logical not <iref item="operators" subitem="not"/> <spanx style="verb">!</spanx></t>
<t>Although Go does not support operator overloading (or method overloading for
that matter), some of the built-in operators <spanx style="emph">are</spanx> overloaded. For instance, <spanx style="verb">+</spanx>
can be used for integers, floats, complex numbers and strings (adding strings is
concatenating them).</t>
</section>

<section anchor="go-keywords" title="Go Keywords">
<t>Let's start looking at keywords, <xref target="tab-keywords"></xref> lists all the keywords in
Go.</t>
<texttable anchor="tab-keywords" title="Keywords in Go.">
<ttcol></ttcol>
<ttcol></ttcol>
<ttcol></ttcol>
<ttcol></ttcol>
<ttcol></ttcol>


<c><spanx style="verb">break</spanx>	</c>
<c><spanx style="verb">default</spanx>	</c>
<c><spanx style="verb">func</spanx>	</c>
<c><spanx style="verb">interface</spanx></c>
<c><spanx style="verb">select</spanx></c>

<c><spanx style="verb">case</spanx>	</c>
<c><spanx style="verb">defer</spanx>	</c>
<c><spanx style="verb">go</spanx>	</c>
<c><spanx style="verb">map</spanx></c>
<c><spanx style="verb">struct</spanx></c>

<c><spanx style="verb">chan</spanx>	</c>
<c><spanx style="verb">else</spanx>	</c>
<c><spanx style="verb">goto</spanx>	</c>
<c><spanx style="verb">package</spanx></c>
<c><spanx style="verb">switch</spanx></c>

<c><spanx style="verb">const</spanx>	</c>
<c><spanx style="verb">fallthrough</spanx>	</c>
<c><spanx style="verb">if</spanx>	</c>
<c><spanx style="verb">range</spanx></c>
<c><spanx style="verb">type</spanx></c>

<c><spanx style="verb">continue</spanx>	</c>
<c><spanx style="verb">for</spanx>	</c>
<c><spanx style="verb">import</spanx>	</c>
<c><spanx style="verb">return</spanx></c>
<c><spanx style="verb">var</spanx></c>

</texttable><t>We've seen some of these already. We used <spanx style="verb">var</spanx> and <spanx style="verb">const</spanx> in the <xref target="variables-types-and-keywords"></xref>
section,  and we briefly looked at <spanx style="verb">package</spanx> and <spanx style="verb">import</spanx> in our &quot;Hello World&quot;
program at the start of the chapter. Others need more attention and have their
own chapter or section:</t>
<t>
<list style="symbols">
<t><spanx style="verb">func</spanx> is used to declare functions and methods.</t>
<t><spanx style="verb">return</spanx> is used to return from functions. We'll look at both <spanx style="verb">func</spanx> and <spanx style="verb">return</spanx> in detail in <xref target="functions"></xref>.</t>
<t><spanx style="verb">go</spanx> is used for concurrency. We'll look at this in <xref target="channels"></xref>.</t>
<t><spanx style="verb">select</spanx> used to choose from different types of communication, We'll work with <spanx style="verb">select</spanx> in <xref target="channels"></xref>.</t>
<t><spanx style="verb">interface</spanx> is covered in <xref target="interfaces"></xref>.</t>
<t><spanx style="verb">struct</spanx> is used for abstract data types. We'll work with <spanx style="verb">struct</spanx> in <xref target="beyond-the-basics"></xref>.</t>
<t><spanx style="verb">type</spanx> is also covered in <xref target="beyond-the-basics"></xref>.</t>
</list>
</t>
</section>

<section anchor="control-structures" title="Control Structures">
<t>There are only a few control structures in Go. To write loops we use the <spanx style="verb">for</spanx>
keyword, and there is a <spanx style="verb">switch</spanx> and of course an <spanx style="verb">if</spanx>. When working with
channels <spanx style="verb">select</spanx> will be used (see <xref target="channels"></xref>). Parentheses are are not
required around the condition, and the body must <spanx style="emph">always</spanx> be brace-delimited.</t>

<section anchor="if-else" title="If-Else">
<t>In Go an <spanx style="verb">if</spanx> <iref item="keywords" subitem="if"/> looks like this:</t>

<figure><artwork type="go">if x &gt; 0 {
    return y
} else {
    return x
}
</artwork></figure>

<t><iref item="keywords" subitem="return"/> <iref item="keywords" subitem="else"/> Since <spanx style="verb">if</spanx> and <spanx style="verb">switch</spanx> accept an
initialization statement, it's common to see one used to set up a (local)
variable.</t>

<figure><artwork type="go">if err := SomeFunction(); err == nil {
    // do something
} else {
    return err
}
</artwork></figure>

<t>It is idomatic in Go to omit the <spanx style="verb">else</spanx> when the <spanx style="verb">if</spanx> statement's body has
a <spanx style="verb">break</spanx>, <spanx style="verb">continue</spanx>, <spanx style="verb">return</spanx> or, <spanx style="verb">goto</spanx>, so the above code would be better
written as:</t>

<figure><artwork type="go">if err := SomeFunction(); err != nil {
    return err
}
// do something
</artwork></figure>

<t>The opening brace on the first line must be positioned on the same line as the
<spanx style="verb">if</spanx> statement. There is no arguing about this, because this is what <spanx style="verb">gofmt</spanx>
outputs.</t>
</section>

<section anchor="goto" title="Goto">
<t>Go has a <spanx style="verb">goto</spanx> <iref item="keywords" subitem="goto"/> statement - use it wisely. With <spanx style="verb">goto</spanx> you
jump to a <iref item="label"/> label which must be defined within the current function.
For instance, a loop in disguise:</t>

<figure><artwork type="go">func myfunc() {
    i := 0
Here:
    fmt.Println(i)
    i++
    goto Here
}
</artwork></figure>

<t>The string <spanx style="verb">Here:</spanx> indicates a label. A label does not need to start with
a capital letter and is case sensitive.</t>
</section>

<section anchor="for" title="For">
<t>The Go <spanx style="verb">for</spanx> <iref item="keywords" subitem="for"/> loop has three forms, only one of which has
semicolons:</t>
<t>
<list style="symbols">
<t><spanx style="verb">for init; condition; post { }</spanx> - a loop using the syntax borrowed from C;</t>
<t><spanx style="verb">for condition { }</spanx> - a while loop, and;</t>
<t><spanx style="verb">for { }</spanx> - an endless loop.</t>
</list>
</t>
<t>Short declarations make it easy to declare the index variable right in the loop.</t>

<figure><artwork type="go">sum := 0
for i := 0; i &lt; 10; i++ {
    sum = sum + i
}
</artwork></figure>

<t>Note that the variable <spanx style="verb">i</spanx> ceases to exist after the loop.</t>
</section>

<section anchor="break-and-continue" title="Break and Continue">
<t>With <spanx style="verb">break</spanx> <iref item="keywords" subitem="break"/> you can quit loops early.  By itself, <spanx style="verb">break</spanx>
breaks the current loop.</t>

<figure><artwork type="go">for i := 0; i &lt; 10; i++ {
    if i &gt; 5 {
    break &lt;1&gt;
    }
    fmt.Println(i) &lt;2&gt;
}
</artwork></figure>

<t>Here we <spanx style="verb">break</spanx> the current loop <spanx style="emph">1</spanx>, and don't continue with the
<spanx style="verb">fmt.Println(i)</spanx> statement <spanx style="emph">2</spanx>. So we only print 0 to 5. With loops within loop
you can specify a label after <spanx style="verb">break</spanx> to identify <spanx style="emph">which</spanx> loop to stop:</t>

<figure><artwork type="go">J:  for j := 0; j &lt; 5; j++ { &lt;1&gt;
        for i := 0; i &lt; 10; i++ {
            if i &gt; 5 {
                break J &lt;2&gt;
            }
            fmt.Println(i)
        }
    }
</artwork></figure>

<t>Here we define a label &quot;J&quot; <spanx style="emph">1</spanx>, preceding the <spanx style="verb">for</spanx>-loop there. When we use
<spanx style="verb">break J</spanx> <spanx style="emph">2</spanx>, we don't break the inner loop but the &quot;J&quot; loop.</t>
<t>With <spanx style="verb">continue</spanx> <iref item="keywords" subitem="continue"/> you begin the next iteration of the
loop, skipping any remaining code. In the same way as <spanx style="verb">break</spanx>, <spanx style="verb">continue</spanx> also
accepts a label.</t>
</section>

<section anchor="range" title="Range">
<t>The keyword <spanx style="verb">range</spanx> <iref item="keywords" subitem="range"/> can be used for loops. It can loop
over slices, arrays, strings, maps and channels (see <xref target="channels"></xref>). <spanx style="verb">range</spanx> is an
iterator that, when called, returns the next key-value pair from the &quot;thing&quot; it
loops over. Depending on what that is, <spanx style="verb">range</spanx> returns different things.</t>
<t>When looping over a slice or array, <spanx style="verb">range</spanx> returns the index in the slice as
the key and value belonging to that index. Consider this code: <iref item="keywords" subitem="range"/></t>

<figure><artwork type="go">list := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}
for k, v := range list {
    // do something with k and v
}
</artwork></figure>

<t>First we create a slice of strings. Then we use <spanx style="verb">range</spanx> to loop over them. With
each iteration, <spanx style="verb">range</spanx> will return the index as an <spanx style="verb">int</spanx> and the key as
a <spanx style="verb">string</spanx>. It will start with 0 and &quot;a&quot;, so <spanx style="verb">k</spanx> will be 0 through 5, and v will
be &quot;a&quot; through &quot;f&quot;.</t>
<t>You can also use <spanx style="verb">range</spanx> on strings directly. Then it will break out the
individual Unicode characters ^[In the UTF-8 world characters are sometimes
called <spanx style="emph">runes</spanx> <iref item="runes"/> Mostly, when people talk about characters, they
mean 8 bit characters. As UTF-8 characters may be up to 32 bits the word rune is
used. In this case the type of <spanx style="verb">char</spanx> is <spanx style="verb">rune</spanx>. and their start position, by
parsing the UTF-8. The loop: <iref item="keywords" subitem="range"/></t>

<figure><artwork type="go">for pos, char := range &quot;Gő!&quot; {
    fmt.Printf(&quot;character '%c' starts at byte position %d\n&quot;, char, pos)
}
</artwork></figure>

<t>prints</t>

<figure><artwork>character 'G' starts at byte position 0
character 'ő' starts at byte position 1
character '!' starts at byte position 3
</artwork></figure>

<t>Note that <spanx style="verb">ő</spanx> took 2 bytes, so '!' starts at byte 3.</t>
</section>

<section anchor="switch" title="Switch">
<t>Go's <spanx style="verb">switch</spanx> <iref item="keywords" subitem="switch"/> is very flexible; you can match on much
more than just integers. The cases are evaluated top to bottom until a match is
found, and if the <spanx style="verb">switch</spanx> has no expression it switches on <spanx style="verb">true</spanx>. It's
therefore possible -- and idiomatic -- to write an <spanx style="verb">if-else-if-else</spanx> chain as
a <spanx style="verb">switch</spanx>.</t>

<figure><artwork type="go">// Convert hexadecimal character to an int value
switch { &lt;1&gt;
case '0' &lt;= c &amp;&amp; c &lt;= '9': &lt;2&gt;
    return c - '0' &lt;3&gt;
case 'a' &lt;= c &amp;&amp; c &lt;= 'f': &lt;4&gt;
    return c - 'a' + 10
case 'A' &lt;= c &amp;&amp; c &lt;= 'F': &lt;5&gt;
    return c - 'A' + 10
}
return 0
</artwork></figure>

<t>A <spanx style="verb">switch</spanx> without a condition is the same as <spanx style="verb">switch true</spanx> <spanx style="emph">1</spanx>. We list the
different cases. Each <spanx style="verb">case</spanx> statement has a condition that is either true of
false. Here <spanx style="emph">2</spanx> we check if <spanx style="verb">c</spanx> is a number. If <spanx style="verb">c</spanx> is a number we return its
value <spanx style="emph">3</spanx>. Check if <spanx style="verb">c</spanx> falls between &quot;a&quot; and &quot;f&quot; <spanx style="emph">4</spanx>. For an &quot;a&quot; we
return 10, for &quot;b&quot; we return 11, etc. We also do the same <spanx style="emph">5</spanx> thing for &quot;A&quot;
to &quot;F&quot;.</t>
<t>There is no automatic fall through, you can use <spanx style="verb">fallthrough</spanx> <iref item="keywords" subitem="fallthrough"/> for that.</t>

<figure><artwork type="go">switch i {
    case 0:  fallthrough
    case 1: &lt;1&gt;
        f()
    default:
        g() &lt;2&gt;
</artwork></figure>

<t><spanx style="verb">f()</spanx> can be called when <spanx style="verb">i == 0</spanx> <spanx style="emph">1</spanx>. With <spanx style="verb">default</spanx> <iref item="keywords" subitem="default"/> you
can specify an action when none of the other cases match. Here <spanx style="verb">g()</spanx> is called
when <spanx style="verb">i</spanx> is not 0 or 1 <spanx style="emph">2</spanx>. We could rewrite the above example as:</t>

<figure><artwork type="go">switch i {
    case 0, 1: &lt;1&gt;
        f()
    default:
        g()
</artwork></figure>

<t>You can list cases on one line <spanx style="emph">1</spanx>, separated by commas.</t>
</section>
</section>

<section anchor="built-in-functions" title="Built-in Functions">
<t>A few functions are predefined, meaning you <spanx style="emph">don't</spanx> have to include any package
to get access to them. <xref target="tab-predef-functions"></xref> lists them all.</t>
<texttable anchor="tab-predef-functions" title="Pre-defined functions in Go.">
<ttcol></ttcol>
<ttcol></ttcol>
<ttcol></ttcol>
<ttcol></ttcol>


<c><spanx style="verb">close</spanx></c>
<c><spanx style="verb">new</spanx></c>
<c><spanx style="verb">panic</spanx></c>
<c><spanx style="verb">complex</spanx></c>

<c><spanx style="verb">delete</spanx></c>
<c><spanx style="verb">make</spanx></c>
<c><spanx style="verb">recover</spanx></c>
<c><spanx style="verb">real</spanx></c>

<c><spanx style="verb">len</spanx></c>
<c><spanx style="verb">append</spanx></c>
<c><spanx style="verb">print</spanx></c>
<c><spanx style="verb">imag</spanx></c>

<c><spanx style="verb">cap</spanx></c>
<c><spanx style="verb">copy</spanx></c>
<c><spanx style="verb">println</spanx></c>
<c></c>

</texttable><t>These built-in functions are documented in the <spanx style="verb">builtin</spanx> <iref item="package" subitem="builtin"/>
pseudo package that is included in recent Go releases. Let's go over these
functions briefly.</t>
<t>
<list style="hanging">
<t hangText="close">
<vspace />is used in channel communication. It closes a channel. We'll learn more about this in <xref target="channels"></xref>.
<iref item="built-in" subitem="close"/></t>
<t hangText="delete">
<vspace />is used for deleting entries in maps. <iref item="built-in" subitem="delete"/></t>
<t hangText="len and cap">
<vspace />are used on a number of different types, <spanx style="verb">len</spanx> is
used to return the lengths of strings, slices, and
arrays. In the next section <xref target="arrays"></xref> we'll look at slices,
arrays and the function <spanx style="verb">cap</spanx>.<iref item="built-in" subitem="len"/><iref item="built-in" subitem="cap"/></t>
<t hangText="new">
<vspace />is used for allocating memory for user defined
data types. See <xref target="allocation-with-new"></xref>.
<iref item="built-in" subitem="new"/></t>
<t hangText="make">
<vspace />is used for allocating memory for built-in
types (maps, slices, and channels). See <xref target="allocation-with-make"></xref>.
<iref item="built-in" subitem="make"/></t>
<t hangText="copy, append">
<vspace /><spanx style="verb">copy</spanx> is for copying slices. <iref item="built-in" subitem="copy"/>
And <spanx style="verb">append</spanx> is for concatenating slices. See <xref target="slices"></xref> in this chapter. <iref item="built-in" subitem="append"/></t>
<t hangText="panic, recover">
<vspace />are used for an <spanx style="emph">exception</spanx> mechanism. See <xref target="panic-and-recovering"></xref> for more.
<iref item="built-in" subitem="panic"/>
<iref item="built-in" subitem="recover"/></t>
<t hangText="print, println">
<vspace />are low level printing functions that can be used without reverting to the
<spanx style="verb">fmt</spanx> <iref item="package" subitem="fmt"/> package. These are mainly used for debugging.
<iref item="built-in" subitem="print"/>built-in,println)</t>
<t hangText="complex, real, imag">
<vspace />all deal with complex numbers. <iref item="complex numbers"/> We will not use complex numbers in this book.
<iref item="built-in" subitem="complex"/>
<iref item="built-in" subitem="real"/>
<iref item="built-in" subitem="imag"/></t>
</list>
</t>
</section>

<section anchor="arrays-slices-and-maps" title="Arrays, Slices, and Maps">
<t>To store multiple values in a list, you can use arrays, or their more flexible
cousin: slices. A dictionary or hash type is also available. It is called
a <spanx style="verb">map</spanx> in Go.</t>

<section anchor="arrays" title="Arrays">
<t>An array is defined by: <spanx style="verb">[n]&lt;type&gt;</spanx>, where <spanx style="verb">n</spanx> is the length of the array and
<spanx style="verb">&lt;type&gt;</spanx> is the stuff you want to store. To assign or index an element in the
array, you use square brackets:</t>

<figure><artwork type="go">var arr [10]int
arr[0] = 42
arr[1] = 13
fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])
</artwork></figure>

<t>Array types like <spanx style="verb">var arr [10]int</spanx> have a fixed size. The size is <spanx style="emph">part</spanx> of the
type. They can't grow, because then they would have a different type. Also
arrays are values: Assigning one array to another <spanx style="emph">copies</spanx> all the elements. In
particular, if you pass an array to a function it will receive a copy of the
array, not a pointer to it.</t>
<t><iref item="array" subitem="multidimensional"/> To declare an array you can use the following: <spanx style="verb">var
a [3]int</spanx>. To initialize it to something other than zero, use a
<spanx style="emph">composite literal</spanx> <iref item="literal" subitem="composite"/> <spanx style="verb">a := [3]int{1, 2, 3}</spanx>. This can
 be shortened to <spanx style="verb">a := [...]int{1, 2, 3}</spanx>, where Go counts the elements
 automatically.</t>
<t>A composite literal allows you
to assign a value directly to an array, slice, or map.
See <xref target="constructors-and-composite-literals"></xref> for more information.</t>
<t>When declaring arrays you <spanx style="emph">always</spanx> have to type something in between the square
brackets, either a number or three dots (<spanx style="verb">...</spanx>), when using a composite literal.
When using multidimensional arrays, you can use the following syntax: <spanx style="verb">a :=
[2][2]int{ {1,2}, {3,4} }</spanx>. Now that you know about arrays you will be delighted
to learn that you will almost never use them in Go, because there is something
much more flexible: slices.</t>
</section>

<section anchor="slices" title="Slices">
<t>A slice is similar to an array, but it can grow when new elements are added.
A slice always refers to an underlying array. What makes slices different from
arrays is that a slice is a pointer <spanx style="emph">to</spanx> an array; slices are reference
types.<iref item="reference types"/></t>
<t>Reference types are created with <spanx style="verb">make</spanx>. We detail this further
in <xref target="beyond-the-basics"></xref>.</t>
<t>That means that if you assign one slice to another, both refer to the <spanx style="emph">same</spanx>
underlying array. For instance, if a function takes a slice argument, changes it
makes to the elements of the slice will be visible to the caller, analogous to
passing a pointer to the underlying array. With: <spanx style="verb">slice := make([]int, 10)</spanx>, you
create a slice which can hold ten elements. Note that the underlying array isn't
specified. A slice is always coupled to an array that has a fixed size. For
slices we define a capacity <iref item="slice" subitem="capacity"/> and a length
<iref item="slice" subitem="length"/> The image below shows the creation of an array,
then the creation of a slice. First we create an array of <spanx style="verb">m</spanx> elements of the
type <spanx style="verb">int</spanx>: <spanx style="verb">var array[m]int</spanx> .</t>
<t>Next, we create a slice from this array: <spanx style="verb">slice := array[:n]</spanx> . And now we have:</t>
<t>
<list style="symbols">
<t><spanx style="verb">len(slice) == n</spanx></t>
<t><spanx style="verb">cap(slice) == m</spanx></t>
<t><spanx style="verb">len(array) == cap(array) == m</spanx></t>
</list>
</t>
<figure title="An array versus a slice.
"></figure>
<t>Given an array, or another slice, a new slice is created via <spanx style="verb">a[n:m]</spanx>. This
creates a new slice which refers to the variable <spanx style="verb">a</spanx>, starts at index <spanx style="verb">n</spanx>, and
ends before index <spanx style="verb">m</spanx>. It has length <spanx style="verb">n - m</spanx>.</t>

<figure><artwork type="go">a := [...]int{1, 2, 3, 4, 5} &lt;1&gt;
s1 := a[2:4] &lt;2&gt;
s2 := a[1:5] &lt;3&gt;
s3 := a[:]   &lt;4&gt;
s4 := a[:4]  &lt;5&gt;
s5 := s2[:] &lt;6&gt;
s6 := a[2:4:5] &lt;7&gt;
</artwork></figure>

<t>First we define <spanx style="emph">1</spanx> an array with five elements, from index 0 to 4.
From this we create <spanx style="emph">2</spanx> a slice with the elements from index 2 to 3, this slices contains: <spanx style="verb">3, 4</spanx>.
Then we we create another slice <spanx style="emph">3</spanx> from <spanx style="verb">a</spanx>: with the elements from index 1 to 4,
this contains: <spanx style="verb">2, 3, 4, 5</spanx>.
With <spanx style="verb">a[:]</spanx> <spanx style="emph">4</spanx> we create a slice with all the elements in the array. This is a shorthand for: <spanx style="verb">a[0:len(a)]</spanx>.
And with <spanx style="verb">a[:4]</spanx> <spanx style="emph">5</spanx> we create a slice with the elements from index
0 to 3, this is short for: <spanx style="verb">a[0:4]</spanx>, and gives us a slices that contains: <spanx style="verb">1, 2, 3, 4</spanx>.
With <spanx style="verb">s2[:]</spanx> we create a slice from the slice <spanx style="verb">s2</spanx> <spanx style="emph">6</spanx>, note that <spanx style="verb">s5</spanx> still refers to the array <spanx style="verb">a</spanx>.
Finally, we create a slice with the elements from index 3 to 3 <spanx style="emph">and</spanx> also set the cap to 4 <spanx style="emph">7</spanx>.</t>
<t>When working with slices you can overrun the bounds, consider this code.</t>

<figure><artwork type="go">package main

func main() {
	var array [100]int   &lt;1&gt;
	slice := array[0:99] &lt;2&gt;

	slice[98] = 1 &lt;3&gt;
	slice[99] = 2 &lt;4&gt;
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we create an array with a 100 elements, indexed from 0 to 99. Then at <spanx style="emph">2</spanx>
we create a slice that has index 0 to 98. We assign 1 to the 99th element <spanx style="emph">3</spanx> of
the slice. This works as expected. But at <spanx style="emph">4</spanx> we dare to do the impossible, and
and try to allocate something beyond the length of the slice and we are greeted
with a <spanx style="emph">runtime</spanx> error: <spanx style="verb">Error: &quot;throw: index out of range&quot;.</spanx></t>
<t>If you want to extend a slice, there are a couple of built-in functions that
make life easier: <spanx style="verb">append</spanx> and <spanx style="verb">copy</spanx>. The append function appends zero or more
values to a slice and returns the result: a slice with the same type as the
original. If the original slice isn't big enough to fit the added values, append
will allocate a new slice that is big enough. So the slice returned by append
may refer to a different underlying array than the original slice does. Here's
an example: <iref item="built-in" subitem="append"/></t>

<figure><artwork type="go">s0 := []int{0, 0}
s1 := append(s0, 2) &lt;1&gt;
s2 := append(s1, 3, 5, 7) &lt;2&gt;
s3 := append(s2, s0...) &lt;3&gt;
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we append a single element, making <spanx style="verb">s1</spanx> equal to <spanx style="verb">[]int{0, 0, 2}</spanx>. At <spanx style="emph">2</spanx>
we append multiple elements, making <spanx style="verb">s2</spanx> equal to <spanx style="verb">[]int{0, 0, 2, 3, 5, 7}</spanx>. And
at <spanx style="emph">3</spanx> we append a slice, giving us <spanx style="verb">s3</spanx> equal to <spanx style="verb">[]int{0, 0, 2, 3, 5, 7, 0, 0}</spanx>.
Note the three dots used after <spanx style="verb">s0...</spanx>! This is needed make it clear
  explicit that you're appending another slice, instead of a single value.</t>
<t>The copy function copies slice elements from a source to a destination, and
returns the number of elements it copied. This number is the minimum of the
length of the source and the length of the destination. For example:
<iref item="built-in" subitem="copy"/></t>

<figure><artwork type="go">var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
n1 := copy(s, a[0:]) &lt;1&gt;
n2 := copy(s, s[2:]) &lt;2&gt;
</artwork></figure>

<t>After <spanx style="emph">1</spanx>, <spanx style="verb">n1</spanx> is 6, and <spanx style="verb">s</spanx> is <spanx style="verb">[]int{0, 1, 2, 3, 4, 5}</spanx>.
And after <spanx style="emph">2</spanx>, <spanx style="verb">n2</spanx> is 4, and <spanx style="verb">s</spanx> is <spanx style="verb">[]int{2, 3, 4, 5, 4, 5}</spanx>.</t>
</section>

<section anchor="maps" title="Maps">
<t>Many other languages have a type similar to maps built-in. For instance, Perl
has hashes, Python has its dictionaries, and C++ also has maps (as part of the
libraries). In Go we have the <spanx style="verb">map</spanx> <iref item="keywords" subitem="map"/> type. A <spanx style="verb">map</spanx> can be
thought of as an array indexed by strings (in its most simple form).</t>

<figure><artwork type="go">monthdays := map[string]int{
    &quot;Jan&quot;: 31, &quot;Feb&quot;: 28, &quot;Mar&quot;: 31,
    &quot;Apr&quot;: 30, &quot;May&quot;: 31, &quot;Jun&quot;: 30,
    &quot;Jul&quot;: 31, &quot;Aug&quot;: 31, &quot;Sep&quot;: 30,
    &quot;Oct&quot;: 31, &quot;Nov&quot;: 30, &quot;Dec&quot;: 31, &lt;1&gt;
}
</artwork></figure>

<t>The general syntax for defining a map is <spanx style="verb">map[&lt;from type&gt;]&lt;to type&gt;</spanx>. Here, we
define a map that converts from a <spanx style="verb">string</spanx> (month abbreviation) to an <spanx style="verb">int</spanx>
(number of days in that month). Note that the trailing comma at <spanx style="emph">1</spanx> is
<spanx style="emph">required</spanx>.</t>
<t>Use <spanx style="verb">make</spanx> when only declaring a map: <spanx style="verb">monthdays := make(map[string]int)</spanx>. A map
is a reference type.</t>
<t>For indexing (&quot;searching&quot;) the map, we use square brackets. For example, suppose
we want to print the number of days in December: <spanx style="verb">fmt.Printf(&quot;%d\n&quot;,
monthdays[&quot;Dec&quot;])</spanx></t>
<t>If you are looping over an array, slice, string, or map a, <spanx style="verb">range</spanx> <iref item="keywords" subitem="range"/> clause will help you again, it returns the key and corresponding value
with each invocation.</t>

<figure><artwork type="go">year := 0
for _, days := range monthdays &lt;1&gt;
    year += days
}
fmt.Printf(&quot;Numbers of days in a year: %d\n&quot;, year)
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we use the underscore to ignore (assign to nothing) the key returned by
<spanx style="verb">range</spanx>. We are only interested in the values from <spanx style="verb">monthdays</spanx>.</t>
<t><iref item="keywords" subitem="map adding elements"/></t>
<t>To add elements to the map, you would add new month with: <spanx style="verb">monthdays[&quot;Undecim&quot;]
= 30</spanx>. If you use a key that already exists, the value will be silently
overwritten: <spanx style="verb">monthdays[&quot;Feb&quot;] = 29</spanx>. To test for existence <iref item="keywords" subitem="map
existence"/> you would use the following: <spanx style="verb">value, present := monthdays[&quot;Jan&quot;]</spanx>.
If the key &quot;Jan&quot; exists, <spanx style="verb">present</spanx> will be true. It's more Go like to name
<spanx style="verb">present</spanx> &quot;ok&quot;, and use: <spanx style="verb">v, ok := monthdays[&quot;Jan&quot;]</spanx>. In Go we call this the
&quot;comma ok&quot; form.</t>
<t>You can remove elements <iref item="keywords" subitem="map remove elements"/> from the <spanx style="verb">map</spanx>:
<spanx style="verb">delete(monthdays, &quot;Mar&quot;)</spanx> . In general the
syntax <spanx style="verb">delete(m, x)</spanx> will delete the map entry retrieved by the expression
<spanx style="verb">m[x]</spanx>.</t>
</section>
</section>

<section anchor="exercises" title="Exercises">

<section anchor="for-loop" title="For-loop">
<t>
<list style="numbers">
<t>Create a loop with the <spanx style="verb">for</spanx> construct. Make it loop
10 times and print out the loop counter with the <spanx style="verb">fmt</spanx> package.</t>
<t>Rewrite the loop from 1 to use <spanx style="verb">goto</spanx>. The keyword <spanx style="verb">for</spanx> may not be used.</t>
<t>Rewrite the loop again so that it fills an array and then prints that array to the screen.</t>
</list>
</t>
</section>

<section anchor="answer" title="Answer">
<t>
<list style="numbers">
<t>There are many possibilities. One solution could be:</t>
</list>
</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&quot;%d&quot;, i)
	}
}
</artwork></figure>

<t>Let's compile this and look at the output.</t>

<figure><artwork>    % go build for.go
    % ./for
    0
    1
    .
    .
    .
    9
</artwork></figure>

<t>
<list style="numbers">
<t>Rewriting the loop results in code that should look something
like this (only showing the <spanx style="verb">main</spanx>-function):
<figure><artwork type="go">func main() {
    i := 0	&lt;1&gt;
Loop:		    &lt;2&gt;
    if i &lt; 10 {
        fmt.Printf(&quot;%d\n&quot;, i)
        i++
        goto Loop &lt;3&gt;
    }
}
</artwork></figure>

<vspace />
At <spanx style="emph">1</spanx> we define our loop variable. And at <spanx style="emph">2</spanx> we define a label and at <spanx style="emph">3</spanx> we jump
to this label.</t>
<t>The following is one possible solution:
<figure><artwork type="go">package main

import &quot;fmt&quot;

func main() {
	var arr [10]int &lt;1&gt;
	for i := 0; i &lt; 10; i++ {
		arr[i] = i &lt;2&gt;
	}
	fmt.Printf(&quot;%v&quot;, arr) &lt;3&gt;
}
</artwork></figure>

<vspace />
Here <spanx style="emph">1</spanx> we create an array with 10 elements.
Which we then fill <spanx style="emph">2</spanx> one by one. And finally we print it <spanx style="emph">3</spanx> with <spanx style="verb">%v</spanx> which lets
Go to print the value for us. You could even do this in one fell swoop by using a composite literal:</t>
</list>
</t>

<figure><artwork type="go">fmt.Printf(&quot;%v\n&quot;, [...]int{0,1,2,3,4,5,6,7,8,9})
</artwork></figure>

</section>

<section anchor="average" title="Average">
<t>
<list style="numbers">
<t>Write code to calculate the average of a <spanx style="verb">float64</spanx> slice. In
a later exercise you will make it into a function.</t>
</list>
</t>
</section>

<section anchor="answer-1" title="Answer">
<t>
<list style="numbers">
<t>The following code calculates the average.</t>
</list>
</t>

<figure><artwork type="go">sum := 0.0
switch len(xs) {
case 0: &lt;1&gt;
    avg = 0
default: &lt;2&gt;
    for _, v := range xs {
        sum += v
    }
    avg = sum / float64(len(xs)) &lt;3&gt;
}
</artwork></figure>

<t>Here at <spanx style="emph">1</spanx> we check if the length is zero and if so, we return 0.
Otherwise we calculate the average at <spanx style="emph">2</spanx>.
We have to convert the value return from <spanx style="verb">len</spanx> to a <spanx style="verb">float64</spanx>
to make the division work at <spanx style="emph">3</spanx>.</t>
</section>

<section anchor="ex-fizzbuzz" title="FizzBuzz">
<t>
<list style="numbers">
<t>Solve this problem, called the Fizz-Buzz <xref target="fizzbuzz"></xref> problem:</t>
</list>
</t>
<t>Write a program that prints the numbers from 1 to 100. But for multiples
of three print, &quot;Fizz&quot; instead of the number, and for multiples of
five, print &quot;Buzz&quot;. For numbers which are multiples of both three and
five, print &quot;FizzBuzz&quot;.</t>
</section>

<section anchor="answer-2" title="Answer">
<t>
<list style="numbers">
<t>A possible solution to this problem is the following program.</t>
</list>
</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

func main() {
	const (
		FIZZ = 3 &lt;1&gt;
		BUZZ = 5
	)
	var p bool                 &lt;2&gt;
	for i := 1; i &lt; 100; i++ { &lt;3&gt;
		p = false
		if i%FIZZ == 0 { &lt;4&gt;
			fmt.Printf(&quot;Fizz&quot;)
			p = true
		}
		if i%BUZZ == 0 { &lt;5&gt;
			fmt.Printf(&quot;Buzz&quot;)
			p = true
		}
		if !p { &lt;6&gt;
			fmt.Printf(&quot;%v&quot;, i)
		}
		fmt.Println()
	}
}
</artwork></figure>

<t>Here <spanx style="emph">1</spanx> we define two constants to make our code more readable, see <xref target="constants"></xref>.
At <spanx style="emph">2</spanx> we define a boolean that keeps track if we already printed something.
At <spanx style="emph">3</spanx> we start our for-loop, see <xref target="for"></xref>.
If the value is divisible by FIZZ - that is, 3 - , we print &quot;Fizz&quot; <spanx style="emph">4</spanx>.
And at <spanx style="emph">5</spanx> we check if the value is divisble by BUZZ -- that is, 5 -- if so print
&quot;Buzz&quot;. Note that we have also taken care of the FizzBuzz case.
At <spanx style="emph">6</spanx>, if printed neither Fizz nor Buzz printed, we print the value.</t>
</section>
</section>
</section>

<section anchor="functions" title="Functions">
<t>
<list style="empty">
<t>I'm always delighted by the light touch and stillness of
early programming languages.  Not much text; a lot gets
done. Old programs read like quiet conversations
between a well-spoken research worker and a well-
studied mechanical colleague, not as a debate with a
compiler.  Who'd have guessed sophistication bought
such noise?</t>
<t>Richard P. Gabriel
</t>
</list></t>
<t>Functions are the basic building blocks of Go programs; all interesting stuff
happens in them.</t>
<t>Here is an example of how you can declare a function:</t>

<figure><artwork type="go">type mytype int
func (p mytype) funcname(q int) (r,s int) { return 0,0 }
&lt;1&gt;        &lt;2&gt;        &lt;3&gt;      &lt;4&gt;        &lt;5&gt;         &lt;6&gt;
</artwork></figure>

<t>To declare a function, you use the <spanx style="verb">func</spanx> keyword <spanx style="emph">1</spanx>. You can optionally bind
<spanx style="emph">2</spanx> to a specific type called receiver <iref item="functions" subitem="receiver"/> (a function
with a receiver is usually called a method<iref item="functions" subitem="method"/>). This will
be explored in <xref target="interfaces"></xref>. Next <spanx style="emph">3</spanx> you write the name of your
function. Here <spanx style="emph">4</spanx> we define that the variable <spanx style="verb">q</spanx> of type <spanx style="verb">int</spanx> is the input
parameter. Parameters are passed <spanx style="emph">pass-by-value</spanx>.<iref item="functions" subitem="pass-by-value"/>
The variables <spanx style="verb">r</spanx> and <spanx style="verb">s</spanx> <spanx style="emph">5</spanx> are the <spanx style="emph">named return parameters</spanx> (((functions,
named return parameters))) for this function. Functions in Go can have multiple
return values. This is very useful to return a value <spanx style="emph">and</spanx> error. This
removes the need for in-band error returns (such as -1 for <spanx style="verb">EOF</spanx>) and modifying
an argument. If you want the return parameters not to be named you only give the
types: <spanx style="verb">(int, int)</spanx>. If you have only one value to return you may omit the
parentheses. If your function is a subroutine and does not have anything to
return you may omit this entirely. Finally, we have the body <spanx style="emph">6</spanx> of the
function. Note that <spanx style="verb">return</spanx> is a statement so the braces around the
parameter(s) are optional.</t>
<t>As said the return or result parameters of a Go function can be given names and
used as regular variables, just like the incoming parameters. When named, they
are initialized to the zero values for their types when the function begins. If
the function executes a <spanx style="verb">return</spanx> statement with no arguments, the current values
of the result parameters are returned. Using these features enables you (again)
to do more with less code.</t>
<t>The names are not mandatory but they can make code shorter and clearer:
<spanx style="emph">they are documentation</spanx>. However don't overuse this feature, especially in
 longer functions where it might not be immediately apparent what is returned.</t>
<t>Functions can be declared in any order you wish. The compiler scans the entire
file before execution, so function prototyping is a thing of the past in Go. Go
does not allow nested functions, but you can work around this with anonymous
functions. See the Section <xref target="functions-as-values"></xref> in this chapter. Recursive
functions work just as in other languages:</t>

<figure><artwork type="go">func rec(i int) {
    if i == 10 { &lt;1&gt;
        return
    }
    rec(i+1) &lt;2&gt;
    fmt.Printf(&quot;%d &quot;, i)
}
</artwork></figure>

<t>Here <spanx style="emph">2</spanx> we call the same function again, <spanx style="verb">rec</spanx> returns when <spanx style="verb">i</spanx> has the value
10, this is checked on the second line <spanx style="emph">1</spanx>. This function prints: <spanx style="verb">9
8 7 6 5 4 3 2 1 0</spanx>, when called as <spanx style="verb">rec(0)</spanx>.</t>

<section anchor="scope" title="Scope">
<t>Variables declared outside any functions are <spanx style="emph">global</spanx> <iref item="scope" subitem="local"/> in Go,
those defined in functions are <spanx style="emph">local</spanx> <iref item="scope" subitem="local"/> to those functions. If
names overlap - a local variable is declared with the same name as a global one
- the local variable hides the global one when the current function is executed.</t>
<t>In the following example we call <spanx style="verb">g()</spanx> from <spanx style="verb">f()</spanx>:</t>

<figure><artwork type="go">package main

var a int &lt;1&gt;

func main() {
    a = 5
    print(a)
    f()
}

func f() {
    a := 6 &lt;2&gt;
    print(a)
    g()
}

func g() {
    print(a)
}
</artwork></figure>

<t>Here <spanx style="emph">1</spanx>, we declare <spanx style="verb">a</spanx> to be a global variable of type <spanx style="verb">int</spanx>. Then in the
<spanx style="verb">main</spanx> function we give the <spanx style="emph">global</spanx> <spanx style="verb">a</spanx> the value of 5, after printing it we
call the function <spanx style="verb">f</spanx>. Then here <spanx style="emph">2</spanx>, <spanx style="verb">a := 6</spanx>, we create a <spanx style="emph">new, local</spanx>
variable also called <spanx style="verb">a</spanx>. This new <spanx style="verb">a</spanx> gets the value of 6, which we then print.
Then we call <spanx style="verb">g</spanx>, which uses the <spanx style="emph">global</spanx> <spanx style="verb">a</spanx> again and prints <spanx style="verb">a</spanx>'s value set
in <spanx style="verb">main</spanx>. Thus the output will be: <spanx style="verb">565</spanx>. A <spanx style="emph">local</spanx> variable is <spanx style="emph">only</spanx> valid
when we are executing the function in which it is defined. Note that the <spanx style="verb">:=</spanx>
used in line 12 is sometimes hard to spot so it is generally advised <spanx style="emph">not</spanx> to
use the same name for global and local variables.</t>
</section>

<section anchor="functions-as-values" title="Functions as values">
<t><iref item="functions" subitem="as values"/> <iref item="functions" subitem="literals"/> As with almost everything in
Go, functions are also <spanx style="emph">just</spanx> values. They can be assigned to variables as
follows:</t>

<figure><artwork type="go">import &quot;fmt&quot;

func main() {
	a := func() { &lt;1&gt;
		fmt.Println(&quot;Hello&quot;)
	} &lt;2&gt;
	a() &lt;3&gt;
}
</artwork></figure>

<t><spanx style="verb">a</spanx> is defined as an anonymous (nameless) function <spanx style="emph">1</spanx>.
Note the lack of parentheses <spanx style="verb">()</spanx> after <spanx style="verb">a</spanx>. If there were, that would be to <spanx style="emph">call</spanx>
some function with the name <spanx style="verb">a</spanx> before we have defined what <spanx style="verb">a</spanx> is. Once <spanx style="verb">a</spanx> is
defined, then we can <spanx style="emph">call</spanx> it, <spanx style="emph">3</spanx>.</t>
<t>Functions--as--values may be used in other places, for example maps. Here we
convert from integers to functions:</t>

<figure><artwork type="go">var xs = map[int]func() int{
    1: func() int { return 10 },
    2: func() int { return 20 },
    3: func() int { return 30 },
}
</artwork></figure>

<t>Note that the final comma on second to last line is <spanx style="emph">mandatory</spanx>.</t>
<t>Or you can write a function that takes a function as its parameter, for example
a <spanx style="verb">Map</spanx> function that works on <spanx style="verb">int</spanx> slices. This is left as an exercise for the
reader; see the exercise <xref target="map-function"></xref>.</t>
</section>

<section anchor="callbacks" title="Callbacks">
<t>Because functions are values they are easy to pass to functions, from where they
can be used as callbacks. First define a function that does &quot;something&quot; with an
integer value:</t>

<figure><artwork type="go">func printit(x int) {
    fmt.Printf(&quot;%v\n&quot;, x)
}
</artwork></figure>

<t>This function does not return a value and just prints its argument. The
<spanx style="emph">signature</spanx> <iref item="functions" subitem="signature"/> of this function is: <spanx style="verb">func printit(int)</spanx>,
or without the function name: <spanx style="verb">func(int)</spanx>. To create a new function that uses
this one as a callback we need to use this signature:</t>

<figure><artwork type="go">func callback(y int, f func(int)) {
    f(y)
}
</artwork></figure>

<t>Here we create a new function that takes two parameters: <spanx style="verb">y int</spanx>, i.e. just an
<spanx style="verb">int</spanx> and <spanx style="verb">f func(int)</spanx>, i.e. a function that takes an int and returns nothing.
The parameter <spanx style="verb">f</spanx> is the variable holding that function. It can be used as any
other function, and we execute the function on line 2 with the parameter <spanx style="verb">y</spanx>:
<spanx style="verb">f(y)</spanx></t>
</section>

<section anchor="deferred-code" title="Deferred Code">
<t>Suppose you have a function in which you open a file and perform various writes
and reads on it. In such a function there are often spots where you want to
return early. If you do that, you will need to close the file descriptor you are
working on. This often leads to the following code:</t>

<figure><artwork type="go">func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    // Do your thing
    if failureX {
        file.Close() &lt;1&gt;
        return false
    }

    if failureY {
        file.Close() &lt;1&gt;
        return false
    }
    file.Close() &lt;1&gt;
    return true  &lt;2&gt;
}
</artwork></figure>

<t>Note that we repeat a lot of code here; you can see the that <spanx style="verb">file.Close()</spanx> is
called at <spanx style="emph">1</spanx>. To overcome this, Go has the <spanx style="verb">defer</spanx> <iref item="keywords" subitem="defer"/>
keyword. After <spanx style="verb">defer</spanx> you specify a function which is called just <spanx style="emph">before</spanx> <spanx style="emph">2</spanx>
the current function exits.</t>
<t>With <spanx style="verb">defer</spanx> we can rewrite the above code as follows. It makes the function
more readable and it puts the <spanx style="verb">Close</spanx> <spanx style="emph">right next</spanx> to the <spanx style="verb">Open</spanx>.</t>

<figure><artwork type="go">func ReadWrite() bool {
    file.Open(&quot;filename&quot;)
    defer file.Close() &lt;1&gt;
    // Do your thing
    if failureX {
        return false &lt;2&gt;
    }
    if failureY {
        return false &lt;2&gt;
    }
    return true &lt;2&gt;
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> <spanx style="verb">file.Close()</spanx> is added to the defer list. <iref item="keywords" subitem="defer list"/>
<spanx style="verb">Close</spanx> is now done automatically at <spanx style="emph">2</spanx>. This makes the function shorter and
more readable. It puts the <spanx style="verb">Close</spanx> right next to the <spanx style="verb">Open</spanx>.</t>
<t>You can put multiple functions on the &quot;defer list&quot;, like this example from</t>

<figure><artwork type="go">for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}
</artwork></figure>

<t>Deferred functions are executed in LIFO order, so the above code prints: <spanx style="verb">4
3 2 1 0</spanx>.</t>
<t>With <spanx style="verb">defer</spanx> you can even change return values, provided that you are using
named result parameters and a function literal <iref item="functions" subitem="literal"/>, i.e:</t>

<figure><artwork type="go">defer func() {/* ... */}()
</artwork></figure>

<t>Here we use a function without a name and specify the body of the function
inline, basically we're creating a nameless function on the spot. The final
braces are needed because <spanx style="verb">defer</spanx> needs a function call, not a function value.
If our anonymous function would take an parameter it would be easier to see why
we need the braces:</t>

<figure><artwork type="go">defer func(x int) {/* ... */}(5)
</artwork></figure>

<t>In this (unnamed) function you can access any named return parameter:</t>

<figure><artwork type="go">func f() (ret int)
    defer func() { &lt;1&gt;
        ret++
    }()
    return 0
}
</artwork></figure>

<t>Here <spanx style="emph">1</spanx> we specify our function, the named return value <spanx style="verb">ret</spanx> is initialized
with zero. The nameless function in the defer increments the value of <spanx style="verb">ret</spanx>
with 1. The <spanx style="verb">return 0</spanx> on line
5 <spanx style="emph">will not be the returned value</spanx>, because of <spanx style="verb">defer</spanx>. The function <spanx style="verb">f</spanx> will
return 1!</t>
</section>

<section anchor="variadic-parameter" title="Variadic Parameter">
<t>Functions that take a variable number of parameters are known as variadic
functions. <iref item="functions" subitem="variadic"/> To declare a function as variadic, do
something like this:</t>

<figure><artwork type="go">func myfunc(arg ...int) {}
</artwork></figure>

<t>The <spanx style="verb">arg ...int</spanx> instructs Go to see this as a function that takes a variable
number of arguments. Note that these arguments all have to have the type <spanx style="verb">int</spanx>.
In the body of your function the variable <spanx style="verb">arg</spanx> is a slice of ints:</t>

<figure><artwork type="go">for _, n := range arg {
    fmt.Printf(&quot;And the number is: %d\n&quot;, n)
}
</artwork></figure>

<t>We range over the arguments on the first line. We are not interested in the
index as returned by <spanx style="verb">range</spanx>, hence the use of the underscore there. In the body
of the <spanx style="verb">range</spanx> we just print the parameters we were given.</t>
<t>If you don't specify the type of the variadic argument it defaults to the empty
interface <spanx style="verb">interface{}</spanx> (see Chapter <xref target="interfaces"></xref>).</t>
<t>Suppose we have another variadic function called <spanx style="verb">myfunc2</spanx>, the following
example shows how to pass variadic arguments to it:</t>

<figure><artwork type="go">func myfunc(arg ...int) {
    myfunc2(arg...)
    myfunc2(arg[:2]...)
}
</artwork></figure>

<t>With <spanx style="verb">myfunc2(arg...)</spanx> we pass all the parameters to <spanx style="verb">myfunc2</spanx>, but because the
variadic parameters is just a slice, we can use some slice tricks as well.</t>
</section>

<section anchor="panic-and-recovering" title="Panic and recovering">
<t>Go does not have an exception mechanism: you cannot throw exceptions. Instead it
uses a panic-and-recover mechanism. It is worth remembering that you should use
this as a last resort, your code will not look, or be, better if it is littered
with panics. It's a powerful tool: use it wisely. So, how do you use it? In the
words of the Go Authors <xref target="go_blog_panic"></xref>:</t>
<t>
<list style="hanging">
<t hangText="Panic">
<vspace />is a built-in function that stops the ordinary flow of control and begins
panicking. When the function <spanx style="verb">F</spanx> calls <spanx style="verb">panic</spanx>, execution of <spanx style="verb">F</spanx> stops, any
deferred functions in <spanx style="verb">F</spanx> are executed normally, and then <spanx style="verb">F</spanx> returns to its
caller. To the caller, <spanx style="verb">F</spanx> then behaves like a call to <spanx style="verb">panic</spanx>. The process
continues up the stack until all functions in the current goroutine have
returned, at which point the program crashes. Panics can be initiated by
invoking <spanx style="verb">panic</spanx> directly. They can also be caused by <spanx style="emph">runtime errors</spanx>, such as
out-of-bounds array accesses.</t>
<t hangText="Recover">
<vspace />is a built-in function that regains control of a panicking goroutine.
Recover is <spanx style="emph">only</spanx> useful inside <spanx style="emph">deferred</spanx> functions. During normal execution,
a call to <spanx style="verb">recover</spanx> will return <spanx style="verb">nil</spanx> and have no other effect. If the current
goroutine is panicking, a call to <spanx style="verb">recover</spanx> will capture the value given to
<spanx style="verb">panic</spanx> and resume normal execution.</t>
</list>
</t>
<t>This function checks if the function it gets as argument will panic when it is
executed:</t>

<figure><artwork type="go">func Panic(f func()) (b bool) { &lt;1&gt;
    defer func() { &lt;2&gt;
        if x := recover(); x != nil {
            b = true
        }
    }()
    f() &lt;3&gt;
    return &lt;4&gt;
}
</artwork></figure>

<t>We define a new function <spanx style="verb">Panic</spanx> <spanx style="emph">1</spanx> that takes a function as an argument (see
<xref target="functions-as-values"></xref>). It returns true if <spanx style="verb">f</spanx> panics when run, else false. We
then <spanx style="emph">2</spanx> define a <spanx style="verb">defer</spanx> function that utilizes <spanx style="verb">recover</spanx>. If the current
goroutine panics, this defer function will notice that. If <spanx style="verb">recover()</spanx> returns
non-<spanx style="verb">nil</spanx> we set <spanx style="verb">b</spanx> to true. At <spanx style="emph">3</spanx> Execute the function we received as the
argument. And finally <spanx style="emph">4</spanx> we return the value of <spanx style="verb">b</spanx>. Because <spanx style="verb">b</spanx> is a named
return parameter.</t>
<t>The following code fragment, shows how we can use this function:</t>

<figure><artwork type="go">func panicy() {
    var a []int
    a[3] = 5
}

func main() {
    fmt.Println(Panic(panicy))
}
</artwork></figure>

<t>On line 3 the <spanx style="verb">a[3] = 5</spanx> triggers a <spanx style="emph">runtime</spanx> out of bounds error which results
in a panic. Thus this program will print <spanx style="verb">true</spanx>. If we change line 2: <spanx style="verb">var
a []int</spanx> to <spanx style="verb">var a [4]int</spanx> the function <spanx style="verb">panicy</spanx> does not panic anymore. Why?</t>
</section>

<section anchor="exercises-1" title="Exercises">

<section anchor="average-1" title="Average">
<t>
<list style="numbers">
<t>Write a function that calculates the average of a <spanx style="verb">float64</spanx> slice.</t>
</list>
</t>
</section>

<section anchor="answer-3" title="Answer">
<t>
<list style="numbers">
<t>The following function calculates the average:</t>
</list>
</t>

<figure><artwork type="go">package main

func average(xs []float64) (avg float64) { //&lt;1&gt;
	sum := 0.0
	switch len(xs) {
	case 0:                 //&lt;2&gt;
		avg = 0
	default:                //&lt;3&gt;
		for _, v := range xs {
			sum += v
		}
		avg = sum / float64(len(xs)) //&lt;4&gt;
	}
	return  //&lt;5&gt;
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we use a named return parameter.  If the length of <spanx style="verb">xs</spanx> is zero <spanx style="emph">2</spanx>, we
 return 0.  Otherwise <spanx style="emph">3</spanx>, we calculate the average.  At <spanx style="emph">4</spanx>  we convert the
 value to a <spanx style="verb">float64</spanx> to make the division work as <spanx style="verb">len</spanx> returns an <spanx style="verb">int</spanx>.
 Finally, at <spanx style="emph">5</spanx> we reutrn our avarage.</t>
</section>

<section anchor="bubble-sort" title="Bubble sort">
<t>
<list style="numbers">
<t>Write a function that performs a bubble sort on a slice of ints. From <xref target="bubblesort"></xref>:</t>
</list>
</t>
<t>
<list style="empty">
<t>It works by repeatedly stepping through the list to be sorted, comparing each
pair of adjacent items and swapping them if they are in the wrong order. The
pass through the list is repeated until no swaps are needed, which indicates
that the list is sorted. The algorithm gets its name from the way smaller
elements &quot;bubble&quot; to the top of the list.</t>
</list></t>
<t>It also gives an example in pseudo code:</t>

<figure><artwork>procedure bubbleSort( A : list of sortable items )
  do
    swapped = false
    for each i in 1 to length(A) - 1 inclusive do:
      if A[i-1] &gt; A[i] then
        swap( A[i-1], A[i] )
        swapped = true
      end if
    end for
  while swapped
end procedure
</artwork></figure>

</section>

<section anchor="answer-4" title="Answer">
<t>
<list style="numbers">
<t>Bubble sort isn't terribly efficient. For <spanx style="verb">n</spanx> elements it scales <spanx style="verb">O(n^2)</spanx>.
But bubble sort is easy to implement:
<figure><artwork type="go">
func main() {
	n := []int{5, -1, 0, 12, 3, 5}
	fmt.Printf(&quot;unsorted %v\n&quot;, n)
	bubblesort(n)
	fmt.Printf(&quot;sorted %v\n&quot;, n)
}

func bubblesort(n []int) {
	for i := 0; i &lt; len(n)-1; i++ {
		for j := i + 1; j &lt; len(n); j++ {
			if n[j] &lt; n[i] {
				n[i], n[j] = n[j], n[i]
			}
</artwork></figure>

<vspace />
Because a slice is a reference type, the <spanx style="verb">bubblesort</spanx> function works and
does not need to return a sorted slice.</t>
</list>
</t>
</section>

<section anchor="for-loop-ii" title="For-loop II">
<t>
<list style="numbers">
<t>Take what you did in exercise to write the for loop and extend it a bit.
Put the body of the for loop - the <spanx style="verb">fmt.Printf</spanx> - in a separate function.</t>
</list>
</t>
</section>

<section anchor="answer-5" title="Answer">
<t>1.
 &lt;{{src/for-func.go}}</t>
</section>

<section anchor="fibonacci" title="Fibonacci">
<t>
<list style="numbers">
<t>The Fibonacci sequence starts as follows: <spanx style="verb">1, 1, 2, 3, 5, 8, 13, \ldots</spanx>
Or in mathematical terms: <spanx style="verb">x_1 = 1; x_2 = 1; x_n = x_{n-1} + x_{n-2}\quad\forall n &gt; 2</spanx>.<vspace />
Write a function that takes an <spanx style="verb">int</spanx> value and gives
that many terms of the Fibonacci sequence.</t>
</list>
</t>
</section>

<section anchor="answer-6" title="Answer">
<t>
<list style="numbers">
<t>The following program calculates Fibonacci numbers:</t>
</list>
</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

func fibonacci(value int) []int {
	x := make([]int, value) &lt;1&gt;
	x[0], x[1] = 1, 1       &lt;2&gt;
	for n := 2; n &lt; value; n++ {
		x[n] = x[n-1] + x[n-2] &lt;3&gt;
	}
	return x &lt;4&gt;
}

func main() {
	for _, term := range fibonacci(10) { &lt;5&gt;
		fmt.Printf(&quot;%v &quot;, term)
	}
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we create an array to hold the integers up to the value given in
the function call.  At <spanx style="emph">2</spanx> we start the Fibonacci calculation. Then <spanx style="emph">3</spanx>:
<spanx style="verb">x_n = x_{n-1} + x_{n-2}</spanx>.  At <spanx style="emph">4</spanx> we return the <spanx style="emph">entire</spanx> array.
And at <spanx style="emph">5</spanx> we use the <spanx style="verb">range</spanx> keyword to  &quot;walk&quot; the numbers returned by the
Fibonacci function. Here up to 10. Finally, we print the numbers.</t>
</section>

<section anchor="var-args" title="Var args">
<t>
<list style="numbers">
<t>Write a function that takes a variable number of ints and print each integer on a separate line.</t>
</list>
</t>
</section>

<section anchor="answer-7" title="Answer">
<t>
<list style="numbers">
<t>For this we need the <spanx style="verb">{...}</spanx>-syntax to signal we define a
function that takes an arbitrary number of arguments.
<figure><artwork type="go">package main

import &quot;fmt&quot;

func main() {
	printthem(1, 4, 5, 7, 4)
	printthem(1, 2, 4)
}

func printthem(numbers ...int) {
	for _, d := range numbers {
		fmt.Printf(&quot;%d\n&quot;, d)
	}
}
</artwork></figure>

</t>
</list>
</t>
</section>

<section anchor="functions-that-return-functions" title="Functions that return functions">
<t>
<list style="numbers">
<t>Write a function that returns a function that performs a <spanx style="verb">+2</spanx> on integers. Name the function <spanx style="verb">plusTwo</spanx>.
You should then be able do the following:
<figure><artwork type="go">p := plusTwo()
fmt.Printf(&quot;%v\n&quot;, p(2))
</artwork></figure>

<vspace />
Which should print 4. See <xref target="callbacks"></xref>.</t>
<t>Generalize the function from above and create a <spanx style="verb">plusX(x)</spanx> which returns functions that add <spanx style="verb">x</spanx> to an integer.</t>
</list>
</t>
</section>

<section anchor="answer-8" title="Answer">
<t>
<list style="numbers">
<t>Define a new function that returns a function: <spanx style="verb">return func(x int) int { return x + 2 }</spanx>
Function literals at work, we define the +2--function right there in the return statement.
<figure><artwork type="go">func main() {
   p2 := plusTwo()
   fmt.Printf(&quot;%v\n&quot;,p2(2))
}


func plusTwo() func(int) int { &lt;1&gt;
    return func(x int) int { return x + 2 } &lt;2&gt;
}
</artwork></figure>

</t>
<t>Here we use a closure:
<figure><artwork type="go">func plusX(x int) func(int) int { &lt;1&gt;
   return func(y int) int { return x + y } &lt;2&gt;
}
</artwork></figure>

<vspace />
Here <spanx style="emph">1</spanx>, we again define a function that returns a function.
We use the <spanx style="emph">local</spanx> variable <spanx style="verb">x</spanx> in the function literal at <spanx style="emph">2</spanx>.</t>
</list>
</t>
</section>

<section anchor="maximum" title="Maximum">
<t>
<list style="numbers">
<t>Write a function that finds the
maximum value in an <spanx style="verb">int</spanx> slice (<spanx style="verb">[]int</spanx>).</t>
</list>
</t>
</section>

<section anchor="answer-9" title="Answer">
<t>
<list style="numbers">
<t>This function returns the largest int in the slice \var{l}:
<figure><artwork type="go">func max(l []int) (max int) {   &lt;1&gt;
    max = l[0]
    for _, v := range l {   &lt;2&gt;
        if v &gt; max {    &lt;3&gt;
            max = v
        }
    }
    return &lt;4&gt;
}
</artwork></figure>

<vspace />
At <spanx style="emph">1</spanx> we use a named return parameter.
At <spanx style="emph">2</spanx> we loop over <spanx style="verb">l</spanx>. The index of the element is not important.
At <spanx style="emph">3</spanx>, if we find a new maximum, we remember it.
And at <spanx style="emph">4</spanx> we have a &quot;lone&quot; return; the current value of <spanx style="verb">max</spanx> is now returned.</t>
</list>
</t>
</section>

<section anchor="map-function" title="Map function">
<t>A <spanx style="verb">map()</spanx>-function is a function that takes
a function and a list. The function is applied to
each member in the list and a new list containing
these calculated values is returned.
Thus:</t>
<t><spanx style="verb"> \mathrm{map}(f(), (a_1,a_2,\ldots,a_{n-1},a_n)) =  (f(a_1), f(a_2),\ldots,f(a_{n-1}), f(a_n)) </spanx></t>
<t>
<list style="numbers">
<t>Write a simple
<spanx style="verb">map()</spanx>-function in Go. It is sufficient for this function only to work for ints.</t>
</list>
</t>
</section>

<section anchor="answer-10" title="Answer">
<t>
<list style="numbers">
<t>A possible answer:
<figure><artwork type="go">func Map(f func(int) int, l []int) []int {
    j := make([]int, len(l))
    for k, v := range l {
        j[k] = f(v)
    }
    return j
}


func main() {
    m := []int{1, 3, 4}
    f := func(i int) int {
        return i * i
    }
    fmt.Printf(&quot;%v&quot;, (Map(f, m)))
}
</artwork></figure>

</t>
</list>
</t>
</section>

<section anchor="stack" title="Stack">
<t>
<list style="numbers">
<t>Create a simple stack which can hold a
fixed number of ints. It does not have to grow beyond this limit.
Define <spanx style="verb">push</spanx> -- put something on the stack -- and <spanx style="verb">pop</spanx>
-- retrieve something from the stack -- functions. The stack should be
a LIFO (last in, first out) stack.</t>
</list>
</t>
<figure title="A stack.
"></figure>
<t>
<list style="numbers">
<t>Write a <spanx style="verb">String</spanx> method which
converts the stack to a string representation.
The stack in the figure could be represented as: <spanx style="verb">[0:m] [1:l] [2:k]</spanx> .</t>
</list>
</t>
</section>

<section anchor="answer-11" title="Answer">
<t>
<list style="numbers">
<t>First we define a new type that represents a stack; we need an
array (to hold the keys) and an index, which points to the last element.
Our small stack can only hold 10 elements.
<figure><artwork type="go">type stack struct {
    i    int
    data [10]int
}
</artwork></figure>

</t>
</list>
</t>
<t>Next we need the <spanx style="verb">push</spanx> and <spanx style="verb">pop</spanx> functions to actually
use the thing. First we show the <spanx style="emph">wrong</spanx> solution!</t>
<t>In Go, data passed to functions is <spanx style="emph">passed-by-value</spanx> meaning a copy
is created and given to the function. The first stab for the function
<spanx style="verb">push</spanx> could be:</t>

<figure><artwork type="go">func (s stack) push(k int) {
    if s.i+1 &gt; 9 {
            return
    }
    s.data[s.i] = k
    s.i++
}
</artwork></figure>

<t>The function works on the <spanx style="verb">s</spanx> which is of the type <spanx style="verb">stack</spanx>. To
use this we just call <spanx style="verb">s.push(50)</spanx>, to push the integer 50 on
the stack. But the push function gets a copy of <spanx style="verb">s</spanx>, so it is
<spanx style="emph">not</spanx> working on the <spanx style="emph">real</spanx> thing. Nothing gets pushed to our
stack. For example the following code:</t>

<figure><artwork type="go">var s stack
s.push(25)
fmt.Printf(&quot;stack %v\n&quot;, s);
s.push(14)
fmt.Printf(&quot;stack %v\n&quot;, s);
</artwork></figure>

<t>prints:</t>

<figure><artwork>stack [0:0]
stack [0:0]
</artwork></figure>

<t>To solve this we need to give the function <spanx style="verb">push</spanx> a pointer
to the stack. This means we need to change <spanx style="verb">push</spanx> from</t>

<figure><artwork type="go">func (s stack) push(k int)
</artwork></figure>

<t>to</t>

<figure><artwork type="go">func (s *stack) push(k int).
</artwork></figure>

<t>We should now use <spanx style="verb">new()</spanx> (see <xref target="allocation-with-new"></xref>).
in <xref target="beyond-the-basics"></xref> to create a <spanx style="emph">pointer</spanx> to a newly
allocated <spanx style="verb">stack</spanx>, so line 1 from the example above needs to be
<spanx style="verb">s := new(stack)</spanx> .</t>
<t>And our two functions become:</t>

<figure><artwork type="go">func (s *stack) push(k int) {
    s.data[s.i] = k
    s.i++
}

func (s *stack) pop() int {
    s.i--
    ret := s.data[s.i]
    s.data[s.i] = 0
    return ret
}
</artwork></figure>

<t>Which we then use as follows:</t>

<figure><artwork type="go">func main() {
    var s stack
    s.push(25)
    s.push(14)
    fmt.Printf(&quot;stack %v\n&quot;, s)
}
</artwork></figure>

<t>
<list style="numbers">
<t><spanx style="verb">fmt.Printf(&quot;%v&quot;)</spanx> can
print any value (<spanx style="verb">%v</spanx>) that satisfies the <spanx style="verb">Stringer</spanx> interface
(see <xref target="interfaces"></xref>).
For this to work we only need to define a <spanx style="verb">String()</spanx> function for
our type:
<figure><artwork type="go">func (s stack) String() string {
    var str string
    for i := 0; i &lt;= s.i; i++ {
        str = str + &quot;[&quot; +
            strconv.Itoa(i) + &quot;:&quot; + strconv.Itoa(s.data[i]) + &quot;]&quot;
    }
    return str
}
</artwork></figure>

</t>
</list>
</t>
</section>
</section>
</section>

<section anchor="packages" title="Packages">
<t>
<list style="empty">
<t>&quot;^(")</t>
<t>Answer to whether there is a bit wise negation operator -- Ken Thompson
</t>
</list></t>
<t>A package <iref item="package"/> is a collection of functions and data.</t>
<t>You declare a package with the <spanx style="verb">package</spanx><iref item="keywords" subitem="package"/> keyword. The
filename does not have to match the package name. The convention for package
names is to use lowercase characters. Go packages may consist of multiple files,
but they share the <spanx style="verb">package &lt;name&gt;</spanx> line. Let's define a package <spanx style="verb">even</spanx> in the
file <spanx style="verb">even.go</spanx>.</t>
<t><iref item="functions" subitem="exported"/>
<iref item="functions" subitem="private"/>
<iref item="functions" subitem="public"/></t>

<figure><artwork type="go">package even &lt;1&gt;

func Even(i int) bool { &lt;2&gt;
	return i%2 == 0
}

func odd(i int) bool { &lt;3&gt;
	return i%2 == 1
}
</artwork></figure>

<t>Here <spanx style="emph">1</spanx> we start a new namespace: &quot;even&quot;. The function <spanx style="verb">Even</spanx> <spanx style="emph">2</spanx> starts with
a capital letter. This means the function is <spanx style="emph">exported</spanx>, and may be used outside
our package (more on that later). The function <spanx style="verb">odd</spanx> <spanx style="emph">3</spanx> does not start with
a capital letter, so it is a <spanx style="emph">private</spanx> function.</t>
<t>Now we just need to build the package. We create a directory under <spanx style="verb">$GOPATH</spanx>,
and copy <spanx style="verb">even.go</spanx> there (see <xref target="compiling-and-running-code"></xref> in <xref target="basics"></xref>).</t>

<figure><artwork>% mkdir $GOPATH/src/even
% cp even.go $GOPATH/src/even
% go build
% go install
</artwork></figure>

<t>Now we can use the package in our own program <spanx style="verb">myeven.go</spanx>:</t>

<figure><artwork type="go">package main

import ( &lt;1&gt;
	&quot;even&quot; &lt;2&gt;
	&quot;fmt&quot;  &lt;3&gt;
)

func main() {
	i := 5
	fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.Even(i)) &lt;4&gt;
}
</artwork></figure>

<t>Import <spanx style="emph">1</spanx> the following packages. The <spanx style="emph">local</spanx> package <spanx style="verb">even</spanx> is imported here
<spanx style="emph">2</spanx>. This <spanx style="emph">3</spanx> imports the official <spanx style="verb">fmt</spanx> package. And now we use <spanx style="emph">4</spanx> the
function from the <spanx style="verb">even</spanx> package. The syntax for accessing a function from
a package is <spanx style="verb">&lt;package&gt;.FunctionName()</spanx>. And finally we can build our program.</t>

<figure><artwork>% go build myeven.go
% ./myeven
Is 5 even? false
</artwork></figure>

<t>If we change our <spanx style="verb">myeven.go</spanx> at <spanx style="emph">4</spanx> to use the unexported function <spanx style="verb">even.odd</spanx>:
<spanx style="verb">fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.odd(i))</spanx> We get an error when compiling,
because we are trying to use a
<spanx style="emph">private</spanx> function:</t>

<figure><artwork>myeven.go: cannot refer to unexported name even.odd
</artwork></figure>

<t>Note that the &quot;starts with capital <spanx style="verb">\rightarrow</spanx> exported&quot;, &quot;starts with
lower-case <spanx style="verb">\rightarrow</spanx> private&quot; rule also extends to other names (new
types, global variables) defined in the package. Note that the term &quot;capital&quot; is
not limited to US-ASCII -- it extends to all bicameral alphabets (Latin, Greek,
Cyrillic, Armenian and Coptic).</t>

<section anchor="identifiers" title="Identifiers">
<t>The Go standard library names some function with the old (Unix) names while
others are in CamelCase. The convention is to leave well-known legacy
not-quite-words alone rather than try to figure out where the capital letters
go:  <spanx style="verb">Atoi</spanx>, <spanx style="verb">Getwd</spanx>, <spanx style="verb">Chmod</spanx>. CamelCasing works best when you have whole words
to work with: <spanx style="verb">ReadFile</spanx>, <spanx style="verb">NewWriter</spanx>, <spanx style="verb">MakeSlice</spanx>. The convention in Go is to
use CamelCase rather than underscores to write multi-word names.</t>
<t>As we did above in our <spanx style="verb">myeven</spanx> program, accessing content from an imported
(with <spanx style="verb">import</spanx> <iref item="keywords" subitem="import"/>) package is done with using the package's
name and then a dot.  After <iref item="package" subitem="bytes"/> <spanx style="verb">import &quot;bytes&quot;</spanx> the importing
program can talk about <spanx style="verb">bytes.Buffer</spanx>. A package name should be good, short,
concise and evocative. The convention in Go is that package names are lowercase,
single word names.</t>
<t>The package name used in the <spanx style="verb">import</spanx> statement is the default name used. But if
the need arises (two different packages with the same name for instance), you
can override this default: <spanx style="verb">import bar &quot;bytes&quot;</spanx> The function <spanx style="verb">Buffer</spanx> is now
accessed as <spanx style="verb">bar.Buffer</spanx>.</t>
<t>Another convention is that the package name is the base name of its source
directory; the package in <spanx style="verb">src/compress/gzip</spanx> is imported as <spanx style="verb">compress/gzip</spanx> but
has name <spanx style="verb">gzip</spanx>, not <spanx style="verb">compress/gzip</spanx>.</t>
<t>It is important to avoid stuttering when naming things. For instance, the
buffered reader type in the <spanx style="verb">bufio</spanx> <iref item="package" subitem="bufio"/> package is called
<spanx style="verb">Reader</spanx>, not <spanx style="verb">BufReader</spanx>, because users see it as <spanx style="verb">bufio.Reader</spanx>, which is
a clear, concise name.</t>
<t>Similarly, the function to make new instances of <spanx style="verb">ring.Ring</spanx> (package
<spanx style="verb">container/ring</spanx>), would normally be called <spanx style="verb">NewRing</spanx>, but since <spanx style="verb">Ring</spanx> is the
only type exported by the package, and since the package is called
<spanx style="verb">ring</spanx><iref item="package" subitem="ring"/>, it's called just <spanx style="verb">New</spanx>. Clients of the package see
that as <spanx style="verb">ring.New</spanx>. Use the package structure to help you choose good names.</t>
<t>Another short example is <spanx style="verb">once.Do</spanx> (see package <spanx style="verb">sync</spanx>); <spanx style="verb">once.Do(setup)</spanx> reads
well and would not be improved by writing <spanx style="verb">once.DoOrWaitUntilDone(setup)</spanx>. Long
names don't automatically make things more readable.</t>
</section>

<section anchor="documenting-packages" title="Documenting packages">
<t>When we created our <spanx style="verb">even</spanx> package, we skipped over an important item:
documentation. Each package should have a <spanx style="emph">package comment</spanx>, a block comment
preceding the <spanx style="verb">package</spanx> clause. In our case we should extend the beginning of
the package, with:</t>

<figure><artwork type="go">// The even package implements a fast function for detecting if an integer
// is even or not.
package even
</artwork></figure>

<t>When running <spanx style="verb">go doc</spanx> this will show up at the top of the page. When a package
consists of multiple files the package comment should only appear in one
file. A common convention (in really big packages) is to have a separate
<spanx style="verb">doc.go</spanx> that only holds the package comment. Here is a snippet from the
official <spanx style="verb">regexp</spanx> package:</t>

<figure><artwork type="go">/*
    The regexp package implements a simple library for
    regular expressions.

    The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
*/
package regexp
</artwork></figure>

<t>Each defined (and exported) function should have a small line of text
documenting the behavior of the function. Again to extend our <spanx style="verb">even</spanx> package:</t>

<figure><artwork type="go">// Even returns true of i is even. Otherwise false is returned.
func Even(i int) bool {
</artwork></figure>

<t>And even though <spanx style="verb">odd</spanx> is not exported, it's good form to document it as well.</t>

<figure><artwork type="go">// odd is the opposite of Even.
func odd(i int) bool {
</artwork></figure>

</section>

<section anchor="testing-packages" title="Testing packages">
<t>In Go it is customary to write (unit) tests for your package. Writing tests
involves the <spanx style="verb">testing</spanx> package and the program <spanx style="verb">go test</spanx><iref item="tooling" subitem="go test"/>.
Both have excellent documentation.</t>
<t>The <spanx style="verb">go test</spanx> program runs all the test functions. Without any defined tests for
our <spanx style="verb">even</spanx> package, <spanx style="verb">go test</spanx> yields:</t>

<figure><artwork>% go test
?       even    [no test files]
</artwork></figure>

<t>Let us fix this by defining a test in a test file. Test files reside in the
package directory and are named <spanx style="verb">*_test.go</spanx>. Those test files are just like
other Go programs, but <spanx style="verb">go test</spanx> will only execute the test functions. Each test
function has the same signature and its name should start with
<spanx style="verb">Test</spanx>: <spanx style="verb">func TestXxx(t *testing.T)</spanx> .</t>
<t>When writing test you will need to tell <spanx style="verb">go test</spanx> whether a test was
successful or not. A successful test function just returns. When
the test fails you can signal this with the following
functions. These are the most important ones (see <spanx style="verb">go doc testing</spanx> or <spanx style="verb">go help testfunc</spanx> for more):</t>
<t>
<list style="symbols">
<t><spanx style="verb">func (t *T) Fail()</spanx>, <spanx style="verb">Fail</spanx> marks the test function as having failed but
continues execution.</t>
<t><spanx style="verb">func (t *T) FailNow()</spanx>, <spanx style="verb">FailNow</spanx> marks the test function as having failed
and stops its execution. Any remaining tests in this file are skipped, and
execution continues with the next test.</t>
<t><spanx style="verb">func (t *T) Log(args ...interface{})</spanx>, <spanx style="verb">Log</spanx> formats its arguments using
default formatting, analogous to <spanx style="verb">Print()</spanx>, and records the text in the error
log.</t>
<t><spanx style="verb">func (t *T) Fatal(args ...interface{})</spanx>, <spanx style="verb">Fatal</spanx> is equivalent to <spanx style="verb">Log()</spanx>
followed by <spanx style="verb">FailNow()</spanx>.</t>
</list>
</t>
<t>Putting all this together we can write our test. First we pick a name:
<spanx style="verb">even_test.go</spanx>. Then we add the following contents:</t>

<figure><artwork type="go">package even &lt;1&gt;

import &quot;testing&quot; &lt;2&gt;

func TestEven(t *testing.T) { &lt;3&gt;
	if !Even(2) {
		t.Log(&quot;2 should be even!&quot;)
		t.Fail()
	}
}
</artwork></figure>

<t>A test file belongs to the current <spanx style="emph">1</spanx> package. This is not only convenient, but
also allows tests of unexported functions and structures. We then <spanx style="emph">2</spanx> import the
<spanx style="verb">testing</spanx> package. And finally the test we want to execute. The code here <spanx style="emph">3</spanx>
should hold no surprises: we check if the <spanx style="verb">Even</spanx> function works OK. And now, the
moment we have been waiting form executing the test.</t>

<figure><artwork>% go test
ok      even    0.001s
</artwork></figure>

<t>Our test ran and reported <spanx style="verb">ok</spanx>. Success! If we redefine our test function, we
can see the result of a failed test:</t>

<figure><artwork type="go">// Entering the twilight zone
func TestEven(t *testing.T) {
    if Even(2) {
        t.Log(&quot;2 should be odd!&quot;)
        t.Fail()
    }
}
</artwork></figure>

<t>We now get:</t>

<figure><artwork>FAIL    even    0.004s
--- FAIL: TestEven (0.00 seconds)
    2 should be odd!
FAIL
</artwork></figure>

<t>And you can act accordingly (by fixing the test for instance).</t>
<t>Writing new packages should go hand in hand with writing (some)
documentation and test functions. It will make your code better and it
shows that you really put in the effort.</t>
<t>The Go test suite also allows you to incorporate example functions which serve
as documentation <spanx style="emph">and</spanx> as tests. These functions need to start with <spanx style="verb">Example</spanx>.</t>

<figure><artwork type="go">func ExampleEven() {
    if Even(2) {
        fmt.Printf(&quot;Is even\n&quot;)
    }
    // Output: &lt;1&gt;
    // Is even
}
</artwork></figure>

<t>Those last two comments lines <spanx style="emph">1</spanx> are part of the example, <spanx style="verb">go test</spanx> uses those
to check the <spanx style="emph">generated</spanx> output with the text in the comments. If there is
a mismatch the test fails.</t>
</section>

<section anchor="useful-packages" title="Useful packages">
<t>The standard libary of Go includes a huge number of packages. It is very
enlightening to browse the <spanx style="verb">$GOROOT/src/pkg</spanx> directory and look at the
packages. We cannot comment on each package, but the following are worth
a mention: </t>
<t>
<list style="hanging">
<t hangText="fmt">
<vspace /><iref item="package" subitem="fmt"/>
Package <spanx style="verb">fmt</spanx> implements formatted I/O with functions analogous
to C's <spanx style="verb">printf</spanx> and <spanx style="verb">scanf</spanx>. The format verbs are derived
from C's but are simpler. Some verbs (%-sequences) that can be used:
<list style="symbols">
<t><spanx style="emph">%v</spanx>, the value in a default format. when printing structs, the plus flag (%+v) adds field names.</t>
<t><spanx style="emph">%#v</spanx>, a Go-syntax representation of the value.</t>
<t><spanx style="emph">%T</spanx>, a Go-syntax representation of the type of the value.</t>
</list></t>
<t hangText="io">
<vspace /><iref item="package" subitem="io"/>
This package provides basic interfaces to I/O primitives.
Its primary job is to wrap existing implementations of such primitives,
such as those in package os, into shared public interfaces that
abstract the functionality, plus some other related primitives.</t>
<t hangText="bufio">
<vspace /><iref item="package" subitem="bufio"/>
This package implements buffered I/O.  It wraps an
<spanx style="verb">io.Reader</spanx>
or
<spanx style="verb">io.Writer</spanx>
object, creating another object (Reader or Writer) that also implements
the interface but provides buffering and some help for textual I/O.</t>
<t hangText="sort">
<vspace /><iref item="package" subitem="sort"/>
The <spanx style="verb">sort</spanx> package provides primitives for sorting arrays
and user-defined collections.</t>
<t hangText="strconv">
<vspace /><iref item="package" subitem="strconv"/>
The <spanx style="verb">strconv</spanx> package implements conversions to and from
string representations of basic data types.</t>
<t hangText="os">
<vspace /><iref item="package" subitem="os"/>
The <spanx style="verb">os</spanx> package provides a platform-independent interface to operating
system functionality.  The design is Unix-like.</t>
<t hangText="sync">
<vspace /><iref item="package" subitem="sync"/>
The package <spanx style="verb">sync</spanx> provides basic synchronization primitives such as mutual
exclusion locks.</t>
<t hangText="flag">
<vspace /><iref item="package" subitem="flag"/>
The <spanx style="verb">flag</spanx> package implements command-line flag parsing.</t>
<t hangText="encoding/json">
<vspace /><iref item="package" subitem="encoding/json"/>
The <spanx style="verb">encoding/json</spanx> package implements encoding and decoding of JSON objects as
defined in RFC 4627 <xref target="RFC4627"></xref>.</t>
<t hangText="html/template">
<vspace /><iref item="package" subitem="html/template"/>
Data-driven templates for generating textual output such as HTML.<vspace />
Templates are executed by applying them to a data structure.  Annotations in
the template refer to elements of the data structure (typically a field of
a struct or a key in a map) to control execution and derive values to be
displayed.  The template walks the structure as it executes and the &quot;cursor&quot;
@ represents the value at the current location in the structure.</t>
<t hangText="net/http">
<vspace /><iref item="package" subitem="net/http"/>
The <spanx style="verb">net/http</spanx> package implements parsing of HTTP requests, replies,
and URLs and provides an extensible HTTP server and a basic
HTTP client.</t>
<t hangText="unsafe">
<vspace /><iref item="package" subitem="unsafe"/>
The <spanx style="verb">unsafe</spanx> package contains operations that step around the type safety of Go programs.
Normally you don't need this package, but it is worth mentioning that <spanx style="emph">unsafe</spanx> Go programs
are possible.</t>
<t hangText="reflect">
<vspace /><iref item="package" subitem="reflect"/>
The <spanx style="verb">reflect</spanx> package implements run-time reflection, allowing a program to
manipulate objects with arbitrary types.  The typical use is to take a
value with static type <spanx style="verb">interface{}</spanx> and extract its dynamic type
information by calling <spanx style="verb">TypeOf</spanx>, which returns an object with interface
type <spanx style="verb">Type</spanx>. See <xref target="interfaces"></xref>, Section <xref target="introspection-and-reflection"></xref>.</t>
<t hangText="os/exec">
<vspace /><iref item="package" subitem="os/exec"/> The <spanx style="verb">os/exec</spanx> package runs external commands.</t>
</list>
</t>
</section>

<section anchor="exercises-2" title="Exercises">

<section anchor="stack-as-package" title="Stack as package">
<t>
<list style="numbers">
<t>See the Stack exercise. In this exercise we want to create a separate package
for that code. Create a proper package for your stack implementation, <spanx style="verb">Push</spanx>,
<spanx style="verb">Pop</spanx> and the <spanx style="verb">Stack</spanx> type need to be exported.</t>
<t>Write a simple unit test for this package.
You should at least test that a <spanx style="verb">Pop</spanx> works after a <spanx style="verb">Push</spanx>.</t>
</list>
</t>
</section>

<section anchor="answer-12" title="Answer">
<t>
<list style="numbers">
<t>There are a few details that should be changed to make a proper package
for our stack. First, the exported functions should begin with a capital
letter and so should <spanx style="verb">Stack</spanx>. The package file is named <spanx style="verb">stack-as-package.go</spanx>
and contains:
<figure><artwork type="go">package stack

// Stack holds the items.
type Stack struct {
	i    int
	data [10]int
}

// Push pushes an item on the stack.
func (s *Stack) Push(k int) {
	s.data[s.i] = k
	s.i++
}

// Pop pops an item from the stack.
func (s *Stack) Pop() (ret int) {
	s.i--
	ret = s.data[s.i]
	return
}
</artwork></figure>

</t>
<t>To make the unit testing work properly you need to do some
preparations. We'll come to those in a minute. First the actual unit test.
Create a file with the name <spanx style="verb">pushpop_test.go</spanx>, with the following contents:</t>
</list>
</t>

<figure><artwork type="go">package stack

import &quot;testing&quot;

func TestPushPop(t *testing.T) {
	c := new(Stack)
	c.Push(5)
	if c.Pop() != 5 {
		t.Log(&quot;Pop doesn't give 5&quot;)
		t.Fail()
	}
}
</artwork></figure>

<t>For <spanx style="verb">go test</spanx> to work we need to put our package files in a directory
under <spanx style="verb">$GOPATH/src</spanx>:</t>

<figure><artwork>% mkdir $GOPATH/src/stack
% cp pushpop_test.go $GOPATH/src/stack
% cp stack-as-package.go $GOPATH/src/stack
</artwork></figure>

<t>Yields:</t>

<figure><artwork>% go test stack
ok stack 0.001s
</artwork></figure>

</section>

<section anchor="calculator" title="Calculator">
<t>
<list style="numbers">
<t>Create a reverse polish calculator. Use your stack package.</t>
</list>
</t>
</section>

<section anchor="answer-13" title="Answer">
<t>
<list style="numbers">
<t>This is one answer:</t>
</list>
</t>

<figure><artwork type="go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strconv&quot;
)

var reader *bufio.Reader = bufio.NewReader(os.Stdin)
var st = new(Stack)

type Stack struct {
	i    int
	data [10]int
}

func (s *Stack) push(k int) {
	if s.i+1 &gt; 9 {
		return
	}
	s.data[s.i] = k
	s.i++
}

func (s *Stack) pop() (ret int) {
	s.i--
	if s.i &lt; 0 {
		s.i = 0
		return
	}
	ret = s.data[s.i]
	return
}

func main() {
	for {
		s, err := reader.ReadString('\n')
		var token string
		if err != nil {
			return
		}
		for _, c := range s {
			switch {
			case c &gt;= '0' &amp;&amp; c &lt;= '9':
				token = token + string(c)
			case c == ' ':
				r, _ := strconv.Atoi(token)
				st.push(r)
				token = &quot;&quot;
			case c == '+':
				fmt.Printf(&quot;%d\n&quot;, st.pop()+st.pop())
			case c == '*':
				fmt.Printf(&quot;%d\n&quot;, st.pop()*st.pop())
			case c == '-':
				p := st.pop()
				q := st.pop()
				fmt.Printf(&quot;%d\n&quot;, q-p)
			case c == 'q':
				return
			default:
				//error
			}
		}
	}
}
</artwork></figure>

</section>
</section>
</section>

<section anchor="beyond-the-basics" title="Beyond the basics">
<t>
<list style="empty">
<t>Go has pointers but not pointer arithmetic. You cannot use a pointer
variable to walk through the bytes of a string.</t>
<t>Go For C++ Programmers -- Go Authors
</t>
</list></t>
<t>In this chapter we delve deeper in to the language.</t>
<t>Go has pointers. There is however no pointer arithmetic, so they act more like
references than pointers that you may know from C. Pointers are useful. Remember
that when you call a function in Go, the variables are
<spanx style="emph">pass-by-value</spanx>. So, for efficiency and the possibility to modify a passed value
 <spanx style="emph">in</spanx> functions we have pointers.</t>
<t>You declare a pointer by prefixing the type with an '<spanx style="verb">*</spanx>': <spanx style="verb">var p *int</spanx>. Now <spanx style="verb">p</spanx>
is a pointer to an integer value. All newly declared variables are assigned
their zero value and pointers are no different. A newly declared pointer, or
just a pointer that points to nothing, has a nil-value <iref item="nil"/>. In other
languages this is often called a NULL pointer in Go it is just <spanx style="verb">nil</spanx>. To make
a pointer point to something you can use the address-of operator
<iref item="operators" subitem="address-of"/> (<spanx style="verb">&amp;</spanx>), which we demonstrate here:</t>

<figure><artwork type="go">var p *int
fmt.Printf(&quot;%v&quot;, p) &lt;1&gt;

var i int	    &lt;2&gt;
p = &amp;i		    &lt;3&gt;

fmt.Printf(&quot;%v&quot;, p) &lt;4&gt;
</artwork></figure>

<t>This <spanx style="emph">1</spanx> Prints <spanx style="verb">nil</spanx>. Declare <spanx style="emph">2</spanx> an integer variable <spanx style="verb">i</spanx>. Make <spanx style="verb">p</spanx> point <spanx style="emph">3</spanx>
to <spanx style="verb">i</spanx>, i.e. take the address of <spanx style="verb">i</spanx>. And this <spanx style="emph">4</spanx> will print something like
<spanx style="verb">0x7ff96b81c000a</spanx>. De-referencing a pointer is done by prefixing the pointer
variable with <spanx style="verb">*</spanx>.</t>
<t>As said, there is no pointer arithmetic, so if you write: <spanx style="verb">*p++</spanx>, it is
interpreted as <spanx style="verb">(*p)++</spanx>: first reference and then increment the
value.<iref item="operators" subitem="increment"/></t>

<section anchor="allocation" title="Allocation">
<t>Go also has garbage collection, meaning that you don't have to worry about
memory deallocation.</t>
<t>To allocate memory Go has two primitives, <spanx style="verb">new</spanx> and <spanx style="verb">make</spanx>. They do different
things and apply to different types, which can be confusing, but the rules are
simple. The following sections show how to handle allocation in Go and hopefully
clarifies the somewhat artificial distinction between <spanx style="verb">new</spanx> <iref item="built-in" subitem="new"/>
and <spanx style="verb">make</spanx> <iref item="built-in" subitem="make"/>.</t>

<section anchor="allocation-with-new" title="Allocation with new">
<t>The built-in function <spanx style="verb">new</spanx> is essentially the same as its namesakes in other
languages: <spanx style="verb">new(T)</spanx> allocates zeroed storage for a new item of type <spanx style="verb">T</spanx> and
returns its address, a value of type <spanx style="verb">*T</spanx>. Or in other words, it returns
a pointer to a newly allocated zero value of type <spanx style="verb">T</spanx>. This is important to
remember.</t>
<t>The documentation for <spanx style="verb">bytes.Buffer</spanx> states that &quot;the zero value for Buffer is
an empty buffer ready to use.&quot;. Similarly, <spanx style="verb">sync.Mutex</spanx> does not have an
explicit constructor or Init method. Instead, the zero value for a <spanx style="verb">sync.Mutex</spanx>
is defined to be an unlocked mutex.</t>
</section>

<section anchor="allocation-with-make" title="Allocation with make">
<t>The built-in function <spanx style="verb">make(T, args)</spanx> serves a purpose different from <spanx style="verb">new(T)</spanx>.
It creates slices, maps, and channels <spanx style="emph">only</spanx>, and it returns an initialized (not
zero!) value of type <spanx style="verb">T</spanx>, and not a pointer: <spanx style="verb">*T</spanx>. The reason for the
distinction is that these three types are, under the covers, references to data
structures that must be initialized before use. A slice, for example, is
a three-item descriptor containing a pointer to the data (inside an array), the
length, and the capacity; until those items are initialized, the slice is <spanx style="verb">nil</spanx>.
For slices, maps, and channels, <spanx style="verb">make</spanx> initializes the internal data structure
and prepares the value for use.</t>
<t>For instance, <spanx style="verb">make([]int, 10, 100)</spanx> allocates an array of 100 ints and then
creates a slice structure with length 10 and a capacity of 100 pointing at the
first 10 elements of the array. In contrast, <spanx style="verb">new([]int)</spanx> returns a pointer to
a newly allocated, zeroed slice structure, that is, a pointer to a <spanx style="verb">nil</spanx> slice
value. These examples illustrate the difference between <spanx style="verb">new</spanx> and <spanx style="verb">make</spanx>.</t>

<figure><artwork type="go">var p *[]int = new([]int)       &lt;1&gt;
var v  []int = make([]int, 100) &lt;2&gt;

var p *[]int = new([]int)       &lt;3&gt;
*p = make([]int, 100, 100)

v := make([]int, 100)           &lt;4&gt;
</artwork></figure>

<t>Allocates <spanx style="emph">1</spanx> slice structure; rarely useful. <spanx style="verb">v</spanx> <spanx style="emph">2</spanx> refers to a new array of
100 ints. At <spanx style="emph">3</spanx> we make it unnecessarily complex, <spanx style="emph">4</spanx> is more idiomatic.</t>
<t>Remember that <spanx style="verb">make</spanx> applies only to maps, slices and channels and does not
return a pointer. To obtain an explicit pointer allocate with <spanx style="verb">new</spanx>.</t>
<t><spanx style="strong">new</spanx> allocates; <spanx style="strong">make</spanx> initializes.</t>
<t>The above two paragraphs can be summarized as:</t>
<t>
<list style="symbols">
<t><spanx style="verb">new(T)</spanx> returns <spanx style="verb">*T</spanx> pointing to a zeroed <spanx style="verb">T</spanx></t>
<t><spanx style="verb">make(T)</spanx> returns an initialized <spanx style="verb">T</spanx></t>
</list>
</t>
<t>And of course <spanx style="verb">make</spanx> is only used for slices, maps and channels.</t>
</section>

<section anchor="constructors-and-composite-literals" title="Constructors and composite literals">
<t>Sometimes the zero value isn't good enough and an initializing constructor is
necessary, as in this example taken from the package <spanx style="verb">os</spanx>.</t>

<figure><artwork type="go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</artwork></figure>

<t>There's a lot of boiler plate in there. We can simplify it using a
<spanx style="emph">composite literal</spanx> <iref item="literal" subitem="composite"/>, which is an expression that
 creates a new instance each time it is evaluated.</t>

<figure><artwork type="go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f	&lt;1&gt;
}
</artwork></figure>

<t>It is OK to return the address of a local variable <spanx style="emph">1</spanx> the storage associated
with the variable survives after the function returns.</t>
<t>In fact, taking the address of a composite literal allocates a fresh instance
each time it is evaluated, so we can combine these last two lines.</t>

<figure><artwork type="go">return &amp;File{fd, name, nil, 0}
</artwork></figure>

<t>The items (called fields) of a composite literal are laid out in order and must
all be present. However, by labeling the elements explicitly as field:value
pairs, the initializers can appear in any order, with the missing ones left as
their respective zero values. Thus we could say</t>

<figure><artwork type="go">return &amp;File{fd: fd, name: name}
</artwork></figure>

<t>As a limiting case, if a composite literal contains no fields at all, it creates
a zero value for the type. The expressions <spanx style="verb">new(File)</spanx> and <spanx style="verb">&amp;File{}</spanx> are
equivalent. In fact the use of <spanx style="verb">new</spanx> is discouraged.</t>
<t>Composite literals can also be created for arrays, slices, and maps, with the
field labels being indices or map keys as appropriate. In these examples, the
initializations work regardless of the values of <spanx style="verb">Enone</spanx>, and <spanx style="verb">Einval</spanx>, as long
as they are distinct:</t>

<figure><artwork type="go">ar := [...]string{Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
sl := []string{Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
ma := map[int]string {Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
</artwork></figure>

</section>
</section>

<section anchor="defining-your-own-types" title="Defining your own types">
<t>Of course Go allows you to define new types, it does this with the
<spanx style="verb">type</spanx><iref item="keywords" subitem="type"/> keyword: <spanx style="verb">type foo int</spanx></t>
<t>This creates a new type <spanx style="verb">foo</spanx> which acts like an <spanx style="verb">int</spanx>. Creating more sophisticated
types is done with the <spanx style="verb">struct</spanx> <iref item="keywords" subitem="struct"/> keyword. An example would
be when we want record somebody's name (<spanx style="verb">string</spanx>) and age (<spanx style="verb">int</spanx>) in a single
structure and make it a new type:</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

type NameAge struct {
	name string // Both non exported fields.
	age  int
}

func main() {
	a := new(NameAge)
	a.name = &quot;Pete&quot;
	a.age = 42
	fmt.Printf(&quot;%v\n&quot;, a)
}
</artwork></figure>

<t>Apropos, the output of <spanx style="verb">fmt.Printf(&quot;%v\n&quot;, a)</spanx> is <spanx style="verb">&amp;{Pete 42}</spanx></t>
<t>That is nice! Go knows how to print your structure. If you only want to print
one, or a few, fields of the structure you'll need to use <spanx style="verb">.&lt;field name&gt;</spanx>. For
example to only print the name:</t>

<figure><artwork type="go">fmt.Printf(&quot;%s&quot;, a.name)
</artwork></figure>


<section anchor="more-on-structure-fields" title="More on structure fields">
<t>As said each item in a structure is called a field<iref item="field"/>. A struct with no
fields: <spanx style="verb">struct {}</spanx>. Or one with four fields:</t>

<figure><artwork type="go">struct {
    x, y int
    A *[]int
    F func()
}
</artwork></figure>

<t>If you omit the name for a field, you create an anonymous field (((field,
anonymous))), for instance:</t>

<figure><artwork type="go">struct {
    T1        // Field name is T1.
    *T2       // Field name is T2.
    P.T3      // Field name is T3.
    x, y int  // Field names are x and y.
}
</artwork></figure>

<t>Note that field names that start with a capital letter are exported, i.e. can be
set or read from other packages. Field names that start with a lowercase are
private to the current package. The same goes for functions defined in packages,
see <xref target="packages"></xref> for the details.</t>
</section>

<section anchor="methods" title="Methods">
<t>If you create functions that work on your newly defined type, you can take two
routes:</t>
<t>
<list style="numbers">
<t>Create a function that takes the type as an argument.</t>
</list>
</t>

<figure><artwork type="go">func doSomething(n1 *NameAge, n2 int) { /* */ }
</artwork></figure>

<t>
<list style="numbers">
<t>Create a function that works on the type (see <spanx style="emph">receiver</spanx> in <xref target="functions"></xref>):</t>
</list>
</t>

<figure><artwork type="go">func (n1 *NameAge) doSomething(n2 int) { /* */ }
</artwork></figure>

<t>This is a method call, which can be used as:</t>

<figure><artwork type="go">var n *NameAge
n.doSomething(2)
</artwork></figure>

<t>Whether to use a function or method is entirely up to the programmer, but if you
want to satisfy an interface (see the next chapter) you must use methods. If no
such requirement exists it is a matter of taste whether to use functions or
methods.</t>
<t>But keep the following in mind, this is quoted from <xref target="go_spec"></xref>:</t>
<t>
<list style="empty">
<t>If <spanx style="verb">x</spanx> is
addressable and <spanx style="verb">&amp;x</spanx>'s method set contains <spanx style="verb">m</spanx>,
<spanx style="verb">x.m()</spanx> is shorthand for <spanx style="verb">(&amp;x).m()</spanx>.</t>
</list></t>
<t>In the above case this means that the following is <spanx style="emph">not</spanx> an error:</t>

<figure><artwork type="go">var n NameAge	    // Not a pointer
n.doSomething(2)
</artwork></figure>

<t>Here Go will search the method list for <spanx style="verb">n</spanx> of type <spanx style="verb">NameAge</spanx>, come up empty and
will then <spanx style="emph">also</spanx> search the method list for the type <spanx style="verb">*NameAge</spanx> and will
translate this call to <spanx style="verb">(&amp;n).doSomething(2)</spanx>.</t>
<t>There is a subtle but major difference between the following type declarations.
Also see the Section &quot;Type Declarations&quot; <xref target="go_spec"></xref>. Suppose we have:</t>

<figure><artwork type="go">// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock impl. */ }
func (m *Mutex) Unlock()  { /* Unlock impl. */ }
</artwork></figure>

<t>We now create two types in two different manners:</t>
<t>
<list style="symbols">
<t><spanx style="verb">type NewMutex Mutex</spanx>.</t>
<t><spanx style="verb">type PrintableMutex struct{Mutex}</spanx>.</t>
</list>
</t>
<t><spanx style="verb">NewMutex</spanx> is equal to <spanx style="verb">Mutex</spanx>, but it <spanx style="emph">does not</spanx> have <spanx style="emph">any</spanx> of the methods of
<spanx style="verb">Mutex</spanx>. In other words its method set is empty. But <spanx style="verb">PrintableMutex</spanx> <spanx style="emph">has</spanx>
<spanx style="emph">inherited</spanx> <iref item="methods" subitem="inherited"/> the method set from <spanx style="verb">Mutex</spanx>. The Go term
 for this is <spanx style="emph">embedding</spanx> <iref item="structures" subitem="embed"/>. In the words of <xref target="go_spec"></xref>:</t>
<t>
<list style="empty">
<t>The method set of <spanx style="verb">*PrintableMutex</spanx> contains the methods
<spanx style="verb">Lock</spanx> and <spanx style="verb">Unlock</spanx> bound to its anonymous field <spanx style="verb">Mutex</spanx>.</t>
</list></t>
</section>
</section>

<section anchor="conversions" title="Conversions">
<t>Sometimes you want to convert a type to another type. This is possible in Go,
but there are some rules. For starters, converting from one value to another is
done by operators (that look like functions: <spanx style="verb">byte()</spanx>) and not all conversions
are allowed.</t>
<texttable anchor="tab-conversion" title="Valid conversions, float64 works the same as float32.">
<ttcol>From</ttcol>
<ttcol><spanx style="verb">b []byte</spanx></ttcol>
<ttcol><spanx style="verb">i []int</spanx></ttcol>
<ttcol><spanx style="verb">r []rune</spanx></ttcol>
<ttcol><spanx style="verb">s string</spanx></ttcol>
<ttcol><spanx style="verb">f float32</spanx></ttcol>
<ttcol><spanx style="verb">i int</spanx></ttcol>


<c><spanx style="strong">To</spanx></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>

<c><spanx style="verb">[]byte</spanx></c>
<c>·</c>
<c></c>
<c></c>
<c><spanx style="verb">[]byte(s)</spanx></c>
<c></c>
<c></c>

<c><spanx style="verb">[]int</spanx></c>
<c></c>
<c>·</c>
<c></c>
<c><spanx style="verb">[]int(s)</spanx></c>
<c></c>
<c></c>

<c><spanx style="verb">[]rune</spanx></c>
<c></c>
<c></c>
<c></c>
<c><spanx style="verb">[]rune(s)</spanx></c>
<c></c>
<c></c>

<c><spanx style="verb">string</spanx></c>
<c><spanx style="verb">string(b)</spanx></c>
<c><spanx style="verb">string(i)</spanx></c>
<c><spanx style="verb">string(r)</spanx></c>
<c>·</c>
<c></c>
<c></c>

<c><spanx style="verb">float32</spanx></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>·</c>
<c><spanx style="verb">float32(i)</spanx></c>

<c><spanx style="verb">int</spanx></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c><spanx style="verb">int(f)</spanx></c>
<c>·</c>

</texttable><t>
<list style="symbols">
<t>From a <spanx style="verb">string</spanx> to a slice of bytes or runes.
<figure><artwork type="go">mystring := &quot;hello this is string&quot;
byteslice := []byte(mystring)
</artwork></figure>

<vspace />
Converts to a <spanx style="verb">byte</spanx> slice, each <spanx style="verb">byte</spanx> contains the integer value of the
corresponding byte in the string. Note that as strings in Go are encoded in
UTF-8 some characters in the string may end up in 1, 2, 3 or 4 bytes.
<figure><artwork type="go">runeslice  := []rune(mystring)
</artwork></figure>

<vspace />
Converts to an <spanx style="verb">rune</spanx> slice, each <spanx style="verb">rune</spanx> contains a Unicode code point.
Every character from the string corresponds to one rune.</t>
<t>From a slice of bytes or runes to a <spanx style="verb">string</spanx>.
<figure><artwork type="go">b := []byte{'h','e','l','l','o'} // Composite literal.
s := string(b)
i := []rune{257,1024,65}
r := string(i)
</artwork></figure>

</t>
</list>
</t>
<t>For numeric values the following conversions are defined:</t>
<t>
<list style="symbols">
<t>Convert to an integer with a specific (bit) length: <spanx style="verb">uint8(int)</spanx></t>
<t>From floating point to an integer value: <spanx style="verb">int(float32)</spanx>. This discards the
fraction part from the floating point value.</t>
<t>And the other way around: <spanx style="verb">float32(int)</spanx>.</t>
</list>
</t>

<section anchor="user-defined-types-and-conversions" title="User defined types and conversions">
<t>How can you convert between the types you have defined yourself? We create two
types here <spanx style="verb">Foo</spanx> and <spanx style="verb">Bar</spanx>, where <spanx style="verb">Bar</spanx> is an alias for <spanx style="verb">Foo</spanx>:</t>

<figure><artwork type="go">type foo struct { int }  // Anonymous struct field.
type bar foo             // bar is an alias for foo.
</artwork></figure>

<t>Then we:</t>

<figure><artwork type="go">var b bar = bar{1} // Declare `b` to be a `bar`.
var f foo = b	   // Assign `b` to `f`.
</artwork></figure>

<t>Which fails on the last line with:
<spanx style="verb">cannot use b (type bar) as type foo in assignment</spanx></t>
<t>This can be fixed with a conversion: <spanx style="verb">var f foo = foo(b)</spanx></t>
<t>Note that converting structures that are not identical in their fields is more
difficult. Also note that converting <spanx style="verb">b</spanx> to a plain <spanx style="verb">int</spanx> also fails; an integer
is not the same as a structure containing an integer.</t>
</section>
</section>

<section anchor="exercises-3" title="Exercises">

<section anchor="map-function-with-interfaces" title="Map function with interfaces">
<t>
<list style="numbers">
<t>Use the answer from the earlier map exercise but now
make it generic using interfaces. Make it at least work for
ints and strings.</t>
</list>
</t>
</section>

<section anchor="answer-14" title="Answer">
<t>
<list style="numbers">
<t></t>
</list>
</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

// Define the empty interface as a type.
type e interface{}

func mult2(f e) e {
	switch f.(type) {
	case int:
		return f.(int) * 2
	case string:
		return f.(string) + f.(string) + f.(string) + f.(string)
	}
	return f
}

func Map(n []e, f func(e) e) []e {
	m := make([]e, len(n))
	for k, v := range n {
		m[k] = f(v)
	}
	return m
}

func main() {
	m := []e{1, 2, 3, 4}
	s := []e{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
	mf := Map(m, mult2)
	sf := Map(s, mult2)
	fmt.Printf(&quot;%v\n&quot;, mf)
	fmt.Printf(&quot;%v\n&quot;, sf)
}
</artwork></figure>

</section>

<section anchor="pointers" title="Pointers">
<t>
<list style="numbers">
<t>Suppose we have defined the following structure:
<figure><artwork type="go">type Person struct {
    name string
    age	 int
}
</artwork></figure>

<vspace />
What is the difference between the following two lines?
<figure><artwork type="go">var p1 Person
p2 := new(Person)
</artwork></figure>

</t>
<t>What is the difference between the following two allocations?
<figure><artwork type="go">func Set(t *T) {
    x = t
}
</artwork></figure>

<vspace />
and
<figure><artwork type="go">func Set(t T) {
    x= &amp;t
}
</artwork></figure>

</t>
</list>
</t>
</section>

<section anchor="answer-15" title="Answer">
<t>
<list style="numbers">
<t>The expression, <spanx style="verb">var p1 Person</spanx> allocates a <spanx style="verb">Person</spanx>-<spanx style="emph">value</spanx> to <spanx style="verb">p1</spanx>. The type of <spanx style="verb">p1</spanx> is <spanx style="verb">Person</spanx>.
The second line: <spanx style="verb">p2 := new(Person)</spanx> allocates memory and assigns a <spanx style="emph">pointer</spanx> to <spanx style="verb">p2</spanx>. The type of <spanx style="verb">p2</spanx> is
<spanx style="verb">*Person</spanx>.</t>
<t>In the first function, <spanx style="verb">x</spanx> points to the same thing that <spanx style="verb">t</spanx> does, which is the same thing that the
actual argument points to. So in the second function, we have an &quot;extra&quot; variable containing a copy of the
interesting value. In the second function, <spanx style="verb">x</spanx> points to a new (heap-allocated) variable <spanx style="verb">t</spanx> which contains
a copy of whatever the actual argument value is.</t>
</list>
</t>
</section>

<section anchor="linked-list" title="Linked List">
<t>
<list style="numbers">
<t>Make use of the package <spanx style="verb">container/list</spanx> to create
a (doubly) linked list. Push the values 1, 2 and 4 to the list and then
print it.</t>
<t>Create your own linked list implementation. And perform the same actions
as above.</t>
</list>
</t>
</section>

<section anchor="answer-16" title="Answer">
<t>
<list style="numbers">
<t>The following is the implementation of a program using doubly
linked lists from <spanx style="verb">container/list</spanx>.</t>
</list>
</t>

<figure><artwork type="go">package main

import (
	&quot;container/list&quot;
	&quot;fmt&quot;
)

func main() {
	l := list.New()
	l.PushBack(1)
	l.PushBack(2)
	l.PushBack(4)

	for e := l.Front(); e != nil; e = e.Next() {
		fmt.Printf(&quot;%v\n&quot;, e.Value)
	}
}
</artwork></figure>

<t>
<list style="numbers">
<t>The following is a program implementing a simple doubly
linked list supporting <spanx style="verb">int</spanx> values.</t>
</list>
</t>

<figure><artwork type="go">package main

import (
	&quot;errors&quot; &lt;1&gt;
	&quot;fmt&quot;
)

type Value int &lt;2&gt;

type Node struct { &lt;3&gt;
	Value
	prev, next *Node
}

type List struct {
	head, tail *Node
}

func (l *List) Front() *Node { &lt;4&gt;
	return l.head
}

func (n *Node) Next() *Node {
	return n.next
}

func (l *List) Push(v Value) *List {
	n := &amp;Node{Value: v} &lt;5&gt;

	if l.head == nil { &lt;6&gt;
		l.head = n
	} else {
		l.tail.next = n &lt;7&gt;
		n.prev = l.tail &lt;8&gt;
	}
	l.tail = n &lt;9&gt;

	return l
}

var errEmpty = errors.New(&quot;List is empty&quot;)

func (l *List) Pop() (v Value, err error) {
	if l.tail == nil { &lt;10&gt;
		err = errEmpty
	} else {
		v = l.tail.Value     &lt;11&gt;
		l.tail = l.tail.prev &lt;12&gt;
		if l.tail == nil {
			l.head = nil &lt;13&gt;
		}
	}

	return v, err
}

func main() {
	l := new(List)

	l.Push(1)
	l.Push(2)
	l.Push(4)

	for n := l.Front(); n != nil; n = n.Next() {
		fmt.Printf(&quot;%v\n&quot;, n.Value)
	}

	fmt.Println()

	for v, err := l.Pop(); err == nil; v, err = l.Pop() {
		fmt.Printf(&quot;%v\n&quot;, v)
	}
}
</artwork></figure>

<t>Import &lt;<spanx style="emph">1</spanx>&gt; the packages we will need. At &lt;<spanx style="emph">2</spanx>&gt; we declare a type for the value our list will contain,
this is not strictly neccesary. And at &lt;<spanx style="emph">3</spanx>&gt; we declare a type for the each node in our list.
At &lt;<spanx style="emph">4</spanx>&gt; we define the <spanx style="verb">Front</spanx> method for our list.
When pushing, create a new Node &lt;<spanx style="emph">5</spanx>&gt; with the provided value. If the list is empty &lt;<spanx style="emph">6</spanx>&gt;,
put the new node at the head. Otherwise &lt;<spanx style="emph">7</spanx>&gt; put it at the tail and make sure &lt;<spanx style="emph">8</spanx>&gt;
the new node points back to the previously existing one. At &lt;<spanx style="emph">9</spanx>&gt; we re-adjust tail
to the newly inserted node.</t>
<t>In the Pop <spanx style="emph">10</spanx> method, we return an error if the list is empty. If it is not empty <spanx style="emph">11</spanx>
we save the last value. And then <spanx style="emph">12</spanx> discard the last node from the list. Finally at <spanx style="emph">13</spanx>
we make sure the list is consistent if it becomes empty.</t>
</section>

<section anchor="cat" title="Cat">
<t>
<list style="numbers">
<t>Write a program which mimics the Unix program <spanx style="verb">cat</spanx>.</t>
<t>Make it support the <spanx style="verb">-n</spanx> flag, where each line is numbered.</t>
<t>The solution to the above question given in contains a bug. Can you spot and fix it?</t>
</list>
</t>
</section>

<section anchor="answer-17" title="Answer">
<t>
<list style="numbers">
<t>The following is implemention of <spanx style="verb">cat</spanx> which also supports a -n flag to number each line.</t>
</list>
</t>

<figure><artwork type="go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot; &lt;1&gt;
	&quot;os&quot;
)

var numberFlag = flag.Bool(&quot;n&quot;, false, &quot;number each line&quot;) // &lt;&lt;2&gt;&gt;

func cat(r *bufio.Reader) { &lt;3&gt;
	i := 1
	for {
		buf, e := r.ReadBytes('\n') &lt;4&gt;
		if e == io.EOF {            &lt;5&gt;
			break
		}
		if *numberFlag { &lt;6&gt;
			fmt.Fprintf(os.Stdout, &quot;%5d  %s&quot;, i, buf)
			i++
		} else { &lt;7&gt;
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() == 0 {
		cat(bufio.NewReader(os.Stdin))
	}
	for i := 0; i &lt; flag.NArg(); i++ {
		f, e := os.Open(flag.Arg(i))
		if e != nil {
			fmt.Fprintf(os.Stderr, &quot;%s: error reading from %s: %s\n&quot;,
				os.Args[0], flag.Arg(i), e.Error())
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we include all the packages we need.
 Here <spanx style="emph">2</spanx> we define a new flag &quot;n&quot;, which defaults to off. Note that we get the help (-h) for free.
 Start the function <spanx style="emph">3</spanx> that actually reads the file's contents and displays it;
 Read one line at the time at <spanx style="emph">4</spanx>. And stop <spanx style="emph">5</spanx> if we hit the end.
 If we should number each line, print the line number and then the line itself <spanx style="emph">6</spanx>.
 Otherwise <spanx style="emph">7</spanx> we could just print the line.</t>
<t>
<list style="numbers">
<t>The bug show itself when the last line of the input does not
contain a newline. Or worse, when the input contains one line without a
closing newline nothing is shown at all. A better solution is the following
program.</t>
</list>
</t>

<figure><artwork type="go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

var numberFlag = flag.Bool(&quot;n&quot;, false, &quot;number each line&quot;)

func cat(r *bufio.Reader) {
	i := 1
	for {
		buf, e := r.ReadBytes('\n')
		if e == io.EOF &amp;&amp; string(buf) == &quot;&quot; {
			break
		}
		if *numberFlag {
			fmt.Fprintf(os.Stdout, &quot;%5d  %s&quot;, i, buf)
			i++
		} else {
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() == 0 {
		cat(bufio.NewReader(os.Stdin))
	}
	for i := 0; i &lt; flag.NArg(); i++ {
		f, e := os.Open(flag.Arg(i))
		if e != nil {
			fmt.Fprintf(os.Stderr, &quot;%s: error reading from %s: %s\n&quot;,
				os.Args[0], flag.Arg(i), e.Error())
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</artwork></figure>

</section>

<section anchor="method-calls" title="Method calls">
<t>
<list style="numbers">
<t>Suppose we have the following
program. Note the package <spanx style="verb">container/vector</spanx> was once part
of Go, but was removed when the <spanx style="verb">append</spanx> built-in was introduced.
However, for this question this isn't important. The package implemented
a stack-like structure, with push and pop methods.
<figure><artwork type="go">package main


import &quot;container/vector&quot;


func main() {
    k1 := vector.IntVector{}
    k2 := &amp;vector.IntVector{}
    k3 := new(vector.IntVector)
    k1.Push(2)
    k2.Push(3)
    k3.Push(4)
}
</artwork></figure>

<vspace />
What are the types of <spanx style="verb">k1</spanx>, <spanx style="verb">k2</spanx> and <spanx style="verb">k3</spanx>?</t>
<t>Now, this program compiles and runs OK. All the <spanx style="verb">Push</spanx>
operations work even though the variables are of a different type. The
documentation for <spanx style="verb">Push</spanx> says:<t>
<list style="empty">
<t><spanx style="verb">func (p *IntVector) Push(x int)</spanx>
Push appends x to the end of the vector.</t>
</list></t>
<vspace />
So the receiver has to be of type <spanx style="verb">*IntVector</spanx>, why does the code
above (the Push statements) work correctly then?</t>
</list>
</t>
</section>

<section anchor="answer-18" title="Answer">
<t>
<list style="numbers">
<t>The type of <spanx style="verb">k1</spanx> is <spanx style="verb">vector.IntVector</spanx>. Why? We use
a composite literal (the <spanx style="verb">{}</spanx>), so we get a value of that type
back. The variable <spanx style="verb">k2</spanx> is of <spanx style="verb">*vector.IntVector</spanx>, because we
take the address (<spanx style="verb">&amp;</spanx>) of the composite literal. And finally
<spanx style="verb">k3</spanx> has also the type <spanx style="verb">*vector.IntVector</spanx>, because <spanx style="verb">new</spanx>
returns a pointer to the type.</t>
<t>The answer is given in <xref target="go_spec"></xref> in the section &quot;Calls&quot;,
where among other things it says:</t>
</list>
</t>
<t>
<list style="empty">
<t>A method call <spanx style="verb">x.m()</spanx> is valid if the method set of (the type of)
<spanx style="verb">x</spanx>
contains <spanx style="verb">m</spanx> and the argument list can be assigned to the parameter list
of <spanx style="verb">m</spanx>. If <spanx style="verb">x</spanx> is addressable and <spanx style="verb">&amp;x</spanx>'s method set
contains <spanx style="verb">m</spanx>, <spanx style="verb">x.m()</spanx> is shorthand for <spanx style="verb">(&amp;x).m()</spanx>.</t>
</list></t>
<t>In other words because <spanx style="verb">k1</spanx> is addressable and
<spanx style="verb">*vector.IntVector</spanx> <spanx style="emph">does</spanx> have the <spanx style="verb">Push</spanx> method, the
call <spanx style="verb">k1.Push(2)</spanx> is translated by Go into
<spanx style="verb">(&amp;k1).Push(2)</spanx> which makes the type system happy again (and
you too -- now you know this).</t>
</section>
</section>
</section>

<section anchor="interfaces" title="Interfaces">
<t>
<list style="empty">
<t>I have this phobia about having my body penetrated surgically. You know what
I mean?</t>
<t>eXistenZ -- Ted Pikul
</t>
</list></t>
<t>In Go, the word <spanx style="emph">interface</spanx><iref item="interface"/> is overloaded to mean several
different things. Every type has an interface, which is the <spanx style="emph">set of methods
defined</spanx> for <iref item="interface" subitem="set of methods"/> that type. This bit of code defines
a struct type <spanx style="verb">S</spanx> with one field, and defines two methods for <spanx style="verb">S</spanx>. </t>
<figure title="Defining a struct and methods on it.
">
<artwork type="go">type S struct { i int }
func (p *S) Get() int  { return p.i }
func (p *S) Put(v int) { p.i = v }
</artwork>
</figure>
<t>You can also define an <iref item="interface" subitem="type"/>interface type, which is simply
a set of methods. This defines an interface <spanx style="verb">I</spanx> with two methods:</t>

<figure><artwork type="go">type I interface {
    Get() int
    Put(int)
}
</artwork></figure>

<t><spanx style="verb">S</spanx> is a valid <spanx style="emph">implementation</spanx> for interface <spanx style="verb">I</spanx>, because it defines the two
methods which <spanx style="verb">I</spanx> requires. Note that this is true even though there is no
explicit declaration that <spanx style="verb">S</spanx> implements <spanx style="verb">I</spanx>.</t>
<t>A Go program can use this fact via yet another meaning of interface, which is an
interface value: <iref item="interface" subitem="value"/></t>

<figure><artwork type="go">func f(p I) { &lt;1&gt;
    fmt.Println(p.Get()) &lt;2&gt;
    p.Put(1) &lt;3&gt;
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we declare a function that takes an interface type as the argument.
Because <spanx style="verb">p</spanx> implements <spanx style="verb">I</spanx>, it <spanx style="emph">must</spanx> have the <spanx style="verb">Get()</spanx> method, which we call at
<spanx style="emph">2</spanx>. And the same holds true for the <spanx style="verb">Put()</spanx> method at <spanx style="emph">3</spanx>. Because <spanx style="verb">S</spanx>
implements <spanx style="verb">I</spanx>, we can call the function <spanx style="verb">f</spanx> passing in a pointer to a value of
type <spanx style="verb">S</spanx>: <spanx style="verb">var s S; f(&amp;s)</spanx></t>
<t>The reason we need to take the address of <spanx style="verb">s</spanx>, rather than a value of type <spanx style="verb">S</spanx>,
is because we defined the methods on <spanx style="verb">s</spanx> to operate on pointers, see the
definition in the code above. This is not a requirement -- we could have defined
the methods to take values -- but then the <spanx style="verb">Put</spanx> method would not work as
expected.</t>
<t>The fact that you do not need to declare whether or not a type implements an
interface means that Go implements a form of duck typing <iref item="duck" subitem="typing"/>
<xref target="duck_typing"></xref>. This is not pure duck typing, because when possible the
Go compiler will statically check whether the type implements the interface.
However, Go does have a purely dynamic aspect, in that you can convert from one
interface type to another. In the general case, that conversion is checked at
run time. If the conversion is invalid -- if the type of the value stored in
the existing interface value does not satisfy the interface to which it is being
converted -- the program will fail with a run time error.</t>
<t>Interfaces in Go are similar to ideas in several other programming languages:
pure abstract virtual base classes in C++, typeclasses in Haskell or duck typing
in Python. However there is no other language which combines interface values,
static type checking, dynamic run time conversion, and no requirement for
explicitly declaring that a type satisfies an interface. The result in Go is
powerful, flexible, efficient, and easy to write.</t>

<section anchor="which-is-what" title="Which is what?">
<t>Let's define another type <spanx style="verb">R</spanx> that also implements the interface <spanx style="verb">I</spanx>:</t>

<figure><artwork type="go">type R struct { i int }
func (p *R) Get() int  { return p.i }
func (p *R) Put(v int) { p.i = v }
</artwork></figure>

<t>The function <spanx style="verb">f</spanx> can now accept variables of type <spanx style="verb">R</spanx> and <spanx style="verb">S</spanx>.</t>
<t>Suppose you need to know the actual type in the function <spanx style="verb">f</spanx>. In Go you can
figure that out by using a type switch<iref item="type switch"/>.</t>

<figure><artwork type="go">func f(p I) {
    switch t := p.(type) { &lt;1&gt;
        case *S: &lt;2&gt;
        case *R: &lt;2&gt;
        default: &lt;3&gt;
    }
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we use the type switch, note that the <spanx style="verb">.(type)</spanx> syntax is <spanx style="emph">only</spanx> valid
within a <spanx style="verb">switch</spanx> statement. We store the value in the variable <spanx style="verb">t</spanx>. The
subsequent cases <spanx style="emph">2</spanx> each check for a different <spanx style="emph">actual</spanx> type. And we can even
have a <spanx style="verb">default</spanx> <spanx style="emph">3</spanx> clause. It is worth pointing out that both <spanx style="verb">case R</spanx> and
<spanx style="verb">case s</spanx> aren't possible, because <spanx style="verb">p</spanx> needs to be a pointer in order to satisfy
<spanx style="verb">i</spanx>.</t>
<t>A type switch isn't the only way to discover the type at <spanx style="emph">run-time</spanx>.</t>

<figure><artwork type="go">if t, ok := something.(I); ok { &lt;1&gt;
    // ...
}
</artwork></figure>

<t>You can also use a &quot;comma, ok&quot; form <spanx style="emph">1</spanx> to see if an interface type implements
a specific interface. If <spanx style="verb">ok</spanx> is true, <spanx style="verb">t</spanx> will hold the type of <spanx style="verb">something</spanx>.
When you are sure a variable implements an interface you can use: <spanx style="verb">t := something.(I)</spanx> .</t>
</section>

<section anchor="empty-interface" title="Empty interface">
<t>Since every type satisfies the empty interface: <spanx style="verb">interface{}</spanx> we can create
a generic function which has an empty interface as its argument:</t>

<figure><artwork type="go">func g(something interface{}) int {
    return something.(I).Get()
}
</artwork></figure>

<t>The <spanx style="verb">return something.(I).Get()</spanx> is the tricky bit in this function. The value
<spanx style="verb">something</spanx> has type <spanx style="verb">interface{}</spanx>, meaning no guarantee of any methods at all:
it could contain any type. The <spanx style="verb">.(I)</spanx> is a type assertion <iref item="type assertion"/>
which converts <spanx style="verb">something</spanx> to an interface of type <spanx style="verb">I</spanx>. If we have that type we
can invoke the <spanx style="verb">Get()</spanx> function. So if we create a new variable of the type
<spanx style="verb">*S</spanx>, we can just call <spanx style="verb">g()</spanx>, because <spanx style="verb">*S</spanx> also implements the empty interface.</t>

<figure><artwork type="go">s = new(S)
fmt.Println(g(s));
</artwork></figure>

<t>The call to <spanx style="verb">g</spanx> will work fine and will print 0. If we however invoke <spanx style="verb">g()</spanx> with
a value that does not implement <spanx style="verb">I</spanx> we have a problem:</t>

<figure><artwork type="go">var i int
fmt.Println(g(i))
</artwork></figure>

<t>This compiles, but when we run this we get slammed with: &quot;panic: interface
conversion: int is not main.I: missing method Get&quot;.</t>
<t>Which is completely true, the built-in type <spanx style="verb">int</spanx> does not have a <spanx style="verb">Get()</spanx>
method.</t>
</section>

<section anchor="methods-1" title="Methods">
<t>Methods are functions that have a receiver (see <xref target="functions"></xref>).
You can define methods on any type (except on non-local types, this includes
built-in types: the type <spanx style="verb">int</spanx> can not have methods).
You can however make a new integer type with its own methods. For example:</t>

<figure><artwork type="go">type Foo int

func (self Foo) Emit() {
    fmt.Printf(&quot;%v&quot;, self)
}

type Emitter interface {
    Emit()
}
</artwork></figure>

<t>Doing this on non-local (types defined in other packages) types yields an error
&quot;cannot define new methods on non-local type int&quot;.</t>
</section>

<section anchor="methods-on-interface-types" title="Methods on interface types">
<t>An interface defines a set of methods. A method contains the actual code. In
other words, an interface is the definition and the methods are the
implementation. So a receiver can not be an interface type, doing so results in
a &quot;invalid receiver type ...&quot; compiler error. The authoritative word from the
language spec <xref target="go_spec"></xref>:</t>
<t>
<list style="empty">
<t>The receiver type must be of the form <spanx style="verb">T</spanx> or <spanx style="verb">*T</spanx> where <spanx style="verb">T</spanx> is a type name. <spanx style="verb">T</spanx>
is called the receiver base type or just base type. The base type must not be
a pointer or interface type and must be declared in the same package as the
method.</t>
</list></t>
<t>Creating a pointer to an interface value is a useless action in Go. It is in
fact illegal to create a pointer to an interface value. The release notes for an
earlier Go release that made them illegal leave no room for doubt:</t>
<t>
<list style="empty">
<t>The language change is that uses of pointers to interface values no longer
automatically de-reference the pointer.  A pointer to an interface value is
more often a beginner's bug than correct code.</t>
</list></t>
</section>

<section anchor="interface-names" title="Interface names">
<t>By convention, one-method interfaces are named by the method name plus the <spanx style="emph">-er</spanx>
suffix: Read<spanx style="emph">er</spanx>, Writ<spanx style="emph">er</spanx>, Formatt<spanx style="emph">er</spanx> etc.</t>
<t>There are a number of such names and it's productive to honor them and the
function names they capture. <spanx style="verb">Read</spanx>, <spanx style="verb">Write</spanx>, <spanx style="verb">Close</spanx>, <spanx style="verb">Flush</spanx>, <spanx style="verb">String</spanx> and so
on have canonical signatures and meanings. To avoid confusion, don't give your
method one of those names unless it has the same signature and meaning.
Conversely, if your type implements a method with the same meaning as a method
on a well-known type, give it the same name and signature; call your
string-converter method <spanx style="verb">String</spanx> not <spanx style="verb">ToString</spanx>. </t>
</section>

<section anchor="a-sorting-example" title="A sorting example">
<t>Recall the Bubblesort exercise, where we sorted an array of integers:</t>

<figure><artwork type="go">func bubblesort(n []int) {
    for i := 0; i &lt; len(n)-1; i++ {
        for j := i + 1; j &lt; len(n); j++ {
            if n[j] &lt; n[i] {
                n[i], n[j] = n[j], n[i]
            }
        }
    }
}
</artwork></figure>

<t>A version that sorts strings is identical except for the signature of the
function: <spanx style="verb">func bubblesortString(n []string) { /* ... */ }</spanx> . Using this
approach would lead to two functions, one for each type. By using interfaces we
can make this more <iref item="generic"/> generic. Let's create a new function that will
sort both strings and integers, something along the lines of this non-working
example:</t>

<figure><artwork type="go">func sort(i []interface{}) {  &lt;1&gt;
    switch i.(type) {         &lt;2&gt;
    case string:              &lt;3&gt;
        // ...
    case int:
        // ...
    }
    return /* ... */          &lt;4&gt;
}
</artwork></figure>

<t>Our function will receive a slice of empty interfaces at <spanx style="emph">1</spanx>. We then <spanx style="emph">2</spanx> use a
type switch to find out what the actual type of the input is. And then <spanx style="emph">3</spanx>
then sort accordingly. And, when done, return <spanx style="emph">4</spanx> the sorted slice.</t>
<t>But when we call this function with <spanx style="verb">sort([]int{1, 4, 5})</spanx>, it fails with:
&quot;cannot use i (type []int) as type []interface { } in function argument&quot;</t>
<t>This is because Go can not easily convert to a <spanx style="emph">slice</spanx> of interfaces.
Just converting to an interface is easy, but to a slice is much more costly.
The full mailing list discussion on this subject can be found at
<xref target="go_nuts_interfaces"></xref>. To keep a long story short: Go does not (implicitly) convert slices for you.</t>
<t>So what is the Go way of creating such a &quot;generic&quot; function?
Instead of doing the type inference ourselves with a type switch, we let
Go do it implicitly:
The following steps are required:</t>
<t>
<list style="symbols">
<t>Define an interface type (called <spanx style="verb">Sorter</spanx> here) with a number of methods
needed for sorting. We will at least need a function to get the length of the
slice, a function to compare two values and a swap function.
<figure><artwork type="go">type Sorter interface {
    Len() int           // len() as a method.
    Less(i, j int) bool // p[j] &lt; p[i] as a method.
    Swap(i, j int)      // p[i], p[j] = p[j], p[i] as a method.
}
</artwork></figure>

</t>
<t>Define new types for the slices we want to sort. Note that we declare slice types:
<figure><artwork type="go">type Xi []int
type Xs []string
</artwork></figure>

</t>
<t>Implementation of the methods of the <spanx style="verb">Sorter</spanx> interface.
For integers:
<figure><artwork type="go">func (p Xi) Len() int               {return len(p)}
func (p Xi) Less(i int, j int) bool {return p[j] &lt; p[i]}
func (p Xi) Swap(i int, j int)      {p[i], p[j] = p[j], p[i]}
</artwork></figure>

<vspace />
And for strings:
<figure><artwork type="go">func (p Xs) Len() int               {return len(p)}
func (p Xs) Less(i int, j int) bool {return p[j] &lt; p[i]}
func (p Xs) Swap(i int, j int)      {p[i], p[j] = p[j], p[i]}
</artwork></figure>

</t>
<t>Write a <spanx style="emph">generic</spanx> Sort function that works on the <spanx style="verb">Sorter</spanx> interface.
<figure><artwork type="go">func Sort(x Sorter) { &lt;1&gt;
    for i := 0; i &lt; x.Len() - 1; i++ { &lt;2&gt;
        for j := i + 1; j &lt; x.Len(); j++ {
            if x.Less(i, j) {
                x.Swap(i, j)
            }
        }
    }
}
</artwork></figure>

<vspace />
At <spanx style="emph">1</spanx> <spanx style="verb">x</spanx> is now of the <spanx style="verb">Sorter</spanx> type and using the defined methods for this interface we implement
Bubblesort at <spanx style="emph">2</spanx>.<vspace />
Now we can use our <spanx style="emph">generic</spanx> <spanx style="verb">Sort</spanx> function as follows:
<figure><artwork type="go">ints := Xi{44, 67, 3, 17, 89, 10, 73, 9, 14, 8}
strings := Xs{&quot;nut&quot;, &quot;ape&quot;, &quot;elephant&quot;, &quot;zoo&quot;, &quot;go&quot;}


Sort(ints)
fmt.Printf(&quot;%v\n&quot;, ints)
Sort(strings)
fmt.Printf(&quot;%v\n&quot;, strings)
</artwork></figure>

</t>
</list>
</t>
</section>

<section anchor="listing-interfaces-in-interfaces" title="Listing interfaces in interfaces">
<t>Take a look at the following example of an interface definition, this one is
from the package <spanx style="verb">container/heap</spanx>:</t>

<figure><artwork type="go">type Interface interface {
    sort.Interface
    Push(x interface{})
    Pop() interface{}
}
</artwork></figure>

<t>Here another interface is listed inside the definition of <spanx style="verb">heap.Interface</spanx>, this
may look odd, but is perfectly valid, remember that on the surface an interface is nothing
more than a listing of methods. <spanx style="verb">sort.Interface</spanx> is also such a listing, so it is
perfectly legal to include it in the interface.</t>
</section>

<section anchor="introspection-and-reflection" title="Introspection and reflection">
<t>In the following example we want to look at the &quot;tag&quot; (here named &quot;namestr&quot;)
defined in the type definition of <spanx style="verb">Person</spanx>. To do this we need the
<spanx style="verb">reflect</spanx><iref item="package" subitem="reflect"/> package (there is no other way in Go). Keep in
mind that looking at a tag means going back to the <spanx style="emph">type</spanx> definition. So we use
the <spanx style="verb">reflect</spanx> package to figure out the type of the variable and <spanx style="emph">then</spanx> access
the tag.</t>
<figure title="Introspection using reflection.
">
<artwork type="go">type Person struct {
    name string &quot;namestr&quot;
    age  int
}

func ShowTag(i interface{}) { &lt;1&gt;
    switch t := reflect.TypeOf(i); t.Kind() {
    case reflect.Ptr: &lt;2&gt;
        tag := t.Elem().Field(0).Tag
    //             &lt;&lt;3&gt;&gt;     &lt;&lt;4&gt;&gt;       &lt;&lt;5&gt;&gt;
</artwork>
</figure>
<t>We are calling <spanx style="verb">ShowTag</spanx> at <spanx style="emph">1</spanx> with a <spanx style="verb">*Person</spanx>, so at <spanx style="emph">2</spanx> we're expecting
a <spanx style="verb">reflect.Ptr</spanx>. We are dealing with a <spanx style="verb">Type</spanx> <spanx style="emph">3</spanx> and according to the
documentation :</t>
<t>
<list style="empty">
<t>Elem returns a type's element type.
It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.</t>
</list></t>
<t>So on <spanx style="verb">t</spanx> we use <spanx style="verb">Elem()</spanx> to get the value the pointer points to. We have now
dereferenced the pointer and are &quot;inside&quot; our structure. We then <spanx style="emph">4</spanx> use
<spanx style="verb">Field(0)</spanx> to access the zeroth field.</t>
<t>The struct <spanx style="verb">StructField</spanx> has a <spanx style="verb">Tag</spanx> member which returns the tag-name as
a string. So on the <spanx style="verb">0^{th}</spanx> field we can unleash <spanx style="verb">.Tag</spanx> <spanx style="emph">5</spanx> to access this
name: <spanx style="verb">Field(0).Tag</spanx>. This gives us <spanx style="verb">namestr</spanx>.</t>
<t>To make the difference between types and values more clear, take a look at the
following code:</t>
<figure title="Reflection and the type and value.
">
<artwork type="go">func show(i interface{}) {
    switch t := i.(type) {
    case *Person:
        t := reflect.TypeOf(i)  &lt;1&gt;
        v := reflect.ValueOf(i) &lt;2&gt;
        tag := t.Elem().Field(0).Tag &lt;3&gt;
        name := v.Elem().Field(0).String() &lt;4&gt;
    }
}
</artwork>
</figure>
<t>At <spanx style="emph">1</spanx> we create <spanx style="verb">t</spanx> the type data of <spanx style="verb">i</spanx>, and <spanx style="verb">v</spanx> gets the actual values at
<spanx style="emph">2</spanx>. Here at <spanx style="emph">3</spanx> we want to get to the &quot;tag&quot;. So we need <spanx style="verb">Elem()</spanx> to redirect
the pointer, access the first field and get the tag. Note that we operate on <spanx style="verb">t</spanx>
a <spanx style="verb">reflect.Type</spanx>. Now <spanx style="emph">4</spanx> we want to get access to the <spanx style="emph">value</spanx> of one of the
members and we employ <spanx style="verb">Elem()</spanx> on <spanx style="verb">v</spanx> to do the redirection. we have &quot;arrived&quot;
at the structure. Then we go to the first field <spanx style="verb">Field(0)</spanx> and invoke the
<spanx style="verb">String()</spanx> method on it.</t>
<figure title="Peeling away the layers using reflection. Going from a *Person via Elem using the
methods described in go doc reflect to get the actual string contained within.&quot;)
"></figure>
<t>Setting a value works similarly as getting a value, but only works on
<spanx style="emph">exported</spanx> members. Again some code:</t>
<figure title="Reflect with private member.
">
<artwork type="go">type Person struct {
    name string
    age  int
}

func Set(i interface{}) {
    switch i.(type) {
    case *Person:
        r := reflect.ValueOf(i)
        r.Elem(0).Field(0).SetString(&quot;Albert Einstein&quot;)
    }
}
</artwork>
</figure>
<figure title="Reflect with public member.
">
<artwork type="go">type Person struct {
    Name string
    age  int
}

func Set(i interface{}) {
    switch i.(type) {
    case *Person:
        r := reflect.ValueOf(i)
        r.Elem().Field(0).SetString(&quot;Albert Einstein&quot;)
    }
}
</artwork>
</figure>
<t>The first program compiles and runs, but when you run it, you are greeted with a
stack trace and a <spanx style="emph">run time</spanx> error:
&quot;panic: reflect.Value.SetString using value obtained using unexported field&quot;.</t>
<t>The second program works OK and sets the member <spanx style="verb">Name</spanx> to &quot;Albert Einstein&quot;.
Of course this only works when you call <spanx style="verb">Set()</spanx> with a pointer argument.</t>
</section>

<section anchor="exercises-4" title="Exercises">
<t>### Interfaces and max()</t>
<t>In the maximum exercise we created a max function that works on a slice of
integers.  The question now is to create a program that shows the maximum number
and that works for both integers and floats.  Try to make your program as
generic as possible, although that is quite difficult in this case.</t>

<section anchor="answer-19" title="Answer">
<t>The following program calculates a maximum. It is as generic as you can get with
Go.</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

func Less(l, r interface{}) bool { &lt;1&gt;
    switch l.(type) {
    case int:
        if _, ok := r.(int); ok {
            return l.(int) &lt; r.(int) &lt;2&gt;
        }
    case float32:
        if _, ok := r.(float32); ok {
            return l.(float32) &lt; r.(float32) &lt;3&gt;
        }
    }
    return false
}

func main() {
    var a, b, c int = 5, 15, 0
    var x, y, z float32 = 5.4, 29.3, 0.0

    if c = a; Less(a, b) { &lt;4&gt;
        c = b
    }
    if z = x; Less(x, y) { &lt;4&gt;
        z = y
    }
    fmt.Println(c, z)
}
</artwork></figure>

<t>We could have chosen to make the return type of this <spanx style="emph">1</spanx> function an
<spanx style="verb">interface{}</spanx>, but that would mean that a caller would always have to do a type
assertion to extract the actual type from the interface. At <spanx style="emph">2</spanx> we compare the
parameters. All parameters are confirmed to be integers, so this is legit. And
at <spanx style="emph">3</spanx> we do the some for floats. At <spanx style="emph">4</spanx> we get the maximum value for <spanx style="verb">a</spanx>, <spanx style="verb">b</spanx>
and <spanx style="verb">x</spanx> and <spanx style="verb">y</spanx>.</t>
</section>

<section anchor="pointers-and-reflection" title="Pointers and reflection">
<t>One of the last paragraphs in section <xref target="introspection-and-reflection"></xref>
has the following words:</t>
<t>
<list style="empty">
<t>The code on the right works OK and sets the member <spanx style="verb">Name</spanx>
to &quot;Albert Einstein&quot;. Of course this only works when you call <spanx style="verb">Set()</spanx>
with a pointer argument.</t>
</list></t>
<t>Why is this the case?</t>
</section>

<section anchor="answer-20" title="Answer">
<t>When called with a non-pointer argument the variable is a copy (call-by-value).
So you are doing the reflection voodoo on a copy. And thus you are <spanx style="emph">not</spanx>
changing the original value, but only this copy.</t>
</section>
</section>
</section>

<section anchor="concurrency" title="Concurrency">
<t>
<list style="empty">
<t>
<list style="symbols">
<t>Parallelism is about performance.</t>
<t>Concurrency is about program design.</t>
</list></t>
<t>Google I/O 2010 -- Rob Pike
</t>
</list></t>
<t>In this chapter we will show off Go's ability for concurrent programming using
channels and goroutines. Goroutines are the central entity in Go's ability for
concurrency.</t>
<t>But what <spanx style="emph">is</spanx> a goroutine, from <xref target="effective_go"></xref>:</t>
<t>
<list style="empty">
<t>They're called goroutines because the existing terms -- threads, coroutines,
processes, and so on -- convey inaccurate connotations. A goroutine has a simple
model: <spanx style="emph">it is a function executing in parallel with other goroutines in the same
address space</spanx>. It is lightweight, costing little more than the allocation of
stack space. And the stacks start small, so they are cheap, and grow by
allocating (and freeing) heap storage as required.</t>
</list></t>
<t>A goroutine <iref item="goroutine"/> is a normal function, except that you start
it with the keyword <spanx style="verb">go</spanx>. <iref item="keywords" subitem="go"/></t>

<figure><artwork type="go">ready(&quot;Tea&quot;, 2)	    // Normal function call.
go ready(&quot;Tea&quot;, 2)  // ... as goroutine.
</artwork></figure>


<figure><artwork type="go">func ready(w string, sec int) {
	time.Sleep(time.Duration(sec) * time.Second)
	fmt.Println(w, &quot;is ready!&quot;)
}

func main() {
	go ready(&quot;Tea&quot;, 2)    //&lt;1&gt;
	go ready(&quot;Coffee&quot;, 1) //&lt;1&gt;
	fmt.Println(&quot;I'm waiting&quot;)
	time.Sleep(5 * time.Second) //&lt;2&gt;
</artwork></figure>

<t>Figure: Go routines in action.</t>
<t>The following idea for a program was taken from <xref target="go_course_day3"></xref>. We run
a function as two goroutines, the goroutines wait for an amount of time and then
print something to the screen. At <spanx style="emph">1</spanx> we start the goroutines. The <spanx style="verb">main</spanx>
function waits long enough at <spanx style="emph">2</spanx>, so that both goroutines will have printed
their text. Right now we wait for 5 seconds, but in fact we have no idea how
long we should wait until all goroutines have exited. This outputs:</t>

<figure><artwork type="go">I'm waiting         // Right away
Coffee is ready!    // After 1 second
Tea is ready!       // After 2 seconds
</artwork></figure>

<t>If we did not wait for the goroutines (i.e. remove the last line at <spanx style="emph">2</spanx>) the
program would be terminated immediately and any running goroutines would
<spanx style="emph">die with it</spanx>.</t>
<t>To fix this we need some kind of mechanism which allows us to
communicate with the goroutines. This mechanism is available to us in the form
of channels <iref item="channels"/>. A channel can be compared to a two-way pipe in Unix
shells: you can send to and receive values from it. Those values can only be of
a specific type: the type of the channel. If we define a channel, we must also
define the type of the values we can send on the channel. Note that we must use
<spanx style="verb">make</spanx> to create a channel:</t>

<figure><artwork type="go">ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
</artwork></figure>

<t>Makes <spanx style="verb">ci</spanx> a channel on which we can send and receive integers,
makes <spanx style="verb">cs</spanx> a channel for strings and <spanx style="verb">cf</spanx> a channel for types
that satisfy the empty interface.
Sending on a channel and receiving from it, is done with the same operator:
<spanx style="verb">&lt;-</spanx>. <iref item="operators" subitem="channel"/></t>
<t>Depending on the operands it figures out what to do:</t>

<figure><artwork type="go">ci &lt;- 1   // *Send* the integer 1 to the channel ci.
&lt;-ci      // *Receive* an integer from the channel ci.
i := &lt;-ci // *Receive* from the channel ci and store it in i.
</artwork></figure>

<t>Let's put this to use.</t>

<figure><artwork type="go">var c chan int &lt;1&gt;

func ready(w string, sec int) {
    time.Sleep(time.Duration(sec) * time.Second)
    fmt.Println(w, &quot;is ready!&quot;)
    c &lt;- 1	&lt;2&gt;
}

func main() {
    c = make(chan int) &lt;3&gt;
    go ready(&quot;Tea&quot;, 2) &lt;4&gt;
    go ready(&quot;Coffee&quot;, 1) &lt;4&gt;
    fmt.Println(&quot;I'm waiting, but not too long&quot;)
    &lt;-c &lt;5&gt;
    &lt;-c &lt;5&gt;
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we declare <spanx style="verb">c</spanx> to be a variable that is a channel of ints. That is: this
channel can move integers. Note that this variable is global so that the
goroutines have access to it. At <spanx style="emph">2</spanx> in the <spanx style="verb">ready</spanx> function we send the integer
1 on the channel. In our <spanx style="verb">main</spanx> function we initialize <spanx style="verb">c</spanx> at <spanx style="emph">3</spanx> and start our
goroutines <spanx style="emph">4</spanx>. At <spanx style="emph">5</spanx> we Wait until we receive a value from the channel, the
value we receive is discarded. We have started two goroutines, so we expect two
values to receive.</t>
<t>There is still some remaining ugliness; we have to read twice from the channel
<spanx style="emph">5</spanx>). This is OK in this case, but what if we don't know how many goroutines we
started? This is where another Go built-in comes in: <spanx style="verb">select</spanx> (((keywords,
select))). With <spanx style="verb">select</spanx> you can (among other things) listen for incoming data
on a channel.</t>
<t>Using <spanx style="verb">select</spanx> in our program does not really make it shorter, because we run
too few go-routines. We remove last lines and replace them with the following:</t>

<figure><artwork type="go">L: for {
    select {
    case &lt;-c:
        i++
        if i &gt; 1 {
            break L
        }
    }
}
</artwork></figure>

<t>We will now wait as long as it takes. Only when we have received more than one
reply on the channel <spanx style="verb">c</spanx> will we exit the loop <spanx style="verb">L</spanx>.</t>

<section anchor="make-it-run-in-parallel" title="Make it run in parallel">
<t>While our goroutines were running concurrently, they were not running in
parallel. When you do not tell Go anything there can only be one goroutine
running at a time. With <spanx style="verb">runtime.GOMAXPROCS(n)</spanx> you can set the number of
goroutines that can run in parallel. From the documentation:</t>
<t>
<list style="empty">
<t>GOMAXPROCS sets the maximum number of CPUs that can be executing
simultaneously and returns the previous setting. If n &lt; 1, it does not
change the current setting. <spanx style="emph">This call will go away when the scheduler
improves.</spanx></t>
</list></t>
<t>If you do not want to change any source code you can also set an environment
variable <spanx style="verb">GOMAXPROCS</spanx> to the desired value.</t>
<t>Note that the above discussion relates to older versions of Go. From
version 1.5 and above, <spanx style="verb">GOMAXPROCS</spanx> defaults to the number of CPU
cores<xref target="go_1_5_release_notes"></xref>.</t>
</section>

<section anchor="more-on-channels" title="More on channels">
<t>When you create a channel in Go with <spanx style="verb">ch := make(chan bool)</spanx>, an unbuffered
channel <iref item="channel" subitem="unbuffered"/> for bools is created. What does this mean for
your program? For one, if you read (<spanx style="verb">value := &lt;-ch</spanx>) it will block until there
is data to receive. Secondly anything sending (<spanx style="verb">ch &lt;- true</spanx>) will block until there
is somebody to read it. Unbuffered channels make a perfect tool for
synchronizing multiple goroutines. <iref item="channel" subitem="blocking read"/> <iref item="channel" subitem="blocking write"/></t>
<t>But Go allows you to specify the buffer size of a channel, which is quite simply
how many elements a channel can hold. <spanx style="verb">ch := make(chan bool, 4)</spanx>, creates
a buffered channel of bools that can hold 4 elements. The first 4 elements in
this channel are written without any blocking. When you write the 5^(th)</t>
<t>In conclusion, the following is true in Go:</t>
<figure><artwork type="math">

\textsf{ch := make(chan type, value)}
\left\{
\begin{array}{ll}
value == 0 &amp; \rightarrow \textsf{unbuffered} \\
value &gt;  0 &amp; \rightarrow \textsf{buffer }{} value{} \textsf{ elements}
\end{array}
\right.
</artwork></figure>

<figure><artwork type="math">

\textsf{ch := make(chan type, value)}
\left\{
\begin{array}{ll}
value == 0 &amp; \rightarrow \textsf{unbuffered} \\
value &gt;  0 &amp; \rightarrow \textsf{buffer }{} value{} \textsf{ elements}
\end{array}
\right.
</artwork></figure>

<t>When a channel is closed the reading side needs to know this. The following code
will check if a channel is closed.</t>

<figure><artwork type="go">x, ok = &lt;-ch
</artwork></figure>

<t>Where <spanx style="verb">ok</spanx> is set to <spanx style="verb">true</spanx> the channel is not closed
<spanx style="emph">and</spanx> we've read something. Otherwise <spanx style="verb">ok</spanx> is set to <spanx style="verb">false</spanx>. In that case the
channel was closed and the value received is a zero value of the
channel's type.</t>
</section>

<section anchor="exercises-5" title="Exercises">

<section anchor="channels" title="Channels">
<t>
<list style="numbers">
<t>Modify the program you created in exercise <xref target="for-loop"></xref> to use
channels, in other words, the function called in the body should now be
a goroutine and communication should happen via channels. You should not
worry yourself on how the goroutine terminates.</t>
<t>There are a few annoying issues left if you resolve question 1 above. One of
the problems is that the goroutine isn't neatly cleaned up when <spanx style="verb">main.main()</spanx>
exits. And worse, due to a race condition between the exit of <spanx style="verb">main.main()</spanx>
and <spanx style="verb">main.shower()</spanx> not all numbers are printed. It should print up until 9,
but sometimes it prints only to 8. Adding a second quit-channel you can
remedy both issues. Do this.</t>
</list>
</t>
</section>

<section anchor="answer-21" title="Answer">
<t>
<list style="numbers">
<t>A possible program is:</t>
</list>
</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

func main() {
	ch := make(chan int)
	go shower(ch)
	for i := 0; i &lt; 10; i++ {
		ch &lt;- i
	}
}

func shower(c chan int) {
	for {
		j := &lt;-c
		fmt.Printf(&quot;%d\n&quot;, j)
	}
}
</artwork></figure>

<t>We start in the usual way, then at line 6 we create a new channel of
   ints. In the next line we fire off the function <spanx style="verb">shower</spanx> with
   the <spanx style="verb">ch</spanx> variable as it argument, so that we may communicate with
   it. Next we start our for-loop (lines 8-10) and in the loop
   we send (with <spanx style="verb">&lt;-</spanx>) our number to the function (now a goroutine) <spanx style="verb">shower</spanx>.</t>
<t>In the function <spanx style="verb">shower</spanx> we wait (as this blocks) until we receive a number
   (line 15). Any received number is printed (line 16) and then continue the
   endless loop started on line 14.</t>
<t>
<list style="numbers">
<t>An answer is</t>
</list>
</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

func main() {
	ch := make(chan int)
	quit := make(chan bool)
	go shower(ch, quit)
	for i := 0; i &lt; 10; i++ {
		ch &lt;- i
	}
	quit &lt;- false	// or true, does not matter
}

func shower(c chan int, quit chan bool) {
	for {
		select {
		case j := &lt;-c:
			fmt.Printf(&quot;%d\n&quot;, j)
		case &lt;-quit:
			break
		}
	}
}
</artwork></figure>

<t>On line 20 we read from the quit channel and we discard the value we read. We
   could have used <spanx style="verb">q := &lt;-quit</spanx>, but then we would have used the variable only
   once --- which is illegal in Go. Another trick you might have pulled out of
   your hat may be: <spanx style="verb">_ = &lt;-quit</spanx>. This is valid in Go, but idomatic Go is the
   one given on line 20.</t>
</section>

<section anchor="fibonacci-ii" title="Fibonacci II">
<t>This is the same exercise as an earlier one <xref target="fibonacci"></xref> in
exercise. For completeness the complete question:</t>
<t>
<list style="empty">
<t>The Fibonacci sequence starts as follows: <spanx style="verb">1, 1, 2, 3, 5, 8, 13, \ldots</spanx>
Or in mathematical terms:
<spanx style="verb">x_1 = 1; x_2 = 1; x_n = x_{n-1} + &gt; x_{n-2}\quad\forall n &gt; 2</spanx>.<vspace />
Write a function that takes an <spanx style="verb">int</spanx> value and gives
that many terms of the Fibonacci sequence.</t>
</list></t>
<t><spanx style="emph">But</spanx> now the twist: You must use channels.</t>
</section>

<section anchor="answer-22" title="Answer">
<t>The following program calculates the Fibonacci numbers using channels.</t>

<figure><artwork type="go">package main
import &quot;fmt&quot;

func dup3(in &lt;-chan int) (&lt;-chan int, &lt;-chan int, &lt;-chan int) {
	a, b, c := make(chan int, 2), make(chan int, 2), make(chan int, 2)
	go func() {
		for {
			x := &lt;-in
			a &lt;- x
			b &lt;- x
			c &lt;- x
		}
	}()
	return a, b, c
}

func fib() &lt;-chan int {
	x := make(chan int, 2)
	a, b, out := dup3(x)
	go func() {
		x &lt;- 0
		x &lt;- 1
		&lt;-a
		for {
			x &lt;- &lt;-a+&lt;-b
		}
	}()
	return out
}

func main() {
	x := fib()
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&lt;-x)
	}
}

// See sdh33b.blogspot.com/2009/12/fibonacci-in-go.html
</artwork></figure>

</section>
</section>
</section>

<section anchor="communication" title="Communication">
<t>
<list style="empty">
<t>Good communication is as stimulating as black coffee, and just as hard
to sleep after.</t>
<t>-- Anne Morrow Lindbergh
</t>
</list></t>
<t>In this chapter we are going to look at the building blocks in Go for
communicating with the outside world. We will look at files, directories,
networking and executing other programs. Central to Go's I/O are the interfaces
<spanx style="verb">io.Reader</spanx> and <spanx style="verb">io.Writer</spanx>. The <spanx style="verb">io.Reader</spanx> interface specifies one method
<spanx style="verb">Read(p []byte) (n int, err err)</spanx>.</t>
<t>Reading from (and writing to) files is easy in Go. This program
only uses the <spanx style="verb">os</spanx> package to read data from the file <spanx style="verb">/etc/passwd</spanx>.</t>

<figure><artwork type="go">package main

import (
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	buf := make([]byte, 1024)
	f, e := os.Open(&quot;/etc/passwd&quot;) &lt;1&gt;
	if e != nil {
		log.Fatalf(e)
	}
	defer f.Close() &lt;2&gt;
	for {
		n, e := f.Read(buf) &lt;3&gt;
		if e != nil {
			log.Fatalf(e) &lt;4&gt;
		}
		if n == 0 { &lt;5&gt;
			break
		}
		os.Stdout.Write(buf[:n]) &lt;6&gt;
	}
}
</artwork></figure>

<t>We open the file at <spanx style="emph">1</spanx> with <spanx style="verb">os.Open</spanx> that returns a <spanx style="verb">*os.File</spanx>
<spanx style="verb">*os.File</spanx> implements <spanx style="verb">io.Reader</spanx> and <spanx style="verb">io.Writer</spanx> interface.
After the <spanx style="verb">Open</spanx> we directly put the <spanx style="verb">f.Close()</spanx> which we defer until the function
return. At <spanx style="emph">3</spanx> we call <spanx style="verb">Read</spanx> on <spanx style="verb">f</spanx> and read up to 1024 bytes at the time. If anything
fails we bail out at <spanx style="emph">4</spanx>. If the number of bytes read is 0 we've read the end of the
file <spanx style="emph">5</spanx>. And at <spanx style="emph">6</spanx> we output the buffer to standard output.</t>
<t>If you want to use buffered <iref item="io" subitem="buffered"/> I/O there is the
<spanx style="verb">bufio</spanx><iref item="package" subitem="bufio"/> package:</t>

<figure><artwork type="go">package main

import (
	&quot;bufio&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	buf := make([]byte, 1024)
	f, e := os.Open(&quot;/etc/passwd&quot;) &lt;1&gt;
	if e != nil {
		log.Fatalf(e)
	}
	defer f.Close()
	r := bufio.NewReader(f) &lt;2&gt;
	w := bufio.NewWriter(os.Stdout)
	defer w.Flush() &lt;3&gt;
	for {
		n, e := r.Read(buf) &lt;4&gt;
		if e != nil {
			log.Fatalf(e)
		}
		if n == 0 {
			break
		}
		w.Write(buf[0:n]) &lt;5&gt;
	}
}
</artwork></figure>

<t>Again, we open <spanx style="emph">1</spanx> the file. Then at <spanx style="emph">2</spanx> we
Turn <spanx style="verb">f</spanx> into a buffered <spanx style="verb">Reader</spanx>. <spanx style="verb">NewReader</spanx> expects an <spanx style="verb">io.Reader</spanx>, so you this will work.
Then at <spanx style="emph">4</spanx> we read and at <spanx style="emph">5</spanx> we write. We also call <spanx style="verb">Flush()</spanx> at <spanx style="emph">3</spanx> to flush all output.
This entire program could be optimized further by using <spanx style="verb">io.Copy</spanx>.</t>

<section anchor="io-reader" title="io.Reader">
<t>As mentioned above the <spanx style="verb">io.Reader</spanx> <iref item="io.Reader"/> is an important interface in the language Go. A lot
(if not all) functions that need to read from something take an <spanx style="verb">io.Reader</spanx><iref item="package" subitem="io"/>
as input. To fulfill the interface a type needs to implement that one method.
The writing side <spanx style="verb">io.Writer</spanx>, has the <spanx style="verb">Write</spanx> method.</t>
<t>If you think of a new type in your program or package and you make it fulfill the <spanx style="verb">io.Reader</spanx>
or <spanx style="verb">io.Writer</spanx> interface, <spanx style="emph">the whole standard Go library can be used</spanx> on that type!</t>
</section>

<section anchor="some-examples" title="Some examples">
<t>The previous program reads a file in its entirety, but a more common scenario is that
you want to read a file on a line-by-line basis. The following snippet shows a way
to do just that (we're discarding the error returned from <spanx style="verb">os.Open</spanx> here to keep
the examples smaller -- don't ever do this in real life code).</t>

<figure><artwork type="go">f, _ := os.Open(&quot;/etc/passwd&quot;); defer f.Close()
r := bufio.NewReader(f) &lt;1&gt;
s, ok := r.ReadString('\n') &lt;2&gt;
</artwork></figure>

<t>At <spanx style="emph">1</spanx> make <spanx style="verb">f</spanx> a <spanx style="verb">bufio</spanx> to have access to the <spanx style="verb">ReadString</spanx> method. Then at <spanx style="emph">2</spanx> we read
a line from the input, <spanx style="verb">s</spanx>  now holds a string which we can manipulate with, for instance,
the <spanx style="verb">strings</spanx> package.</t>
<t>A more robust method (but slightly more complicated) is <spanx style="verb">ReadLine</spanx>, see the documentation
of the <spanx style="verb">bufio</spanx> package.</t>
<t>A common scenario in shell scripting is that you want to check if a directory
exists and if not, create one.</t>

<figure><artwork type="go">if [ ! -e name ]; then          if f, e := os.Stat(&quot;name&quot;); e != nil {
    mkdir name                      os.Mkdir(&quot;name&quot;, 0755)
else                            } else {
    # error                         // error
fi                              }
</artwork></figure>

<t>The similarity between these two examples (and with other scripting languages)
have prompted comments that Go has a &quot;script&quot;-like feel to it, i.e. programming
in Go can be compared to programming in an interpreted language (Python, Ruby,
Perl or PHP).</t>
</section>

<section anchor="command-line-arguments" title="Command line arguments">
<t>Arguments from the command line are available inside your program via the string
slice <spanx style="verb">os.Args</spanx>, provided you have imported the package <spanx style="verb">os</spanx>. The <spanx style="verb">flag</spanx> package
<iref item="package" subitem="flag"/>
has a more sophisticated interface, and also provides a way to parse flags. Take
this example from a DNS query tool:</t>

<figure><artwork type="go">dnssec := flag.Bool(&quot;dnssec&quot;, false, &quot;Request DNSSEC records&quot;) &lt;1&gt;
port := flag.String(&quot;port&quot;, &quot;53&quot;, &quot;Set the query port&quot;) &lt;2&gt;
flag.Usage = func() {   &lt;3&gt;
    fmt.Fprintf(os.Stderr, &quot;Usage: %s [OPTIONS] [name ...]\n&quot;, os.Args[0])
    flag.PrintDefaults() &lt;4&gt;
}
flag.Parse() &lt;4&gt;
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we define a <spanx style="verb">bool</spanx> flag <spanx style="verb">-dnssec</spanx>. Note that this function returns
a <spanx style="emph">pointer</spanx> to the value, the <spanx style="verb">dnssec</spanx> is now a pointer to a <spanx style="verb">bool</spanx>. At <spanx style="emph">2</spanx> we
define an <spanx style="verb">strings</spanx> flag. Then at <spanx style="emph">3</spanx> we <spanx style="emph">redefine</spanx> the <spanx style="verb">Usage</spanx> variable of the
flag package so we can add some extra text. The <spanx style="verb">PrintDefaults</spanx> at <spanx style="emph">4</spanx> will
output the default help for the flags that are defined. Note even without
redefining a <spanx style="verb">flag.Usage</spanx> the flag <spanx style="verb">-h</spanx> is supported and will just output the help text
for each of the flags. Finally at <spanx style="emph">4</spanx> we call <spanx style="verb">Parse</spanx> that parses the command
line and fills the variables.</t>
<t>After the flags have been parsed you can used them: <spanx style="verb">if *dnssec { ... }</spanx></t>
</section>

<section anchor="executing-commands" title="Executing commands">
<t>The <spanx style="verb">os/exec</spanx><iref item="package" subitem="os/exec"/> package has functions to run external
commands, and is the premier way to execute commands from within a Go program.
It works by defining a <spanx style="verb">*exec.Cmd</spanx> structure for which it defines a number of
methods. Let's execute <spanx style="verb">ls -l</spanx>:</t>

<figure><artwork type="go">import &quot;os/exec&quot;

cmd := exec.Command(&quot;/bin/ls&quot;, &quot;-l&quot;)
err := cmd.Run()
</artwork></figure>

<t>The above example just runs &quot;ls -l&quot; without doing anything with the returned
data, capturing the standard output from a command is done as follows:</t>

<figure><artwork type="go">cmd := exec.Command(&quot;/bin/ls&quot;, &quot;-l&quot;)
buf, err := cmd.Output()
</artwork></figure>

<t>And <spanx style="verb">buf</spanx> is byte slice, that you can further use in your program.</t>
</section>

<section anchor="networking" title="Networking">
<t>All network related types and functions can be found in the package <spanx style="verb">net</spanx>. One
of the most important functions in there is <spanx style="verb">Dial</spanx><iref item="networking" subitem="Dial"/>. When
you <spanx style="verb">Dial</spanx> into a remote system the function returns a <spanx style="verb">Conn</spanx> interface type,
which can be used to send and receive information. The function <spanx style="verb">Dial</spanx> neatly
abstracts away the network family and transport. So IPv4 or IPv6, TCP or UDP can
all share a common interface.</t>
<t>Dialing a remote system (port 80) over TCP, then UDP and lastly TCP over IPv6
looks like this:</t>

<figure><artwork type="go">conn, e := Dial(&quot;tcp&quot;, &quot;192.0.32.10:80&quot;)
conn, e := Dial(&quot;udp&quot;, &quot;192.0.32.10:80&quot;)
conn, e := Dial(&quot;tcp&quot;, &quot;[2620:0:2d0:200::10]:80&quot;)
</artwork></figure>

<t>If there were no errors (returned in <spanx style="verb">e</spanx>), you can use <spanx style="verb">conn</spanx> to read and write.
And <spanx style="verb">conn</spanx> implements the <spanx style="verb">io.Reader</spanx> and <spanx style="verb">io.Writer</spanx> interface. </t>
<t>But these are the low level nooks and crannies, you will almost always use
higher level packages, such as the <spanx style="verb">http</spanx> package. For instance a simple Get for
http:</t>

<figure><artwork type="go">package main

import (
    &quot;fmt&quot;
    &quot;http&quot;
    &quot;io/ioutil&quot;
)

func main() {
    r, err := http.Get(&quot;http://www.google.com/robots.txt&quot;)
    if err != nil {
        fmt.Printf(&quot;%s\n&quot;, err.String())
        return
    }
    b, err := ioutil.ReadAll(r.Body)
    r.Body.Close()
    if err == nil {
        fmt.Printf(&quot;%s&quot;, string(b))
    }
}
</artwork></figure>

</section>

<section anchor="exercises-6" title="Exercises">

<section anchor="finger-daemon" title="Finger daemon">
<t>Write a finger daemon that works with the finger(1) command.</t>
<t>From the <eref target="https://www.debian.org">Debian</eref> package description:</t>
<t>
<list style="empty">
<t>Fingerd is a simple daemon based on RFC 1196 <xref target="RFC1196"></xref> that provides an interface to the
&quot;finger&quot; program at most network sites.  The program is supposed to return a
friendly, human-oriented status report on either the system at the moment or a
particular person in depth.</t>
</list></t>
<t>Stick to the basics and only support a username argument. If the user has a <spanx style="verb">.plan</spanx> file
show the contents of that file. So your program needs to be able to figure out:</t>
<t>
<list style="symbols">
<t>Does the user exist?</t>
<t>If the user exists, show the contents of the <spanx style="verb">.plan</spanx> file.</t>
</list>
</t>
</section>

<section anchor="answer-23" title="Answer">
<t>This solution is from Fabian Becker.</t>

<figure><artwork type="go">package main

import (
	&quot;bufio&quot;
	&quot;errors&quot;
	&quot;flag&quot;
	&quot;io/ioutil&quot;
	&quot;net&quot;
	&quot;os/user&quot;
)

func main() {
	flag.Parse()
	ln, err := net.Listen(&quot;tcp&quot;, &quot;:79&quot;)
	if err != nil {
		panic(err)
	}
	for {
		conn, err := ln.Accept()
		if err != nil {
			continue
		}
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	usr, _, _ := reader.ReadLine()

	if info, err := getUserInfo(string(usr)); err != nil {
		conn.Write([]byte(err.Error()))
	} else {
		conn.Write(info)
	}
}

func getUserInfo(usr string) ([]byte, error) {
	u, e := user.Lookup(usr)
	if e != nil {
		return nil, e
	}
	data, err := ioutil.ReadFile(u.HomeDir + &quot;.plan&quot;)
	if err != nil {
		return data, errors.New(&quot;User doesn't have a .plan file!\n&quot;)
	}
	return data, nil
}
</artwork></figure>

</section>

<section anchor="echo-server" title="Echo server">
<t>Write a simple echo server. Make it listen to TCP port number 8053 on localhost.
It should be able to read a line (up to the newline), echo back that line and
then close the connection.</t>
<t>Make the server concurrent so that every request is taken care of in a separate
goroutine.</t>
</section>

<section anchor="answer-24" title="Answer">
<t>A simple echo server might be:</t>

<figure><artwork type="go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;net&quot;
)

func main() {
	l, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8053&quot;)
	if err != nil {
		fmt.Printf(&quot;Failure to listen: %s\n&quot;, err.Error())
	}
	for {
		if c, err := l.Accept(); err == nil {
			Echo(c)
		}
	}
}

func Echo(c net.Conn) {
	defer c.Close()
	line, err := bufio.NewReader(c).ReadString('\n')
	if err != nil {
		fmt.Printf(&quot;Failure to read: %s\n&quot;, err.Error())
		return
	}
	_, err = c.Write([]byte(line))
	if err != nil {
		fmt.Printf(&quot;Failure to write: %s\n&quot;, err.Error())
		return
	}
}
</artwork></figure>

<t>When started you should see the following:</t>

<figure><artwork>% nc 127.0.0.1 8053
Go is *awesome*
Go is *awesome*
</artwork></figure>

<t>To make the connection handling concurrent we <spanx style="emph">only need to change one line</spanx> in our
echo server, the line:</t>

<figure><artwork type="go">if c, err := l.Accept(); err == nil { Echo(c) }
</artwork></figure>

<t>becomes:</t>

<figure><artwork type="go">if c, err := l.Accept(); err == nil { go Echo(c) }
</artwork></figure>

</section>

<section anchor="word-and-letter-count" title="Word and Letter Count">
<t>Write a small program that reads text from standard input and performs the
following actions:</t>
<t>
<list style="symbols">
<t>Count the number of characters (including spaces).</t>
<t>Count the number of words.</t>
<t>Count the numbers of lines</t>
</list>
</t>
<t>In other words implement wc(1) (check you local manual page), however you only
have to read from standard input.</t>
</section>

<section anchor="answer-25" title="Answer">
<t>The following program is an implementation of wc(1).</t>

<figure><artwork type="go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	var chars, words, lines int
	r := bufio.NewReader(os.Stdin) &lt;1&gt;
	for {
		switch s, ok := r.ReadString('\n'); true { &lt;2&gt;
		case ok != nil: &lt;3&gt;
			fmt.Printf(&quot;%d %d %d\n&quot;, chars, words, lines)
			return
		default: &lt;4&gt;
			chars += len(s)
			words += len(strings.Fields(s))
			lines++
		}
	}
}
</artwork></figure>

<t>At <spanx style="emph">1</spanx> we create a new reader that reads from standard input, we then read from
the input at <spanx style="emph">2</spanx>. And at <spanx style="emph">3</spanx> we check the value of <spanx style="verb">ok</spanx> and if we received an
error, we assume it was because of a EOF, So we print the current values;.
Otherwise <spanx style="emph">4</spanx> we count the charaters, words and increment the number lines.</t>
</section>

<section anchor="uniq" title="Uniq">
<t>Write a Go program that mimics the function of the Unix <spanx style="verb">uniq</spanx> command. This
program should work as follows, given a list with the following items:</t>

<figure><artwork>'a' 'b' 'a' 'a' 'a' 'c' 'd' 'e' 'f' 'g'
</artwork></figure>

<t>it should print only those items which don't have the same successor:</t>

<figure><artwork>'a' 'b' 'a' 'c' 'd' 'e' 'f' 'g'
</artwork></figure>

<t>The next listing is a Perl implementation of the algorithm.</t>

<figure><artwork type="pl">#!/usr/bin/perl
my @a = qw/a b a a a c d e f g/;
print my $first = shift @a;
foreach (@a) {
    if ($first ne $_) { print; $first = $_; }
}
</artwork></figure>

</section>

<section anchor="answer-26" title="Answer">
<t>The following is a <spanx style="verb">uniq</spanx> implementation in Go.</t>

<figure><artwork type="go">package main

import &quot;fmt&quot;

func main() {
	list := []string{&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}
	first := list[0]

	fmt.Printf(&quot;%s &quot;, first)
	for _, v := range list[1:] {
		if first != v {
			fmt.Printf(&quot;%s &quot;, v)
			first = v
		}
	}
}
</artwork></figure>

</section>

<section anchor="quine" title="Quine">
<t>A <spanx style="emph">Quine</spanx> is a program that prints itself. Write a Quine in Go.</t>
</section>

<section anchor="answer-27" title="Answer">
<t>This solution is from Russ Cox. It was posted to the Go Nuts mailing list.</t>

<figure><artwork type="go">/* Go quine */
package main
import &quot;fmt&quot;
func main() {
 fmt.Printf(&quot;%s%c%s%c\n&quot;, q, 0x60, q, 0x60)
}
var q = `/* Go quine */
package main
import &quot;fmt&quot;
func main() {
 fmt.Printf(&quot;%s%c%s%c\n&quot;, q, 0x60, q, 0x60)
}
var q = `
</artwork></figure>

</section>

<section anchor="processes" title="Processes">
<t>Write a program that takes a list of all running processes and prints how many
child processes each parent has spawned. The output should look like:</t>

<figure><artwork>Pid 0 has 2 children: [1 2]
Pid 490 has 2 children: [1199 26524]
Pid 1824 has 1 child: [7293]
</artwork></figure>

<t>
<list style="symbols">
<t>For acquiring the process list, you'll need to capture the output of <spanx style="verb">ps -e
-opid,ppid,comm</spanx>. This output looks like:
<figure><artwork>  PID  PPID COMMAND
 9024  9023 zsh
19560  9024 ps
</artwork></figure>

</t>
<t>If a parent has one child you must print <spanx style="verb">child</spanx>, if there is more than one
print <spanx style="verb">children</spanx>.</t>
<t>The process list must be numerically sorted, so you start with pid 0 and work
your way up.</t>
</list>
</t>
<t>Here is a Perl version to help you on your way (or to create complete and utter confusion).</t>

<figure><artwork type="pl">#!/usr/bin/perl -l
my (%child, $pid, $parent);
my @ps=`ps -e -opid,ppid,comm`;	  # capture the output from `ps`
foreach (@ps[1..$#ps]) {	  # discard the header line
  ($pid, $parent, undef) = split; # split the line, discard 'comm'
  push @{$child{$parent}}, $pid;  # save the child PIDs on a list
}
# Walk through the sorted PPIDs
foreach (sort { $a &lt;=&gt; $b } keys %child) {
  print &quot;Pid &quot;, $_, &quot; has &quot;, @{$child{$_}}+0, &quot; child&quot;,
    @{$child{$_}} == 1 ? &quot;: &quot; : &quot;ren: &quot;, &quot;[@{$child{$_}}]&quot;;
}
</artwork></figure>

</section>

<section anchor="answer-28" title="Answer">
<t>There is lots of stuff to do here. We can divide our program
up in the following sections:</t>
<t>
<list style="symbols">
<t>Starting <spanx style="verb">ps</spanx> and capturing the output.</t>
<t>Parsing the output and saving the child PIDs for each PPID.</t>
<t>Sorting the PPID list.</t>
<t>Printing the sorted list to the screen.</t>
</list>
</t>
<t>In the solution presented below, we've used a <spanx style="verb">map[int][]int</spanx>, i.e. a map
indexed with integers, pointing to a slice of ints -- which holds the PIDs. The
builtin <spanx style="verb">append</spanx> is used to grow the integer slice.</t>
<t>A possible program is:</t>

<figure><artwork type="go">package main

import (
	&quot;fmt&quot;
	&quot;os/exec&quot;
	&quot;sort&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
)

func main() {
	ps := exec.Command(&quot;ps&quot;, &quot;-e&quot;, &quot;-opid,ppid,comm&quot;)
	output, _ := ps.Output()
	child := make(map[int][]int)
	for i, s := range strings.Split(string(output), &quot;\n&quot;) {
		if i == 0 { // kill first line
			continue
		}
		if len(s) == 0 { // kill last line
			continue
		}
		f := strings.Fields(s)
		fpp, _ := strconv.Atoi(f[1]) // parent's pid
		fp, _ := strconv.Atoi(f[0])  // child's pid
		child[fpp] = append(child[fpp], fp)
	}
	schild := make([]int, len(child))
	i := 0
	for k, _ := range child {
		schild[i] = k
		i++
	}
	sort.Ints(schild)
	for _, ppid := range schild {
		fmt.Printf(&quot;Pid %d has %d child&quot;, ppid, len(child[ppid]))
		if len(child[ppid]) == 1 {
			fmt.Printf(&quot;: %v\n&quot;, child[ppid])
			continue
		}
		fmt.Printf(&quot;ren: %v\n&quot;, child[ppid])
	}
}
</artwork></figure>

</section>

<section anchor="number-cruncher" title="Number cruncher">
<t>
<list style="symbols">
<t>Pick six (6) random numbers from this list: <spanx style="verb">1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
25, 50, 75, 100</spanx> Numbers may be picked multiple times.</t>
<t>Pick one (1) random number (<spanx style="verb">i</spanx>) in the range: <spanx style="verb">1 \ldots 1000</spanx>.</t>
<t>Tell how, by combining the first 6 numbers (or a subset thereof)
with the operators <spanx style="verb">+,-,*</spanx> and <spanx style="verb">/</spanx>, you can make <spanx style="verb">i</spanx>.</t>
</list>
</t>
<t>An example. We have picked the numbers: 1, 6, 7, 8, 8 and 75. And <spanx style="verb">i</spanx> is
977. This can be done in many different ways, one way is:
<spanx style="verb"> ((((1 * 6) * 8) + 75) * 8) - 7 = 977</spanx>
or
<spanx style="verb"> (8*(75+(8*6)))-(7/1) = 977</spanx></t>
<t>Implement a number cruncher that works like that. Make it print the solution in
a similar format (i.e. output should be infix with parenthesis) as used above.</t>
<t>Calculate <spanx style="emph">all</spanx> possible solutions and show them (or only show how many there
are). In the example above there are 544 ways to do it.</t>
</section>

<section anchor="answer-29" title="Answer">
<t>The following is one possibility. It uses recursion and backtracking to get
an answer. When starting <spanx style="verb">permrec</spanx> we give 977 as the first argument:</t>

<figure><artwork>% ./permrec 977
1+(((6+7)*75)+(8/8)) = 977  #1
...                         ...
((75+(8*6))*8)-7 = 977      #542
(((75+(8*6))*8)-7)*1 = 977  #543
(((75+(8*6))*8)-7)/1 = 977  #544
</artwork></figure>


<figure><artwork type="go">package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;strconv&quot;
)

const (
	_ = 1000 * iota
	ADD
	SUB
	MUL
	DIV
	MAXPOS = 11
)

var mop = map[int]string{ADD: &quot;+&quot;, SUB: &quot;-&quot;, MUL: &quot;*&quot;, DIV: &quot;/&quot;}
var (
	ok    bool
	value int
)

type Stack struct {
	i    int
	data [MAXPOS]int
}

func (s *Stack) Reset()     { s.i = 0 }
func (s *Stack) Len() int   { return s.i }
func (s *Stack) Push(k int) { s.data[s.i] = k; s.i++ }
func (s *Stack) Pop() int   { s.i--; return s.data[s.i] }

var found int
var stack = new(Stack)

func main() {
	flag.Parse()
	list := []int{1, 6, 7, 8, 8, 75, ADD, SUB, MUL, DIV}
	magic, ok := strconv.Atoi(flag.Arg(0)) // Arg0 is i
	if ok != nil {
		return
	}
	f := make([]int, MAXPOS)
	solve(f, list, 0, magic)
}

func solve(form, numberop []int, index, magic int) {
	var tmp int
	for i, v := range numberop {
		if v == 0 {
			goto NEXT
		}
		if v &lt; ADD { // it's a number, save it
			tmp = numberop[i]
			numberop[i] = 0
		}
		form[index] = v
		value, ok = rpncalc(form[0 : index+1])

		if ok &amp;&amp; value == magic {
			if v &lt; ADD {
				numberop[i] = tmp // reset and go on
			}
			found++
			fmt.Printf(&quot;%s = %d  #%d\n&quot;, rpnstr(form[0:index+1]), value, found)
		}

		if index == MAXPOS-1 {
			if v &lt; ADD {
				numberop[i] = tmp // reset and go on
			}
			goto NEXT
		}
		solve(form, numberop, index+1, magic)
		if v &lt; ADD {
			numberop[i] = tmp // reset and go on
		}
	NEXT:
	}
}

func rpnstr(r []int) (ret string) { // Convert rpn to infix notation
	s := make([]string, 0) // Still memory intensive
	for k, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
			var a, b string
			a, s = s[len(s)-1], s[:len(s)-1]
			b, s = s[len(s)-1], s[:len(s)-1]
			if k == len(r)-1 {
				s = append(s, b+mop[t]+a)
			} else {
				s = append(s, &quot;(&quot;+b+mop[t]+a+&quot;)&quot;)
			}
		default:
			s = append(s, strconv.Itoa(t))
		}
	}
	for _, v := range s {
		ret += v
	}
	return
}

func rpncalc(r []int) (int, bool) {
	stack.Reset()
	for _, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
			if stack.Len() &lt; 2 {
				return 0, false
			}
			a := stack.Pop()
			b := stack.Pop()
			if t == ADD {
				stack.Push(b + a)
			}
			if t == SUB {
				// disallow negative subresults
				if b-a &lt; 0 {
					return 0, false
				}
				stack.Push(b - a)
			}
			if t == MUL {
				stack.Push(b * a)
			}
			if t == DIV {
				if a == 0 {
					return 0, false
				}
				// disallow fractions
				if b%a != 0 {
					return 0, false
				}
				stack.Push(b / a)
			}
		default:
			stack.Push(t)
		}
	}
	if stack.Len() == 1 { // there is only one!
		return stack.Pop(), true
	}
	return 0, false
}
</artwork></figure>

</section>
</section>
</section>

</middle>

<back>
<references title="Informative References">
<reference anchor="effective_go">
  <front>
    <title>Effective Go</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://golang.org/doc/effective_go.html" />
</reference>
<reference anchor="go_1_5_release_notes">
  <front>
    <title>Go 1.5 Release Notes</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="https://golang.org/doc/go1.5" />
</reference>
<reference anchor="fizzbuzz">
  <front>
    <title>Using fizzbuzz to find developers...</title>
    <author fullname="Imran On Tech" initials="I. O." surname="Tech" />
    <date year="2010" />
  </front>
</reference>
<reference anchor="duck_typing">
  <front>
    <title>Duck typing</title>
    <author fullname="Wikipedia" initials="" surname="Wikipedia" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://en.wikipedia.org/wiki/Duck_typing" />
</reference>
<reference anchor="go_course_day3">
  <front>
    <title>The Go programming language, day 3</title>
    <author fullname="Rob Pike" initials="R." surname="Pike" />
    <date year="2010" />
  </front>
  <format type="PDF" target="http://golang.org/doc/GoCourseDay3.pdf" />
</reference>
<reference anchor="go_nuts_interfaces">
  <front>
    <title>Function accepting a slice of interface types</title>
    <author fullname="Go Community" initials="G." surname="Community" />
    <date year="2010" />
  </front>
</reference>
<reference anchor="go_web">
  <front>
    <title>Go website</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://golang.org/" />
</reference>
<reference anchor="go_tutorial">
  <front>
    <title>Go tutorial</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://golang.org/doc/go_tutorial.html" />
</reference>
<reference anchor="go_spec">
  <front>
    <title>Go language specification</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target=" http://golang.org/doc/go_spec.html" />
</reference>
<?rfc include="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4627.xml"?>
<?rfc include="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1196.xml"?>
<reference anchor="csp">
  <front>
    <title>Communicating sequential processes (csp)</title>
    <author fullname="C. A. R. Hoare" initials="C. A. R." surname="Hoare" />
    <date year="1985" />
  </front>
  <format type="PDF" target="http://www.usingcsp.com/cspbook.pdf" />
</reference>
<reference anchor="go_blog_panic">
  <front>
    <title>Defer, panic, and recover</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="https://blog.golang.org/defer-panic-and-recover" />
</reference>
<reference anchor="bubblesort">
  <front>
    <title>Bubble sort</title>
    <author fullname="Wikipedia" initials="" surname="Wikipedia" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://en.wikipedia.org/wiki/Bubble_sort" />
</reference>
</references>

</back>

</rfc>
