<?xml version="1.0" encoding="utf-8"?>
<!-- name="GENERATOR" content="github.com/mmarkdown/mmark markdown processor for Go" -->
<rfc version="3" ipr="trust200902" submissionType="IETF" category="info" xml:lang="en" consensus="false" xmlns:xi="http://www.w3.org/2001/XInclude">

<front>
<title abbrev="Learning Go">Learning Go</title><seriesInfo value="draft-learning-go-00" stream="IETF" status="informational" name="Internet-Draft"></seriesInfo>
<author initials="R." surname="Gieben" fullname="R. (Miek) Gieben"><organization></organization><address><postal><street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal><phone></phone>
<email>miek@miek.nl</email>
<uri></uri>
</address></author>
<date year="2018" month="8" day="25"></date>
<area>Application</area>
<workgroup>Go Working Group</workgroup>
<keyword>Go</keyword>
<keyword>Language</keyword>
<keyword>Computer</keyword>

</front>

<middle>

<section anchor="preface"><name>Preface</name>
<t>The <eref target="https://github.com/miekg/learninggo">source of this book</eref> is written in
<eref target="https://github.com/mmarkdown/mmark">mmark</eref> and is converted from the <eref target="https://github.com/miekg/gobook">original
LaTeX source</eref>.</t>
<t><em>All example code used in this book is hereby licensed under the Apache License version 2.0.</em></t>
<blockquote><t>This work is licensed under the Attribution-NonCommercial-ShareAlike 3.0 Unported License. To
view a copy of this license, visit <eref target="http://creativecommons.org/licenses/by-nc-sa/3.0/">http://creativecommons.org/licenses/by-nc-sa/3.0/</eref>
or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.</t>
</blockquote><t>The following people made large or small contributions to earlier versions of this book:</t>
<t>Adam J. Gray,
Alexander Katasonov,
Alexey Chernenkov,
Alex Sychev,
Andrea Spadaccini,
Andrey Mirtchovski,
Anthony Magro,
Babu Sreekanth,
Ben Bullock,
Bob Cunningham,
Brian Fallik,
Cecil New,
Cobold,
Damian Gryski,
Daniele Pala,
Dan Kortschak,
David Otton,
Fabian Becker,
Filip Zaludek,
Hadi Amiri,
Haiping Fan,
Iaroslav Tymchenko,
Jaap Akkerhuis,
JC van Winkel,
Jeroen Bulten,
Jinpu Hu,
John Shahid,
Jonathan Kans,
Joshua Stein,
Makoto Inoue,
Marco Ynema,
Mayuresh Kathe,
Mem,
Michael Stapelberg,
Nicolas Kaiser,
Olexandr Shalakhin,
Paulo Pinto,
Peter Kleiweg,
Philipp Schmidt,
Robert Johnson,
Russel Winder,
Simoc,
Sonia Keys,
Stefan Schroeder,
Thomas Kapplet,
T.J. Yang,
Uriel<tt>\dagger</tt>,
Vrai Stacey,
Xing Xing.</t>
<t>&quot;Learning Go&quot; has been translated into (note that this used the original LaTeX source).</t>

<ul>
<li><t>Chinese, by Xing Xing, 这里是中文译本: <eref target="http://www.mikespook.com/learning-go/">http://www.mikespook.com/learning-go/</eref></t>
</li>
</ul>
<t>I hope this book is useful.</t>
<t>Miek Gieben, London, 2015.</t>
<t>This book still sees development, small incremental improvements trickle in from Github.</t>
<t>Miek Gieben, London, 2017.</t>
<t>Learning Go's source has been rewritten in <eref target="https://github.com/mmarkdown/mmark">mmark2</eref>, but did not see any
other changes.</t>
<t>Miek Gieben, London, 2018.</t>
</section>

<section anchor="learning-go"><name>Learning Go</name>
<t></t>
</section>

<section anchor="introduction"><name>Introduction</name>
<blockquote quotedFrom="Frequently asked questions, Go Authors
"><t>Is Go an object-oriented language? Yes and no.</t>
</blockquote><t>The Go programming language is an open source project language to make programmers more productive.</t>
<t>According to the website <xref target="go_web"></xref> &quot;Go is expressive, concise, clean, and efficient&quot;. And indeed it
is. My initial interest was piqued when I read early announcements about this new language that had
built-in concurreny and a C-like syntax (Erlang also has built-in concurrency, but I could never get
used to its syntax). Go is a compiled statically typed language that feels like a dynamically typed,
interpreted language. My go to (scripting!) language Perl has taken a back seat now that Go is
around.</t>
<t>The unique Go language is defined by these principles:</t>

<dl>
<dt>Clean and Simple</dt>
<dd><t>Go strives to keep things small and beautiful. You should be able to do a lot in only a few
lines of code.</t>
</dd>
<dt>Concurrent</dt>
<dd><t>Go makes it easy to &quot;fire off&quot; functions to be run as <em>very</em> lightweight threads. These threads
are called goroutines <iref item="goroutine"/> in Go.</t>
</dd>
<dt>Channels</dt>
<dd><t>Communication with these goroutines is done, either via shared state or via <iref item="channels"/>
channels <xref target="csp"></xref>.</t>
</dd>
<dt>Fast</dt>
<dd><t>Compilation is fast and execution is fast. The aim is to be as fast as C. Compilation time is
measured in seconds.</t>
</dd>
<dt>Safe</dt>
<dd><t>Explicit casting and strict rules when converting one type to another. Go has garbage
collection. No more <tt>free()</tt> in Go: the language takes care of this.</t>
</dd>
<dt>Standard format</dt>
<dd><t>A Go program can be formatted in (almost) any way the programmers want, but an official format
exists. The rule is very simple: The output of the filter <tt>gofmt</tt> <em>is the officially endorsed
format</em>.</t>
</dd>
<dt>Postfix types</dt>
<dd><t>Types are given <em>after</em> the variable name, thus <tt>var a int</tt>, instead of <tt>int a</tt>.</t>
</dd>
<dt>UTF-8</dt>
<dd><t>UTF-8 is everywhere, in strings <em>and</em> in the program code. Finally you can use <tt>\Phi = \Phi + 1</tt>
in your source code.</t>
</dd>
<dt>Open Source</dt>
<dd><t>The Go license is completely open source.</t>
</dd>
<dt>Fun</dt>
<dd><t>Programming with Go should be fun!</t>
</dd>
</dl>
<t>As I mentioned Erlang also shares some features of Go. A notable difference between Erlang and Go is
that Erlang borders on being a functional language, while Go is imperative. And Erlang runs in
a virtual machine, while Go is compiled.</t>

<section anchor="how-to-read-this-book"><name>How to Read this Book</name>
<t>I've written this book for people who already know some programming languages and how to program. In
order to use this book, you (of course) need Go installed on your system, but you can easily try
examples online in the Go playground. All exercises in this book work
with Go 1, the first stable release of Go -- if not, it's a bug.</t>
<t>The best way to learn Go is to create your own programs. Each chapter therefore includes exercises
(and answers to exercises) to acquaint you with the language. Each exercise is either <em>easy</em>,
<em>intermediate</em>, or <em>difficult</em>. The answers are included after the exercises on a new page. Some
exercises don't have an answer; these are marked with an asterisk.</t>
<t>Here's what you can expect from each chapter:</t>

<dl>
<dt><xref target="basics"></xref></dt>
<dd><t>We'll look at the basic types, variables, and control structures available in the language.</t>
</dd>
<dt><xref target="functions"></xref></dt>
<dd><t>Here we look at functions, the basic building blocks of Go programs.</t>
</dd>
<dt><xref target="packages"></xref></dt>
<dd><t>We'll see that functions and data can be grouped together in packages. We'll also see how to
document and test our packages.</t>
</dd>
<dt><xref target="beyond-the-basics"></xref></dt>
<dd><t>We'll create our own types. We'll also look at memory allocations in Go.</t>
</dd>
<dt><xref target="interfaces"></xref></dt>
<dd><t>We'll learn how to use interfaces. Interfaces are the central concept in Go,
as Go does not support object orientation in the traditional sense.</t>
</dd>
<dt><xref target="concurrency"></xref></dt>
<dd><t>We'll learn the <tt>go</tt> keyword, which can be used to start function in separate routines (called
goroutines). Communication with those goroutines is done via channels.</t>
</dd>
<dt><xref target="communication"></xref></dt>
<dd><t>Finally we'll see how to interface with the rest of the world from within a Go program. We'll
see how to create files and read and write to and from them. We'll also briefly look into
networking.</t>
</dd>
</dl>
</section>

<section anchor="official-documentation"><name>Official Documentation</name>
<t>There is a substantial amount of documentation written about Go. The Go Tutorial <xref target="go_tutorial"></xref>, the
Go Tour (with lots of exercises) and the Effective Go <xref target="effective_go"></xref> are helpful resources. The
website <eref target="http://golang.org/doc/">http://golang.org/doc/</eref> is a very good starting point for reading up on
Go. Reading these documents is certainly not
required, but it is recommended.</t>
<blockquote><t>When searching on the internet use the term &quot;golang&quot; instead of plain &quot;go&quot;.</t>
</blockquote><t>Go comes with its own documentation in the form of a program called <tt>godoc</tt>. If you are
interested in the documentation for the built-ins, simply do this:</t>

<artwork>% godoc builtin
</artwork>
<t>To get the documentation of the <tt>hash</tt> package, just:</t>

<artwork>% godoc hash
</artwork>
<t>To read the documentation of <tt>fnv</tt> contained in <tt>hash</tt>, you'll need to issue <tt>godoc hash/fnv</tt> as
<tt>fnv</tt> is a subdirectory of <tt>hash</tt>.</t>

<sourcecode type="go">PACKAGE DOCUMENTATION

package fnv
    import &quot;hash/fnv&quot;

    Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash
    ...
</sourcecode>
</section>
</section>

<section anchor="basics"><name>Basics</name>
<blockquote quotedFrom="On adding complex numbers to Go, Ken Thompson
"><t>I am interested in this and hope to do something.</t>
</blockquote><t>In this chapter we will look at the basic building blocks of the Go programming
language.</t>

<section anchor="hello-world"><name>Hello World</name>
<t>In the Go tutorial, you get started with Go in the typical manner: printing
&quot;Hello World&quot; (Ken Thompson and Dennis Ritchie started this when they presented
the C language in the 1970s). That's a great way to start, so here it is, &quot;Hello
World&quot; in Go.</t>

<sourcecode type="go">package main &lt;1&gt;

import &quot;fmt&quot; &lt;2&gt; // Implements formatted I/O.

/* Print something */ &lt;3&gt;
func main() {         &lt;4&gt;
	fmt.Printf(&quot;Hello, world.&quot;) &lt;5&gt;
}
</sourcecode>
<t>Lets look at the program line by line. This first line is just required <em>1</em>. All
Go files start with <tt>package &lt;something&gt;</tt>, and <tt>package main</tt> is required for
a standalone executable.</t>
<t><tt>import &quot;fmt&quot;</tt> says we need <tt>fmt</tt> in addition to <tt>main</tt> <em>2</em>. A package other
than <tt>main</tt> is commonly called a library, a familiar concept in many programming
languages (see <xref target="packages"></xref>). The line ends with a comment that begins with <tt>//</tt>.</t>
<t>Next we another comment, but this one is enclosed in <tt>/*</tt> <tt>*/</tt> <em>3</em>. When your Go
program is executed, the first function called will be <tt>main.main()</tt>, which
mimics the behavior from C. Here we declare that function <em>4</em>.</t>
<t>Finally we call a function from the package <tt>fmt</tt> to print a string to the
screen. The string is enclosed with <tt>&quot;</tt> and may contain non-ASCII characters
<em>5</em>.</t>
</section>

<section anchor="compiling-and-running-code"><name>Compiling and Running Code</name>
<t>To build a Go program, use the <tt>go</tt> tool.<iref item="tooling" subitem="go"/>
To build <tt>helloworld</tt> we just enter:</t>

<artwork>% go build helloworld.go
</artwork>
<t><iref item="tooling" subitem="go build"/>
This results in an executable called <tt>helloworld</tt>. <iref item="tooling" subitem="go run"/></t>

<artwork>% ./helloworld
Hello, world.
</artwork>
<t>You can combine the above and just call <tt>go run helloworld.go</tt>.</t>
</section>

<section anchor="variables-types-and-keywords"><name>Variables, Types and Keywords</name>
<t>In the next few sections we will look at the variables, basic types, keywords,
and control structures of our new language.</t>
<t>Go is different from (most) other languages in that the type of a variable is
specified <em>after</em> the variable name. So not: <tt>int a</tt>, but <tt>a int</tt>. When you
declare a variable it is assigned the &quot;natural&quot; null value for the type. This
means that after <tt>var a int</tt>, <tt>a</tt> has a value of 0. With <tt>var s string</tt>, <tt>s</tt> is
assigned the zero string, which is <tt>&quot;&quot;</tt>. Declaring and assigning in Go is a two
step process, but they may be combined. Compare the following pieces of code
which have the same effect. <iref item="variables" subitem="declaring"/> <iref item="variables" subitem="assigning"/></t>

<sourcecode type="go">var a int                           a := 15
var b bool                          b := false
a = 15
b = false
</sourcecode>
<t>On the left we use the <tt>var</tt> keyword to declare a variable and <em>then</em> assign
a value to it. The code on the right uses <tt>:=</tt> to do this in one step (this form
may only be used <em>inside</em> functions). In that case the variable type is
<em>deduced</em> from the value. A value of 15 indicates an <tt>int</tt>. A value of <tt>false</tt>
tells Go that the type should be <tt>bool</tt>. Multiple <tt>var</tt> declarations may also
be grouped; <tt>const</tt> (see <xref target="constants"></xref>) and <tt>import</tt> also allow this. Note the
use of parentheses instead of braces:</t>

<sourcecode type="go">var (
    x int
    b bool
)
</sourcecode>
<t>Multiple variables of the same type can also be declared on a single line: <tt>var
x, y int</tt> makes <tt>x</tt> and <tt>y</tt> both <tt>int</tt> variables. You can also make use of
<em>parallel assignment</em><iref item="variables" subitem="parallel assignment"/> <tt>a, b := 20, 16</tt>.
This makes <tt>a</tt> and <tt>b</tt> both integer variables and assigns
20 to <tt>a</tt> and 16 to <tt>b</tt>.</t>
<t>A special name for a variable is <tt>_</tt>. <iref item="variables" subitem="underscore"/> Any value
assigned to it is discarded (it's similar to <tt>/dev/null</tt> on Unix). In this
example we only assign the integer value of 35 to <tt>b</tt> and discard the value 34:
<tt>_, b := 34, 35</tt>. Declared but otherwise <em>unused</em> variables are a compiler error
in Go.</t>

<section anchor="boolean-types"><name>Boolean Types</name>
<t>A boolean type represents the set of boolean truth values denoted by the
predeclared constants <em>true</em> and <em>false</em>. The boolean type is <tt>bool</tt>.</t>
</section>

<section anchor="numerical-types"><name>Numerical Types</name>
<t>Go has most of the well-known types such as <tt>int</tt>. The <tt>int</tt> type has the
appropriate length for your machine, meaning that on a 32-bit machine it is 32
bits and on a 64-bit machine it is 64 bits. Note: an <tt>int</tt> is either 32 or 64
bits, no other values are defined. Same goes for <tt>uint</tt>, the unsigned int.</t>
<t>If you want to be explicit about the length, you can have that too, with
<tt>int32</tt>, or <tt>uint32</tt>. The full list for (signed and unsigned) integers is
<tt>int8</tt>, <tt>int16</tt>, <tt>int32</tt>, <tt>int64</tt> and <tt>byte</tt>, <tt>uint8</tt>, <tt>uint16</tt>, <tt>uint32</tt>,
<tt>uint64</tt>, with <tt>byte</tt> being an alias for <tt>uint8</tt>. For floating point values
there is <tt>float32</tt> and <tt>float64</tt> (there is no <tt>float</tt> type). A 64 bit integer or
floating point value is <em>always</em> 64 bit, also on 32 bit architectures.</t>
<t>Note that these types are all distinct and assigning variables which mix these
types is a compiler error, like in the following code:</t>

<sourcecode type="go">package main

func main() {
	var a int
	var b int32
	b = a + a
	b = b + 5
}
</sourcecode>
<t>We declare two different integers, a and b where a is an <tt>int</tt> and b is an
<tt>int32</tt>. We want to set b to the sum of a and a. This fails and gives the error:
<tt>cannot use a + a (type int)  as type int32 in assignment</tt>. Adding the constant
5 to b <em>does</em> succeed, because constants are not typed.</t>
</section>

<section anchor="constants"><name>Constants</name>
<t>Constants in Go are just that --- constant. They are created at compile time,
and can only be numbers, strings, or booleans; <tt>const x = 42</tt> makes <tt>x</tt>
a constant. You can use
<em>iota</em><iref item="keywords" subitem="iota"/>  to enumerate values.</t>

<sourcecode type="go">const (
    a = iota
    b
)
</sourcecode>
<t>The first use of <tt>iota</tt> will yield 0, so <tt>a</tt> is equal to 0. Whenever <tt>iota</tt> is
used again on a new line its value is incremented with 1, so <tt>b</tt> has a value of 1.
Or, as shown here, you can even let Go repeat the use of <tt>iota</tt>. You may also
explicitly type a constant: <tt>const b string = &quot;0&quot;</tt>. Now <tt>b</tt> is a <tt>string</tt> type
constant.</t>
</section>

<section anchor="strings"><name>Strings</name>
<t>Another important built-in type is <tt>string</tt>. Assigning a string is as simple as:</t>

<sourcecode type="go">s := &quot;Hello World!&quot;
</sourcecode>
<t>Strings in Go are a sequence of UTF-8 characters enclosed in double quotes (&quot;).
If you use the single quote (') you mean one character (encoded in UTF-8) ---
which is <em>not</em> a <tt>string</tt> in Go.</t>
<t>Once assigned to a variable, the string cannot be changed: strings in Go are
immutable. If you are coming from C, note that the following is not legal in Go:</t>

<sourcecode type="go">var s string = &quot;hello&quot;
s[0] = 'c'
</sourcecode>
<t>To do this in Go you will need the following:</t>

<sourcecode type="go">s := &quot;hello&quot;
c := []rune(s)	    &lt;1&gt;
c[0] = 'c'	        &lt;2&gt;
s2 := string(c)     &lt;3&gt;
fmt.Printf(&quot;%s\n&quot;, s2) &lt;4&gt;
</sourcecode>
<t>Here we convert <tt>s</tt> to an array of runes <em>1</em>. We change the first element of
this array <em>2</em>. Then we create a <em>new</em> string <tt>s2</tt> with the alteration <em>3</em>.
Finally, we print the string with <tt>fmt.Printf</tt> <em>4</em>.</t>
</section>

<section anchor="runes"><name>Runes</name>
<t><tt>Rune</tt> is an alias for <tt>int32</tt>. It is an UTF-8 encoded code point. When is this
type useful? <iref item="runes"/> One example is when you're iterating over characters in
a string. You could loop over each byte (which is only equivalent to a character
when strings are encoded in 8-bit ASCII, which they are <em>not</em> in Go!). But to
get the actual characters you should use the <tt>rune</tt> type.</t>
</section>

<section anchor="complex-numbers"><name>Complex Numbers</name>
<t>Go has native support for complex numbers. To use them you need a variable of
type <tt>complex128</tt> (64 bit real and imaginary parts) or <tt>complex64</tt> (32 bit real
and imaginary parts). Complex numbers are written as <tt>re + im</tt><tt>i</tt>, where <tt>re</tt>
is the real part, <tt>im</tt> is the imaginary part and <tt>i</tt> is the literal '<tt>i</tt>'
(<tt>\sqrt{-1}</tt>).</t>
</section>

<section anchor="errors"><name>Errors</name>
<t>Any non-trivial program will have the need for error reporting sooner or later.
Because of this Go has a builtin type specially for errors, called <tt>error</tt>. <tt>var
e error</tt> creates a variable <tt>e</tt> of type <tt>error</tt> with the value <tt>nil</tt>. This error
type is an interface -- we'll look more at interfaces in <xref target="interfaces"></xref>. For
now you can just assume that <tt>error</tt> is a type just like all other types.</t>
</section>
</section>

<section anchor="operators-and-built-in-functions"><name>Operators and Built-in Functions</name>
<t>Go supports the normal set of numerical operators. See <xref target="tab-op-precedence"></xref>
for lists the current ones and their relative precedence. They all associate from
left to right.</t>
<table anchor="tab-op-precedence"><name>Operator precedence.</name>
<thead>
<tr>
<th>Precedence</th>
<th>Operator(s)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Highest</td>
<td>	<tt>*  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</tt></td>
</tr>

<tr>
<td></td>
<td>	`+  -</td>
</tr>

<tr>
<td></td>
<td>	<tt>==  !=  &lt;  &lt;=  &gt;  &gt;=</tt></td>
</tr>

<tr>
<td></td>
<td>	<tt>&lt;-</tt></td>
</tr>

<tr>
<td></td>
<td>	<tt>&amp;&amp;</tt></td>
</tr>

<tr>
<td>Lowest</td>
<td>	||</td>
</tr>
</tbody>
</table><t><tt>+ - * /</tt> and <tt>%</tt> all do what you would expect, <tt>&amp; | ^</tt> and <tt>&amp;^</tt> are bit
operators for bitwise <em>and</em><iref item="operators" subitem="bitwise and"/> bitwise
<em>or</em><iref item="operators" subitem="bitwise or"/> bitwise <em>xor</em><iref item="operators" subitem="bit wise xor"/> and
bit clear <iref item="operators" subitem="bitwise clear"/> respectively. The <tt>&amp;&amp;</tt> and <tt>||</tt>
operators are logical <em>and</em> <iref item="operators" subitem="and"/> and logical <em>or</em> <iref item="operators" subitem="or"/> Not listed in the table is the logical not <iref item="operators" subitem="not"/> <tt>!</tt></t>
<t>Although Go does not support operator overloading (or method overloading for
that matter), some of the built-in operators <em>are</em> overloaded. For instance, <tt>+</tt>
can be used for integers, floats, complex numbers and strings (adding strings is
concatenating them).</t>
</section>

<section anchor="go-keywords"><name>Go Keywords</name>
<t>Let's start looking at keywords, <xref target="tab-keywords"></xref> lists all the keywords in
Go.</t>
<table anchor="tab-keywords"><name>Keywords in Go.</name>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><tt>break</tt>	</td>
<td><tt>default</tt>	</td>
<td><tt>func</tt>	</td>
<td><tt>interface</tt></td>
<td><tt>select</tt></td>
</tr>

<tr>
<td><tt>case</tt>	</td>
<td><tt>defer</tt>	</td>
<td><tt>go</tt>	</td>
<td><tt>map</tt></td>
<td><tt>struct</tt></td>
</tr>

<tr>
<td><tt>chan</tt>	</td>
<td><tt>else</tt>	</td>
<td><tt>goto</tt>	</td>
<td><tt>package</tt></td>
<td><tt>switch</tt></td>
</tr>

<tr>
<td><tt>const</tt>	</td>
<td><tt>fallthrough</tt>	</td>
<td><tt>if</tt>	</td>
<td><tt>range</tt></td>
<td><tt>type</tt></td>
</tr>

<tr>
<td><tt>continue</tt>	</td>
<td><tt>for</tt>	</td>
<td><tt>import</tt>	</td>
<td><tt>return</tt></td>
<td><tt>var</tt></td>
</tr>
</tbody>
</table><t>We've seen some of these already. We used <tt>var</tt> and <tt>const</tt> in the <xref target="variables-types-and-keywords"></xref>
section,  and we briefly looked at <tt>package</tt> and <tt>import</tt> in our &quot;Hello World&quot;
program at the start of the chapter. Others need more attention and have their
own chapter or section:</t>

<ul>
<li><t><tt>func</tt> is used to declare functions and methods.</t>
</li>
<li><t><tt>return</tt> is used to return from functions. We'll look at both <tt>func</tt> and <tt>return</tt> in detail in <xref target="functions"></xref>.</t>
</li>
<li><t><tt>go</tt> is used for concurrency. We'll look at this in <xref target="channels"></xref>.</t>
</li>
<li><t><tt>select</tt> used to choose from different types of communication, We'll work with <tt>select</tt> in <xref target="channels"></xref>.</t>
</li>
<li><t><tt>interface</tt> is covered in <xref target="interfaces"></xref>.</t>
</li>
<li><t><tt>struct</tt> is used for abstract data types. We'll work with <tt>struct</tt> in <xref target="beyond-the-basics"></xref>.</t>
</li>
<li><t><tt>type</tt> is also covered in <xref target="beyond-the-basics"></xref>.</t>
</li>
</ul>
</section>

<section anchor="control-structures"><name>Control Structures</name>
<t>There are only a few control structures in Go. To write loops we use the <tt>for</tt>
keyword, and there is a <tt>switch</tt> and of course an <tt>if</tt>. When working with
channels <tt>select</tt> will be used (see <xref target="channels"></xref>). Parentheses are are not
required around the condition, and the body must <em>always</em> be brace-delimited.</t>

<section anchor="if-else"><name>If-Else</name>
<t>In Go an <tt>if</tt> <iref item="keywords" subitem="if"/> looks like this:</t>

<sourcecode type="go">if x &gt; 0 {
    return y
} else {
    return x
}
</sourcecode>
<t><iref item="keywords" subitem="return"/> <iref item="keywords" subitem="else"/> Since <tt>if</tt> and <tt>switch</tt> accept an
initialization statement, it's common to see one used to set up a (local)
variable.</t>

<sourcecode type="go">if err := SomeFunction(); err == nil {
    // do something
} else {
    return err
}
</sourcecode>
<t>It is idomatic in Go to omit the <tt>else</tt> when the <tt>if</tt> statement's body has
a <tt>break</tt>, <tt>continue</tt>, <tt>return</tt> or, <tt>goto</tt>, so the above code would be better
written as:</t>

<sourcecode type="go">if err := SomeFunction(); err != nil {
    return err
}
// do something
</sourcecode>
<t>The opening brace on the first line must be positioned on the same line as the
<tt>if</tt> statement. There is no arguing about this, because this is what <tt>gofmt</tt>
outputs.</t>
</section>

<section anchor="goto"><name>Goto</name>
<t>Go has a <tt>goto</tt> <iref item="keywords" subitem="goto"/> statement - use it wisely. With <tt>goto</tt> you
jump to a <iref item="label"/> label which must be defined within the current function.
For instance, a loop in disguise:</t>

<sourcecode type="go">func myfunc() {
    i := 0
Here:
    fmt.Println(i)
    i++
    goto Here
}
</sourcecode>
<t>The string <tt>Here:</tt> indicates a label. A label does not need to start with
a capital letter and is case sensitive.</t>
</section>

<section anchor="for"><name>For</name>
<t>The Go <tt>for</tt> <iref item="keywords" subitem="for"/> loop has three forms, only one of which has
semicolons:</t>

<ul>
<li><t><tt>for init; condition; post { }</tt> - a loop using the syntax borrowed from C;</t>
</li>
<li><t><tt>for condition { }</tt> - a while loop, and;</t>
</li>
<li><t><tt>for { }</tt> - an endless loop.</t>
</li>
</ul>
<t>Short declarations make it easy to declare the index variable right in the loop.</t>

<sourcecode type="go">sum := 0
for i := 0; i &lt; 10; i++ {
    sum = sum + i
}
</sourcecode>
<t>Note that the variable <tt>i</tt> ceases to exist after the loop.</t>
</section>

<section anchor="break-and-continue"><name>Break and Continue</name>
<t>With <tt>break</tt> <iref item="keywords" subitem="break"/> you can quit loops early.  By itself, <tt>break</tt>
breaks the current loop.</t>

<sourcecode type="go">for i := 0; i &lt; 10; i++ {
    if i &gt; 5 {
    break &lt;1&gt;
    }
    fmt.Println(i) &lt;2&gt;
}
</sourcecode>
<t>Here we <tt>break</tt> the current loop <em>1</em>, and don't continue with the
<tt>fmt.Println(i)</tt> statement <em>2</em>. So we only print 0 to 5. With loops within loop
you can specify a label after <tt>break</tt> to identify <em>which</em> loop to stop:</t>

<sourcecode type="go">J:  for j := 0; j &lt; 5; j++ { &lt;1&gt;
        for i := 0; i &lt; 10; i++ {
            if i &gt; 5 {
                break J &lt;2&gt;
            }
            fmt.Println(i)
        }
    }
</sourcecode>
<t>Here we define a label &quot;J&quot; <em>1</em>, preceding the <tt>for</tt>-loop there. When we use
<tt>break J</tt> <em>2</em>, we don't break the inner loop but the &quot;J&quot; loop.</t>
<t>With <tt>continue</tt> <iref item="keywords" subitem="continue"/> you begin the next iteration of the
loop, skipping any remaining code. In the same way as <tt>break</tt>, <tt>continue</tt> also
accepts a label.</t>
</section>

<section anchor="range"><name>Range</name>
<t>The keyword <tt>range</tt> <iref item="keywords" subitem="range"/> can be used for loops. It can loop
over slices, arrays, strings, maps and channels (see <xref target="channels"></xref>). <tt>range</tt> is an
iterator that, when called, returns the next key-value pair from the &quot;thing&quot; it
loops over. Depending on what that is, <tt>range</tt> returns different things.</t>
<t>When looping over a slice or array, <tt>range</tt> returns the index in the slice as
the key and value belonging to that index. Consider this code: <iref item="keywords" subitem="range"/></t>

<sourcecode type="go">list := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}
for k, v := range list {
    // do something with k and v
}
</sourcecode>
<t>First we create a slice of strings. Then we use <tt>range</tt> to loop over them. With
each iteration, <tt>range</tt> will return the index as an <tt>int</tt> and the key as
a <tt>string</tt>. It will start with 0 and &quot;a&quot;, so <tt>k</tt> will be 0 through 5, and v will
be &quot;a&quot; through &quot;f&quot;.</t>
<t>You can also use <tt>range</tt> on strings directly. Then it will break out the
individual Unicode characters ^[In the UTF-8 world characters are sometimes
called <em>runes</em> <iref item="runes"/> Mostly, when people talk about characters, they
mean 8 bit characters. As UTF-8 characters may be up to 32 bits the word rune is
used. In this case the type of <tt>char</tt> is <tt>rune</tt>. and their start position, by
parsing the UTF-8. The loop: <iref item="keywords" subitem="range"/></t>

<sourcecode type="go">for pos, char := range &quot;Gő!&quot; {
    fmt.Printf(&quot;character '%c' starts at byte position %d\n&quot;, char, pos)
}
</sourcecode>
<t>prints</t>

<artwork>character 'G' starts at byte position 0
character 'ő' starts at byte position 1
character '!' starts at byte position 3
</artwork>
<t>Note that <tt>ő</tt> took 2 bytes, so '!' starts at byte 3.</t>
</section>

<section anchor="switch"><name>Switch</name>
<t>Go's <tt>switch</tt> <iref item="keywords" subitem="switch"/> is very flexible; you can match on much
more than just integers. The cases are evaluated top to bottom until a match is
found, and if the <tt>switch</tt> has no expression it switches on <tt>true</tt>. It's
therefore possible -- and idiomatic -- to write an <tt>if-else-if-else</tt> chain as
a <tt>switch</tt>.</t>

<sourcecode type="go">// Convert hexadecimal character to an int value
switch { &lt;1&gt;
case '0' &lt;= c &amp;&amp; c &lt;= '9': &lt;2&gt;
    return c - '0' &lt;3&gt;
case 'a' &lt;= c &amp;&amp; c &lt;= 'f': &lt;4&gt;
    return c - 'a' + 10
case 'A' &lt;= c &amp;&amp; c &lt;= 'F': &lt;5&gt;
    return c - 'A' + 10
}
return 0
</sourcecode>
<t>A <tt>switch</tt> without a condition is the same as <tt>switch true</tt> <em>1</em>. We list the
different cases. Each <tt>case</tt> statement has a condition that is either true of
false. Here <em>2</em> we check if <tt>c</tt> is a number. If <tt>c</tt> is a number we return its
value <em>3</em>. Check if <tt>c</tt> falls between &quot;a&quot; and &quot;f&quot; <em>4</em>. For an &quot;a&quot; we
return 10, for &quot;b&quot; we return 11, etc. We also do the same <em>5</em> thing for &quot;A&quot;
to &quot;F&quot;.</t>
<t>There is no automatic fall through, you can use <tt>fallthrough</tt> <iref item="keywords" subitem="fallthrough"/> for that.</t>

<sourcecode type="go">switch i {
    case 0:  fallthrough
    case 1: &lt;1&gt;
        f()
    default:
        g() &lt;2&gt;
</sourcecode>
<t><tt>f()</tt> can be called when <tt>i == 0</tt> <em>1</em>. With <tt>default</tt> <iref item="keywords" subitem="default"/> you
can specify an action when none of the other cases match. Here <tt>g()</tt> is called
when <tt>i</tt> is not 0 or 1 <em>2</em>. We could rewrite the above example as:</t>

<sourcecode type="go">switch i {
    case 0, 1: &lt;1&gt;
        f()
    default:
        g()
</sourcecode>
<t>You can list cases on one line <em>1</em>, separated by commas.</t>
</section>
</section>

<section anchor="built-in-functions"><name>Built-in Functions</name>
<t>A few functions are predefined, meaning you <em>don't</em> have to include any package
to get access to them. <xref target="tab-predef-functions"></xref> lists them all.</t>
<table anchor="tab-predef-functions"><name>Pre-defined functions in Go.</name>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td><tt>close</tt></td>
<td><tt>new</tt></td>
<td><tt>panic</tt></td>
<td><tt>complex</tt></td>
</tr>

<tr>
<td><tt>delete</tt></td>
<td><tt>make</tt></td>
<td><tt>recover</tt></td>
<td><tt>real</tt></td>
</tr>

<tr>
<td><tt>len</tt></td>
<td><tt>append</tt></td>
<td><tt>print</tt></td>
<td><tt>imag</tt></td>
</tr>

<tr>
<td><tt>cap</tt></td>
<td><tt>copy</tt></td>
<td><tt>println</tt></td>
<td></td>
</tr>
</tbody>
</table><t>These built-in functions are documented in the <tt>builtin</tt> <iref item="package" subitem="builtin"/>
pseudo package that is included in recent Go releases. Let's go over these
functions briefly.</t>

<dl>
<dt><tt>close</tt></dt>
<dd><t>is used in channel communication. It closes a channel. We'll learn more about this in <xref target="channels"></xref>.
<iref item="built-in" subitem="close"/></t>
</dd>
<dt><tt>delete</tt></dt>
<dd><t>is used for deleting entries in maps. <iref item="built-in" subitem="delete"/></t>
</dd>
<dt><tt>len</tt> and <tt>cap</tt></dt>
<dd><t>are used on a number of different types, <tt>len</tt> is
used to return the lengths of strings, slices, and
arrays. In the next section <xref target="arrays"></xref> we'll look at slices,
arrays and the function <tt>cap</tt>.<iref item="built-in" subitem="len"/><iref item="built-in" subitem="cap"/></t>
</dd>
<dt><tt>new</tt></dt>
<dd><t>is used for allocating memory for user defined
data types. See <xref target="allocation-with-new"></xref>.
<iref item="built-in" subitem="new"/></t>
</dd>
<dt><tt>make</tt></dt>
<dd><t>is used for allocating memory for built-in
types (maps, slices, and channels). See <xref target="allocation-with-make"></xref>.
<iref item="built-in" subitem="make"/></t>
</dd>
<dt><tt>copy</tt>, <tt>append</tt></dt>
<dd><t><tt>copy</tt> is for copying slices. <iref item="built-in" subitem="copy"/>
And <tt>append</tt> is for concatenating slices. See <xref target="slices"></xref> in this chapter. <iref item="built-in" subitem="append"/></t>
</dd>
<dt><tt>panic</tt>, <tt>recover</tt></dt>
<dd><t>are used for an <em>exception</em> mechanism. See <xref target="panic-and-recovering"></xref> for more.
<iref item="built-in" subitem="panic"/>
<iref item="built-in" subitem="recover"/></t>
</dd>
<dt><tt>print</tt>, <tt>println</tt></dt>
<dd><t>are low level printing functions that can be used without reverting to the
<tt>fmt</tt> <iref item="package" subitem="fmt"/> package. These are mainly used for debugging.
<iref item="built-in" subitem="print"/>built-in,println)</t>
</dd>
<dt><tt>complex</tt>, <tt>real</tt>, <tt>imag</tt></dt>
<dd><t>all deal with complex numbers. <iref item="complex numbers"/> We will not use complex numbers in this book.
<iref item="built-in" subitem="complex"/>
<iref item="built-in" subitem="real"/>
<iref item="built-in" subitem="imag"/></t>
</dd>
</dl>
</section>

<section anchor="arrays-slices-and-maps"><name>Arrays, Slices, and Maps</name>
<t>To store multiple values in a list, you can use arrays, or their more flexible
cousin: slices. A dictionary or hash type is also available. It is called
a <tt>map</tt> in Go.</t>

<section anchor="arrays"><name>Arrays</name>
<t>An array is defined by: <tt>[n]&lt;type&gt;</tt>, where <tt>n</tt> is the length of the array and
<tt>&lt;type&gt;</tt> is the stuff you want to store. To assign or index an element in the
array, you use square brackets:</t>

<sourcecode type="go">var arr [10]int
arr[0] = 42
arr[1] = 13
fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])
</sourcecode>
<t>Array types like <tt>var arr [10]int</tt> have a fixed size. The size is <em>part</em> of the
type. They can't grow, because then they would have a different type. Also
arrays are values: Assigning one array to another <em>copies</em> all the elements. In
particular, if you pass an array to a function it will receive a copy of the
array, not a pointer to it.</t>
<t><iref item="array" subitem="multidimensional"/> To declare an array you can use the following: <tt>var
a [3]int</tt>. To initialize it to something other than zero, use a
<em>composite literal</em> <iref item="literal" subitem="composite"/> <tt>a := [3]int{1, 2, 3}</tt>. This can
 be shortened to <tt>a := [...]int{1, 2, 3}</tt>, where Go counts the elements
 automatically.</t>

<aside><t>A composite literal allows you
to assign a value directly to an array, slice, or map.
See <xref target="constructors-and-composite-literals"></xref> for more information.</t>
</aside>
<t>When declaring arrays you <em>always</em> have to type something in between the square
brackets, either a number or three dots (<tt>...</tt>), when using a composite literal.
When using multidimensional arrays, you can use the following syntax: <tt>a :=
[2][2]int{ {1,2}, {3,4} }</tt>. Now that you know about arrays you will be delighted
to learn that you will almost never use them in Go, because there is something
much more flexible: slices.</t>
</section>

<section anchor="slices"><name>Slices</name>
<t>A slice is similar to an array, but it can grow when new elements are added.
A slice always refers to an underlying array. What makes slices different from
arrays is that a slice is a pointer <em>to</em> an array; slices are reference
types.<iref item="reference types"/></t>

<aside><t>Reference types are created with <tt>make</tt>. We detail this further
in <xref target="beyond-the-basics"></xref>.</t>
</aside>
<t>That means that if you assign one slice to another, both refer to the <em>same</em>
underlying array. For instance, if a function takes a slice argument, changes it
makes to the elements of the slice will be visible to the caller, analogous to
passing a pointer to the underlying array. With: <tt>slice := make([]int, 10)</tt>, you
create a slice which can hold ten elements. Note that the underlying array isn't
specified. A slice is always coupled to an array that has a fixed size. For
slices we define a capacity <iref item="slice" subitem="capacity"/> and a length
<iref item="slice" subitem="length"/> <xref target="fig-array-vs-slice"></xref> shows the creation of an array,
then the creation of a slice. First we create an array of <tt>m</tt> elements of the
type <tt>int</tt>: <tt>var array[m]int</tt> .</t>
<t>Next, we create a slice from this array: <tt>slice := array[:n]</tt> . And now we have:</t>

<ul>
<li><t><tt>len(slice) == n</tt></t>
</li>
<li><t><tt>cap(slice) == m</tt></t>
</li>
<li><t><tt>len(array) == cap(array) == m</tt></t>
</li>
</ul>
<t anchor="fig-array-vs-slice">Array versus slice</t>
<t>Given an array, or another slice, a new slice is created via <tt>a[n:m]</tt>. This
creates a new slice which refers to the variable <tt>a</tt>, starts at index <tt>n</tt>, and
ends before index <tt>m</tt>. It has length <tt>n - m</tt>.</t>

<sourcecode type="go">a := [...]int{1, 2, 3, 4, 5} &lt;1&gt;
s1 := a[2:4] &lt;2&gt;
s2 := a[1:5] &lt;3&gt;
s3 := a[:]   &lt;4&gt;
s4 := a[:4]  &lt;5&gt;
s5 := s2[:] &lt;6&gt;
s6 := a[2:4:5] &lt;7&gt;
</sourcecode>
<t>First we define <em>1</em> an array with five elements, from index 0 to 4.
From this we create <em>2</em> a slice with the elements from index 2 to 3, this slices contains: <tt>3, 4</tt>.
Then we we create another slice <em>3</em> from <tt>a</tt>: with the elements from index 1 to 4,
this contains: <tt>2, 3, 4, 5</tt>.
With <tt>a[:]</tt> <em>4</em> we create a slice with all the elements in the array. This is a shorthand for: <tt>a[0:len(a)]</tt>.
And with <tt>a[:4]</tt> <em>5</em> we create a slice with the elements from index
0 to 3, this is short for: <tt>a[0:4]</tt>, and gives us a slices that contains: <tt>1, 2, 3, 4</tt>.
With <tt>s2[:]</tt> we create a slice from the slice <tt>s2</tt> <em>6</em>, note that <tt>s5</tt> still refers to the array <tt>a</tt>.
Finally, we create a slice with the elements from index 3 to 3 <em>and</em> also set the cap to 4 <em>7</em>.</t>
<t>When working with slices you can overrun the bounds, consider this code.</t>

<sourcecode type="go">package main

func main() {
	var array [100]int   &lt;1&gt;
	slice := array[0:99] &lt;2&gt;

	slice[98] = 1 &lt;3&gt;
	slice[99] = 2 &lt;4&gt;
}
</sourcecode>
<t>At <em>1</em> we create an array with a 100 elements, indexed from 0 to 99. Then at <em>2</em>
we create a slice that has index 0 to 98. We assign 1 to the 99th element <em>3</em> of
the slice. This works as expected. But at <em>4</em> we dare to do the impossible, and
and try to allocate something beyond the length of the slice and we are greeted
with a <em>runtime</em> error: <tt>Error: &quot;throw: index out of range&quot;.</tt></t>
<t>If you want to extend a slice, there are a couple of built-in functions that
make life easier: <tt>append</tt> and <tt>copy</tt>. The append function appends zero or more
values to a slice and returns the result: a slice with the same type as the
original. If the original slice isn't big enough to fit the added values, append
will allocate a new slice that is big enough. So the slice returned by append
may refer to a different underlying array than the original slice does. Here's
an example: <iref item="built-in" subitem="append"/></t>

<sourcecode type="go">s0 := []int{0, 0}
s1 := append(s0, 2) &lt;1&gt;
s2 := append(s1, 3, 5, 7) &lt;2&gt;
s3 := append(s2, s0...) &lt;3&gt;
</sourcecode>
<t>At <em>1</em> we append a single element, making <tt>s1</tt> equal to <tt>[]int{0, 0, 2}</tt>. At <em>2</em>
we append multiple elements, making <tt>s2</tt> equal to <tt>[]int{0, 0, 2, 3, 5, 7}</tt>. And
at <em>3</em> we append a slice, giving us <tt>s3</tt> equal to <tt>[]int{0, 0, 2, 3, 5, 7, 0, 0}</tt>.
Note the three dots used after <tt>s0...</tt>! This is needed make it clear
  explicit that you're appending another slice, instead of a single value.</t>
<t>The copy function copies slice elements from a source to a destination, and
returns the number of elements it copied. This number is the minimum of the
length of the source and the length of the destination. For example:
<iref item="built-in" subitem="copy"/></t>

<sourcecode type="go">var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
n1 := copy(s, a[0:]) &lt;1&gt;
n2 := copy(s, s[2:]) &lt;2&gt;
</sourcecode>
<t>After <em>1</em>, <tt>n1</tt> is 6, and <tt>s</tt> is <tt>[]int{0, 1, 2, 3, 4, 5}</tt>.
And after <em>2</em>, <tt>n2</tt> is 4, and <tt>s</tt> is <tt>[]int{2, 3, 4, 5, 4, 5}</tt>.</t>
</section>

<section anchor="maps"><name>Maps</name>
<t>Many other languages have a type similar to maps built-in. For instance, Perl
has hashes, Python has its dictionaries, and C++ also has maps (as part of the
libraries). In Go we have the <tt>map</tt> <iref item="keywords" subitem="map"/> type. A <tt>map</tt> can be
thought of as an array indexed by strings (in its most simple form).</t>

<sourcecode type="go">monthdays := map[string]int{
    &quot;Jan&quot;: 31, &quot;Feb&quot;: 28, &quot;Mar&quot;: 31,
    &quot;Apr&quot;: 30, &quot;May&quot;: 31, &quot;Jun&quot;: 30,
    &quot;Jul&quot;: 31, &quot;Aug&quot;: 31, &quot;Sep&quot;: 30,
    &quot;Oct&quot;: 31, &quot;Nov&quot;: 30, &quot;Dec&quot;: 31, &lt;1&gt;
}
</sourcecode>
<t>The general syntax for defining a map is <tt>map[&lt;from type&gt;]&lt;to type&gt;</tt>. Here, we
define a map that converts from a <tt>string</tt> (month abbreviation) to an <tt>int</tt>
(number of days in that month). Note that the trailing comma at <em>1</em> is
<em>required</em>.</t>
<t>Use <tt>make</tt> when only declaring a map: <tt>monthdays := make(map[string]int)</tt>. A map
is a reference type.</t>
<t>For indexing (&quot;searching&quot;) the map, we use square brackets. For example, suppose
we want to print the number of days in December: <tt>fmt.Printf(&quot;%d\n&quot;,
monthdays[&quot;Dec&quot;])</tt></t>
<t>If you are looping over an array, slice, string, or map a, <tt>range</tt> <iref item="keywords" subitem="range"/> clause will help you again, it returns the key and corresponding value
with each invocation.</t>

<sourcecode type="go">year := 0
for _, days := range monthdays &lt;1&gt;
    year += days
}
fmt.Printf(&quot;Numbers of days in a year: %d\n&quot;, year)
</sourcecode>
<t>At <em>1</em> we use the underscore to ignore (assign to nothing) the key returned by
<tt>range</tt>. We are only interested in the values from <tt>monthdays</tt>.</t>
<t><iref item="keywords" subitem="map adding elements"/></t>
<t>To add elements to the map, you would add new month with: <tt>monthdays[&quot;Undecim&quot;]
= 30</tt>. If you use a key that already exists, the value will be silently
overwritten: <tt>monthdays[&quot;Feb&quot;] = 29</tt>. To test for existence <iref item="keywords" subitem="map
existence"/> you would use the following: <tt>value, present := monthdays[&quot;Jan&quot;]</tt>.
If the key &quot;Jan&quot; exists, <tt>present</tt> will be true. It's more Go like to name
<tt>present</tt> &quot;ok&quot;, and use: <tt>v, ok := monthdays[&quot;Jan&quot;]</tt>. In Go we call this the
&quot;comma ok&quot; form.</t>
<t>You can remove elements <iref item="keywords" subitem="map remove elements"/> from the <tt>map</tt>:
<tt>delete(monthdays, &quot;Mar&quot;)</tt> . In general the
syntax <tt>delete(m, x)</tt> will delete the map entry retrieved by the expression
<tt>m[x]</tt>.</t>
</section>
</section>

<section anchor="exercises"><name>Exercises</name>

<section anchor="for-loop"><name>For-loop</name>

<ol>
<li><t>Create a loop with the <tt>for</tt> construct. Make it loop
10 times and print out the loop counter with the <tt>fmt</tt> package.</t>
</li>
<li><t>Rewrite the loop from 1 to use <tt>goto</tt>. The keyword <tt>for</tt> may not be used.</t>
</li>
<li><t>Rewrite the loop again so that it fills an array and then prints that array to the screen.</t>
</li>
</ol>
</section>

<section anchor="answer"><name>Answer</name>

<ol>
<li><t>There are many possibilities. One solution could be:</t>
</li>
</ol>

<sourcecode type="go">package main

import &quot;fmt&quot;

func main() {
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&quot;%d&quot;, i)
	}
}
</sourcecode>
<t>Let's compile this and look at the output.</t>

<artwork>    % go build for.go
    % ./for
    0
    1
    .
    .
    .
    9
</artwork>

<ol start="2">
<li><t>Rewriting the loop results in code that should look something
like this (only showing the <tt>main</tt>-function):</t>

<sourcecode type="go">func main() {
    i := 0	&lt;1&gt;
Loop:		    &lt;2&gt;
    if i &lt; 10 {
        fmt.Printf(&quot;%d\n&quot;, i)
        i++
        goto Loop &lt;3&gt;
    }
}
</sourcecode>
<t>At <em>1</em> we define our loop variable. And at <em>2</em> we define a label and at <em>3</em> we jump
to this label.</t>
</li>
<li><t>The following is one possible solution:</t>

<sourcecode type="go">package main

import &quot;fmt&quot;

func main() {
	var arr [10]int &lt;1&gt;
	for i := 0; i &lt; 10; i++ {
		arr[i] = i &lt;2&gt;
	}
	fmt.Printf(&quot;%v&quot;, arr) &lt;3&gt;
}
</sourcecode>
<t>Here <em>1</em> we create an array with 10 elements.
Which we then fill <em>2</em> one by one. And finally we print it <em>3</em> with <tt>%v</tt> which lets
Go to print the value for us. You could even do this in one fell swoop by using a composite literal:</t>
</li>
</ol>

<sourcecode type="go">fmt.Printf(&quot;%v\n&quot;, [...]int{0,1,2,3,4,5,6,7,8,9})
</sourcecode>
</section>

<section anchor="average"><name>Average</name>

<ol>
<li><t>Write code to calculate the average of a <tt>float64</tt> slice. In
a later exercise you will make it into a function.</t>
</li>
</ol>
</section>

<section anchor="answer-1"><name>Answer</name>

<ol>
<li><t>The following code calculates the average.</t>
</li>
</ol>

<sourcecode type="go">sum := 0.0
switch len(xs) {
case 0: &lt;1&gt;
    avg = 0
default: &lt;2&gt;
    for _, v := range xs {
        sum += v
    }
    avg = sum / float64(len(xs)) &lt;3&gt;
}
</sourcecode>
<t>Here at <em>1</em> we check if the length is zero and if so, we return 0.
Otherwise we calculate the average at <em>2</em>.
We have to convert the value return from <tt>len</tt> to a <tt>float64</tt>
to make the division work at <em>3</em>.</t>
</section>

<section anchor="fizzbuzz"><name>FizzBuzz</name>

<ol>
<li><t>Solve this problem, called the Fizz-Buzz <xref target="cite_fizzbuzz"></xref> problem:</t>
</li>
</ol>
<t>Write a program that prints the numbers from 1 to 100. But for multiples
of three print, &quot;Fizz&quot; instead of the number, and for multiples of
five, print &quot;Buzz&quot;. For numbers which are multiples of both three and
five, print &quot;FizzBuzz&quot;.</t>
</section>

<section anchor="answer-2"><name>Answer</name>

<ol>
<li><t>A possible solution to this problem is the following program.</t>
</li>
</ol>

<sourcecode type="go">package main

import &quot;fmt&quot;

func main() {
	const (
		FIZZ = 3 &lt;1&gt;
		BUZZ = 5
	)
	var p bool                 &lt;2&gt;
	for i := 1; i &lt; 100; i++ { &lt;3&gt;
		p = false
		if i%FIZZ == 0 { &lt;4&gt;
			fmt.Printf(&quot;Fizz&quot;)
			p = true
		}
		if i%BUZZ == 0 { &lt;5&gt;
			fmt.Printf(&quot;Buzz&quot;)
			p = true
		}
		if !p { &lt;6&gt;
			fmt.Printf(&quot;%v&quot;, i)
		}
		fmt.Println()
	}
}
</sourcecode>
<t>Here <em>1</em> we define two constants to make our code more readable, see <xref target="constants"></xref>.
At <em>2</em> we define a boolean that keeps track if we already printed something.
At <em>3</em> we start our for-loop, see <xref target="for"></xref>.
If the value is divisible by FIZZ - that is, 3 - , we print &quot;Fizz&quot; <em>4</em>.
And at <em>5</em> we check if the value is divisble by BUZZ -- that is, 5 -- if so print
&quot;Buzz&quot;. Note that we have also taken care of the FizzBuzz case.
At <em>6</em>, if printed neither Fizz nor Buzz printed, we print the value.</t>
</section>
</section>
</section>

<section anchor="functions"><name>Functions</name>
<blockquote quotedFrom="Richard P. Gabriel
"><t>I'm always delighted by the light touch and stillness of
early programming languages.  Not much text; a lot gets
done. Old programs read like quiet conversations
between a well-spoken research worker and a well-
studied mechanical colleague, not as a debate with a
compiler.  Who'd have guessed sophistication bought
such noise?</t>
</blockquote><t>Functions are the basic building blocks of Go programs; all interesting stuff
happens in them.</t>
<t>Here is an example of how you can declare a function:</t>

<sourcecode type="go">type mytype int
func (p mytype) funcname(q int) (r,s int) { return 0,0 }
&lt;1&gt;        &lt;2&gt;        &lt;3&gt;      &lt;4&gt;        &lt;5&gt;         &lt;6&gt;
</sourcecode>
<t>To declare a function, you use the <tt>func</tt> keyword <em>1</em>. You can optionally bind
<em>2</em> to a specific type called receiver <iref item="functions" subitem="receiver"/> (a function
with a receiver is usually called a method<iref item="functions" subitem="method"/>). This will
be explored in <xref target="interfaces"></xref>. Next <em>3</em> you write the name of your
function. Here <em>4</em> we define that the variable <tt>q</tt> of type <tt>int</tt> is the input
parameter. Parameters are passed <em>pass-by-value</em>.<iref item="functions" subitem="pass-by-value"/>
The variables <tt>r</tt> and <tt>s</tt> <em>5</em> are the <em>named return parameters</em> (((functions,
named return parameters))) for this function. Functions in Go can have multiple
return values. This is very useful to return a value <em>and</em> error. This
removes the need for in-band error returns (such as -1 for <tt>EOF</tt>) and modifying
an argument. If you want the return parameters not to be named you only give the
types: <tt>(int, int)</tt>. If you have only one value to return you may omit the
parentheses. If your function is a subroutine and does not have anything to
return you may omit this entirely. Finally, we have the body <em>6</em> of the
function. Note that <tt>return</tt> is a statement so the braces around the
parameter(s) are optional.</t>
<t>As said the return or result parameters of a Go function can be given names and
used as regular variables, just like the incoming parameters. When named, they
are initialized to the zero values for their types when the function begins. If
the function executes a <tt>return</tt> statement with no arguments, the current values
of the result parameters are returned. Using these features enables you (again)
to do more with less code.</t>
<t>The names are not mandatory but they can make code shorter and clearer:
<em>they are documentation</em>. However don't overuse this feature, especially in
 longer functions where it might not be immediately apparent what is returned.</t>
<t>Functions can be declared in any order you wish. The compiler scans the entire
file before execution, so function prototyping is a thing of the past in Go. Go
does not allow nested functions, but you can work around this with anonymous
functions. See the Section <xref target="functions-as-values"></xref> in this chapter. Recursive
functions work just as in other languages:</t>

<sourcecode type="go">func rec(i int) {
    if i == 10 { &lt;1&gt;
        return
    }
    rec(i+1) &lt;2&gt;
    fmt.Printf(&quot;%d &quot;, i)
}
</sourcecode>
<t>Here <em>2</em> we call the same function again, <tt>rec</tt> returns when <tt>i</tt> has the value
10, this is checked on the second line <em>1</em>. This function prints: <tt>9
8 7 6 5 4 3 2 1 0</tt>, when called as <tt>rec(0)</tt>.</t>

<section anchor="scope"><name>Scope</name>
<t>Variables declared outside any functions are <em>global</em> <iref item="scope" subitem="local"/> in Go,
those defined in functions are <em>local</em> <iref item="scope" subitem="local"/> to those functions. If
names overlap - a local variable is declared with the same name as a global one
- the local variable hides the global one when the current function is executed.</t>
<t>In the following example we call <tt>g()</tt> from <tt>f()</tt>:</t>

<sourcecode type="go">package main

var a int &lt;1&gt;

func main() {
    a = 5
    print(a)
    f()
}

func f() {
    a := 6 &lt;2&gt;
    print(a)
    g()
}

func g() {
    print(a)
}
</sourcecode>
<t>Here <em>1</em>, we declare <tt>a</tt> to be a global variable of type <tt>int</tt>. Then in the
<tt>main</tt> function we give the <em>global</em> <tt>a</tt> the value of 5, after printing it we
call the function <tt>f</tt>. Then here <em>2</em>, <tt>a := 6</tt>, we create a <em>new, local</em>
variable also called <tt>a</tt>. This new <tt>a</tt> gets the value of 6, which we then print.
Then we call <tt>g</tt>, which uses the <em>global</em> <tt>a</tt> again and prints <tt>a</tt>'s value set
in <tt>main</tt>. Thus the output will be: <tt>565</tt>. A <em>local</em> variable is <em>only</em> valid
when we are executing the function in which it is defined. Note that the <tt>:=</tt>
used in line 12 is sometimes hard to spot so it is generally advised <em>not</em> to
use the same name for global and local variables.</t>
</section>

<section anchor="functions-as-values"><name>Functions as values</name>
<t><iref item="functions" subitem="as values"/> <iref item="functions" subitem="literals"/> As with almost everything in
Go, functions are also <em>just</em> values. They can be assigned to variables as
follows:</t>

<sourcecode type="go">import &quot;fmt&quot;

func main() {
	a := func() { &lt;1&gt;
		fmt.Println(&quot;Hello&quot;)
	} &lt;2&gt;
	a() &lt;3&gt;
}
</sourcecode>
<t><tt>a</tt> is defined as an anonymous (nameless) function <em>1</em>.
Note the lack of parentheses <tt>()</tt> after <tt>a</tt>. If there were, that would be to <em>call</em>
some function with the name <tt>a</tt> before we have defined what <tt>a</tt> is. Once <tt>a</tt> is
defined, then we can <em>call</em> it, <em>3</em>.</t>
<t>Functions--as--values may be used in other places, for example maps. Here we
convert from integers to functions:</t>

<sourcecode type="go">var xs = map[int]func() int{
    1: func() int { return 10 },
    2: func() int { return 20 },
    3: func() int { return 30 },
}
</sourcecode>
<t>Note that the final comma on second to last line is <em>mandatory</em>.</t>
<t>Or you can write a function that takes a function as its parameter, for example
a <tt>Map</tt> function that works on <tt>int</tt> slices. This is left as an exercise for the
reader; see the exercise <xref target="map-function"></xref>.</t>
</section>

<section anchor="callbacks"><name>Callbacks</name>
<t>Because functions are values they are easy to pass to functions, from where they
can be used as callbacks. First define a function that does &quot;something&quot; with an
integer value:</t>

<sourcecode type="go">func printit(x int) {
    fmt.Printf(&quot;%v\n&quot;, x)
}
</sourcecode>
<t>This function does not return a value and just prints its argument. The
<em>signature</em> <iref item="functions" subitem="signature"/> of this function is: <tt>func printit(int)</tt>,
or without the function name: <tt>func(int)</tt>. To create a new function that uses
this one as a callback we need to use this signature:</t>

<sourcecode type="go">func callback(y int, f func(int)) {
    f(y)
}
</sourcecode>
<t>Here we create a new function that takes two parameters: <tt>y int</tt>, i.e. just an
<tt>int</tt> and <tt>f func(int)</tt>, i.e. a function that takes an int and returns nothing.
The parameter <tt>f</tt> is the variable holding that function. It can be used as any
other function, and we execute the function on line 2 with the parameter <tt>y</tt>:
<tt>f(y)</tt></t>
</section>

<section anchor="deferred-code"><name>Deferred Code</name>
<t>Suppose you have a function in which you open a file and perform various writes
and reads on it. In such a function there are often spots where you want to
return early. If you do that, you will need to close the file descriptor you are
working on. This often leads to the following code:</t>

<sourcecode type="go">func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    // Do your thing
    if failureX {
        file.Close() &lt;1&gt;
        return false
    }

    if failureY {
        file.Close() &lt;1&gt;
        return false
    }
    file.Close() &lt;1&gt;
    return true  &lt;2&gt;
}
</sourcecode>
<t>Note that we repeat a lot of code here; you can see the that <tt>file.Close()</tt> is
called at <em>1</em>. To overcome this, Go has the <tt>defer</tt> <iref item="keywords" subitem="defer"/>
keyword. After <tt>defer</tt> you specify a function which is called just <em>before</em> <em>2</em>
the current function exits.</t>
<t>With <tt>defer</tt> we can rewrite the above code as follows. It makes the function
more readable and it puts the <tt>Close</tt> <em>right next</em> to the <tt>Open</tt>.</t>

<sourcecode type="go">func ReadWrite() bool {
    file.Open(&quot;filename&quot;)
    defer file.Close() &lt;1&gt;
    // Do your thing
    if failureX {
        return false &lt;2&gt;
    }
    if failureY {
        return false &lt;2&gt;
    }
    return true &lt;2&gt;
}
</sourcecode>
<t>At <em>1</em> <tt>file.Close()</tt> is added to the defer list. <iref item="keywords" subitem="defer list"/>
<tt>Close</tt> is now done automatically at <em>2</em>. This makes the function shorter and
more readable. It puts the <tt>Close</tt> right next to the <tt>Open</tt>.</t>
<t>You can put multiple functions on the &quot;defer list&quot;, like this example from</t>

<sourcecode type="go">for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}
</sourcecode>
<t>Deferred functions are executed in LIFO order, so the above code prints: <tt>4
3 2 1 0</tt>.</t>
<t>With <tt>defer</tt> you can even change return values, provided that you are using
named result parameters and a function literal <iref item="functions" subitem="literal"/>, i.e:</t>

<sourcecode type="go">defer func() {/* ... */}()
</sourcecode>
<t>Here we use a function without a name and specify the body of the function
inline, basically we're creating a nameless function on the spot. The final
braces are needed because <tt>defer</tt> needs a function call, not a function value.
If our anonymous function would take an parameter it would be easier to see why
we need the braces:</t>

<sourcecode type="go">defer func(x int) {/* ... */}(5)
</sourcecode>
<t>In this (unnamed) function you can access any named return parameter:</t>

<sourcecode type="go">func f() (ret int)
    defer func() { &lt;1&gt;
        ret++
    }()
    return 0
}
</sourcecode>
<t>Here <em>1</em> we specify our function, the named return value <tt>ret</tt> is initialized
with zero. The nameless function in the defer increments the value of <tt>ret</tt>
with 1. The <tt>return 0</tt> on line
5 <em>will not be the returned value</em>, because of <tt>defer</tt>. The function <tt>f</tt> will
return 1!</t>
</section>

<section anchor="variadic-parameter"><name>Variadic Parameter</name>
<t>Functions that take a variable number of parameters are known as variadic
functions. <iref item="functions" subitem="variadic"/> To declare a function as variadic, do
something like this:</t>

<sourcecode type="go">func myfunc(arg ...int) {}
</sourcecode>
<t>The <tt>arg ...int</tt> instructs Go to see this as a function that takes a variable
number of arguments. Note that these arguments all have to have the type <tt>int</tt>.
In the body of your function the variable <tt>arg</tt> is a slice of ints:</t>

<sourcecode type="go">for _, n := range arg {
    fmt.Printf(&quot;And the number is: %d\n&quot;, n)
}
</sourcecode>
<t>We range over the arguments on the first line. We are not interested in the
index as returned by <tt>range</tt>, hence the use of the underscore there. In the body
of the <tt>range</tt> we just print the parameters we were given.</t>
<t>If you don't specify the type of the variadic argument it defaults to the empty
interface <tt>interface{}</tt> (see Chapter <xref target="interfaces"></xref>).</t>
<t>Suppose we have another variadic function called <tt>myfunc2</tt>, the following
example shows how to pass variadic arguments to it:</t>

<sourcecode type="go">func myfunc(arg ...int) {
    myfunc2(arg...)
    myfunc2(arg[:2]...)
}
</sourcecode>
<t>With <tt>myfunc2(arg...)</tt> we pass all the parameters to <tt>myfunc2</tt>, but because the
variadic parameters is just a slice, we can use some slice tricks as well.</t>
</section>

<section anchor="panic-and-recovering"><name>Panic and recovering</name>
<t>Go does not have an exception mechanism: you cannot throw exceptions. Instead it
uses a panic-and-recover mechanism. It is worth remembering that you should use
this as a last resort, your code will not look, or be, better if it is littered
with panics. It's a powerful tool: use it wisely. So, how do you use it? In the
words of the Go Authors <xref target="go_blog_panic"></xref>:</t>

<dl>
<dt>Panic</dt>
<dd><t>is a built-in function that stops the ordinary flow of control and begins
panicking. When the function <tt>F</tt> calls <tt>panic</tt>, execution of <tt>F</tt> stops, any
deferred functions in <tt>F</tt> are executed normally, and then <tt>F</tt> returns to its
caller. To the caller, <tt>F</tt> then behaves like a call to <tt>panic</tt>. The process
continues up the stack until all functions in the current goroutine have
returned, at which point the program crashes. Panics can be initiated by
invoking <tt>panic</tt> directly. They can also be caused by <em>runtime errors</em>, such as
out-of-bounds array accesses.</t>
</dd>
<dt>Recover</dt>
<dd><t>is a built-in function that regains control of a panicking goroutine.
Recover is <em>only</em> useful inside <em>deferred</em> functions. During normal execution,
a call to <tt>recover</tt> will return <tt>nil</tt> and have no other effect. If the current
goroutine is panicking, a call to <tt>recover</tt> will capture the value given to
<tt>panic</tt> and resume normal execution.</t>
</dd>
</dl>
<t>This function checks if the function it gets as argument will panic when it is
executed:</t>

<sourcecode type="go">func Panic(f func()) (b bool) { &lt;1&gt;
    defer func() { &lt;2&gt;
        if x := recover(); x != nil {
            b = true
        }
    }()
    f() &lt;3&gt;
    return &lt;4&gt;
}
</sourcecode>
<t>We define a new function <tt>Panic</tt> <em>1</em> that takes a function as an argument (see
<xref target="functions-as-values"></xref>). It returns true if <tt>f</tt> panics when run, else false. We
then <em>2</em> define a <tt>defer</tt> function that utilizes <tt>recover</tt>. If the current
goroutine panics, this defer function will notice that. If <tt>recover()</tt> returns
non-<tt>nil</tt> we set <tt>b</tt> to true. At <em>3</em> Execute the function we received as the
argument. And finally <em>4</em> we return the value of <tt>b</tt>. Because <tt>b</tt> is a named
return parameter.</t>
<t>The following code fragment, shows how we can use this function:</t>

<sourcecode type="go">func panicy() {
    var a []int
    a[3] = 5
}

func main() {
    fmt.Println(Panic(panicy))
}
</sourcecode>
<t>On line 3 the <tt>a[3] = 5</tt> triggers a <em>runtime</em> out of bounds error which results
in a panic. Thus this program will print <tt>true</tt>. If we change line 2: <tt>var
a []int</tt> to <tt>var a [4]int</tt> the function <tt>panicy</tt> does not panic anymore. Why?</t>
</section>

<section anchor="exercises-1"><name>Exercises</name>

<section anchor="average-1"><name>Average</name>

<ol>
<li><t>Write a function that calculates the average of a <tt>float64</tt> slice.</t>
</li>
</ol>
</section>

<section anchor="answer-3"><name>Answer</name>

<ol>
<li><t>The following function calculates the average:</t>
</li>
</ol>

<sourcecode type="go">package main

func average(xs []float64) (avg float64) { //&lt;1&gt;
	sum := 0.0
	switch len(xs) {
	case 0:                 //&lt;2&gt;
		avg = 0
	default:                //&lt;3&gt;
		for _, v := range xs {
			sum += v
		}
		avg = sum / float64(len(xs)) //&lt;4&gt;
	}
	return  //&lt;5&gt;
}
</sourcecode>
<t>At <em>1</em> we use a named return parameter.  If the length of <tt>xs</tt> is zero <em>2</em>, we
 return 0.  Otherwise <em>3</em>, we calculate the average.  At <em>4</em>  we convert the
 value to a <tt>float64</tt> to make the division work as <tt>len</tt> returns an <tt>int</tt>.
 Finally, at <em>5</em> we reutrn our avarage.</t>
</section>

<section anchor="bubble-sort"><name>Bubble sort</name>

<ol>
<li><t>Write a function that performs a bubble sort on a slice of ints. From <xref target="bubblesort"></xref>:</t>
</li>
</ol>
<blockquote><t>It works by repeatedly stepping through the list to be sorted, comparing each
pair of adjacent items and swapping them if they are in the wrong order. The
pass through the list is repeated until no swaps are needed, which indicates
that the list is sorted. The algorithm gets its name from the way smaller
elements &quot;bubble&quot; to the top of the list.</t>
</blockquote><t>It also gives an example in pseudo code:</t>

<artwork>procedure bubbleSort( A : list of sortable items )
  do
    swapped = false
    for each i in 1 to length(A) - 1 inclusive do:
      if A[i-1] &gt; A[i] then
        swap( A[i-1], A[i] )
        swapped = true
      end if
    end for
  while swapped
end procedure
</artwork>
</section>

<section anchor="answer-4"><name>Answer</name>

<ol>
<li><t>Bubble sort isn't terribly efficient. For <tt>n</tt> elements it scales <tt>O(n^2)</tt>.
But bubble sort is easy to implement:</t>

<sourcecode type="go">
func main() {
	n := []int{5, -1, 0, 12, 3, 5}
	fmt.Printf(&quot;unsorted %v\n&quot;, n)
	bubblesort(n)
	fmt.Printf(&quot;sorted %v\n&quot;, n)
}

func bubblesort(n []int) {
	for i := 0; i &lt; len(n)-1; i++ {
		for j := i + 1; j &lt; len(n); j++ {
			if n[j] &lt; n[i] {
				n[i], n[j] = n[j], n[i]
			}
</sourcecode>
<t>Because a slice is a reference type, the <tt>bubblesort</tt> function works and
does not need to return a sorted slice.</t>
</li>
</ol>
</section>

<section anchor="for-loop-ii"><name>For-loop II</name>

<ol>
<li><t>Take what you did in exercise to write the for loop and extend it a bit.
Put the body of the for loop - the <tt>fmt.Printf</tt> - in a separate function.</t>
</li>
</ol>
</section>

<section anchor="answer-5"><name>Answer</name>
<t>1.
 &lt;{{src/for-func.go}}</t>
</section>

<section anchor="fibonacci"><name>Fibonacci</name>

<ol>
<li><t>The Fibonacci sequence starts as follows: <tt>1, 1, 2, 3, 5, 8, 13, \ldots</tt>
Or in mathematical terms: <tt>x_1 = 1; x_2 = 1; x_n = x_{n-1} + x_{n-2}\quad\forall n &gt; 2</tt>.</t>
<t>Write a function that takes an <tt>int</tt> value and gives
that many terms of the Fibonacci sequence.</t>
</li>
</ol>
</section>

<section anchor="answer-6"><name>Answer</name>

<ol>
<li><t>The following program calculates Fibonacci numbers:</t>
</li>
</ol>

<sourcecode type="go">package main

import &quot;fmt&quot;

func fibonacci(value int) []int {
	x := make([]int, value) &lt;1&gt;
	x[0], x[1] = 1, 1       &lt;2&gt;
	for n := 2; n &lt; value; n++ {
		x[n] = x[n-1] + x[n-2] &lt;3&gt;
	}
	return x &lt;4&gt;
}

func main() {
	for _, term := range fibonacci(10) { &lt;5&gt;
		fmt.Printf(&quot;%v &quot;, term)
	}
}
</sourcecode>
<t>At <em>1</em> we create an array to hold the integers up to the value given in
the function call.  At <em>2</em> we start the Fibonacci calculation. Then <em>3</em>:
<tt>x_n = x_{n-1} + x_{n-2}</tt>.  At <em>4</em> we return the <em>entire</em> array.
And at <em>5</em> we use the <tt>range</tt> keyword to  &quot;walk&quot; the numbers returned by the
Fibonacci function. Here up to 10. Finally, we print the numbers.</t>
</section>

<section anchor="var-args"><name>Var args</name>

<ol>
<li><t>Write a function that takes a variable number of ints and print each integer on a separate line.</t>
</li>
</ol>
</section>

<section anchor="answer-7"><name>Answer</name>

<ol>
<li><t>For this we need the <tt>{...}</tt>-syntax to signal we define a
function that takes an arbitrary number of arguments.</t>

<sourcecode type="go">package main

import &quot;fmt&quot;

func main() {
	printthem(1, 4, 5, 7, 4)
	printthem(1, 2, 4)
}

func printthem(numbers ...int) {
	for _, d := range numbers {
		fmt.Printf(&quot;%d\n&quot;, d)
	}
}
</sourcecode>
</li>
</ol>
</section>

<section anchor="functions-that-return-functions"><name>Functions that return functions</name>

<ol>
<li><t>Write a function that returns a function that performs a <tt>+2</tt> on integers. Name the function <tt>plusTwo</tt>.
You should then be able do the following:</t>

<sourcecode type="go">p := plusTwo()
fmt.Printf(&quot;%v\n&quot;, p(2))
</sourcecode>
<t>Which should print 4. See <xref target="callbacks"></xref>.</t>
</li>
<li><t>Generalize the function from above and create a <tt>plusX(x)</tt> which returns functions that add <tt>x</tt> to an integer.</t>
</li>
</ol>
</section>

<section anchor="answer-8"><name>Answer</name>

<ol>
<li><t>Define a new function that returns a function: <tt>return func(x int) int { return x + 2 }</tt>
Function literals at work, we define the +2--function right there in the return statement.</t>

<sourcecode type="go">func main() {
   p2 := plusTwo()
   fmt.Printf(&quot;%v\n&quot;,p2(2))
}


func plusTwo() func(int) int { &lt;1&gt;
    return func(x int) int { return x + 2 } &lt;2&gt;
}
</sourcecode>
</li>
<li><t>Here we use a closure:</t>

<sourcecode type="go">func plusX(x int) func(int) int { &lt;1&gt;
   return func(y int) int { return x + y } &lt;2&gt;
}
</sourcecode>
<t>Here <em>1</em>, we again define a function that returns a function.
We use the <em>local</em> variable <tt>x</tt> in the function literal at <em>2</em>.</t>
</li>
</ol>
</section>

<section anchor="maximum"><name>Maximum</name>

<ol>
<li><t>Write a function that finds the
maximum value in an <tt>int</tt> slice (<tt>[]int</tt>).</t>
</li>
</ol>
</section>

<section anchor="answer-9"><name>Answer</name>

<ol>
<li><t>This function returns the largest int in the slice \var{l}:</t>

<sourcecode type="go">func max(l []int) (max int) {   &lt;1&gt;
    max = l[0]
    for _, v := range l {   &lt;2&gt;
        if v &gt; max {    &lt;3&gt;
            max = v
        }
    }
    return &lt;4&gt;
}
</sourcecode>
<t>At <em>1</em> we use a named return parameter.
At <em>2</em> we loop over <tt>l</tt>. The index of the element is not important.
At <em>3</em>, if we find a new maximum, we remember it.
And at <em>4</em> we have a &quot;lone&quot; return; the current value of <tt>max</tt> is now returned.</t>
</li>
</ol>
</section>

<section anchor="map-function"><name>Map function</name>
<t>A <tt>map()</tt>-function is a function that takes
a function and a list. The function is applied to
each member in the list and a new list containing
these calculated values is returned.
Thus:</t>
<t><tt> \mathrm{map}(f(), (a_1,a_2,\ldots,a_{n-1},a_n)) =  (f(a_1), f(a_2),\ldots,f(a_{n-1}), f(a_n)) </tt></t>

<ol>
<li><t>Write a simple
<tt>map()</tt>-function in Go. It is sufficient for this function only to work for ints.</t>
</li>
</ol>
</section>

<section anchor="answer-10"><name>Answer</name>

<ol>
<li><t>A possible answer:</t>

<sourcecode type="go">func Map(f func(int) int, l []int) []int {
    j := make([]int, len(l))
    for k, v := range l {
        j[k] = f(v)
    }
    return j
}


func main() {
    m := []int{1, 3, 4}
    f := func(i int) int {
        return i * i
    }
    fmt.Printf(&quot;%v&quot;, (Map(f, m)))
}
</sourcecode>
</li>
</ol>
</section>

<section anchor="stack"><name>Stack</name>

<ol>
<li><t>Create a simple stack which can hold a
fixed number of ints. It does not have to grow beyond this limit.
Define <tt>push</tt> -- put something on the stack -- and <tt>pop</tt>
-- retrieve something from the stack -- functions. The stack should be
a LIFO (last in, first out) stack.</t>
</li>
</ol>
<t>A stack</t>

<ol start="2">
<li><t>Write a <tt>String</tt> method which
converts the stack to a string representation.
The stack in the figure could be represented as: <tt>[0:m] [1:l] [2:k]</tt> .</t>
</li>
</ol>
</section>

<section anchor="answer-11"><name>Answer</name>

<ol>
<li><t>First we define a new type that represents a stack; we need an
array (to hold the keys) and an index, which points to the last element.
Our small stack can only hold 10 elements.</t>

<sourcecode type="go">type stack struct {
    i    int
    data [10]int
}
</sourcecode>
</li>
</ol>
<t>Next we need the <tt>push</tt> and <tt>pop</tt> functions to actually
use the thing. First we show the <em>wrong</em> solution!</t>
<t>In Go, data passed to functions is <em>passed-by-value</em> meaning a copy
is created and given to the function. The first stab for the function
<tt>push</tt> could be:</t>

<sourcecode type="go">func (s stack) push(k int) {
    if s.i+1 &gt; 9 {
            return
    }
    s.data[s.i] = k
    s.i++
}
</sourcecode>
<t>The function works on the <tt>s</tt> which is of the type <tt>stack</tt>. To
use this we just call <tt>s.push(50)</tt>, to push the integer 50 on
the stack. But the push function gets a copy of <tt>s</tt>, so it is
<em>not</em> working on the <em>real</em> thing. Nothing gets pushed to our
stack. For example the following code:</t>

<sourcecode type="go">var s stack
s.push(25)
fmt.Printf(&quot;stack %v\n&quot;, s);
s.push(14)
fmt.Printf(&quot;stack %v\n&quot;, s);
</sourcecode>
<t>prints:</t>

<artwork>stack [0:0]
stack [0:0]
</artwork>
<t>To solve this we need to give the function <tt>push</tt> a pointer
to the stack. This means we need to change <tt>push</tt> from</t>

<sourcecode type="go">func (s stack) push(k int)
</sourcecode>
<t>to</t>

<sourcecode type="go">func (s *stack) push(k int).
</sourcecode>
<t>We should now use <tt>new()</tt> (see <xref target="allocation-with-new"></xref>).
in <xref target="beyond-the-basics"></xref> to create a <em>pointer</em> to a newly
allocated <tt>stack</tt>, so line 1 from the example above needs to be
<tt>s := new(stack)</tt> .</t>
<t>And our two functions become:</t>

<sourcecode type="go">func (s *stack) push(k int) {
    s.data[s.i] = k
    s.i++
}

func (s *stack) pop() int {
    s.i--
    ret := s.data[s.i]
    s.data[s.i] = 0
    return ret
}
</sourcecode>
<t>Which we then use as follows:</t>

<sourcecode type="go">func main() {
    var s stack
    s.push(25)
    s.push(14)
    fmt.Printf(&quot;stack %v\n&quot;, s)
}
</sourcecode>

<ol start="2">
<li><t><tt>fmt.Printf(&quot;%v&quot;)</tt> can
print any value (<tt>%v</tt>) that satisfies the <tt>Stringer</tt> interface
(see <xref target="interfaces"></xref>).
For this to work we only need to define a <tt>String()</tt> function for
our type:</t>

<sourcecode type="go">func (s stack) String() string {
    var str string
    for i := 0; i &lt;= s.i; i++ {
        str = str + &quot;[&quot; +
            strconv.Itoa(i) + &quot;:&quot; + strconv.Itoa(s.data[i]) + &quot;]&quot;
    }
    return str
}
</sourcecode>
</li>
</ol>
</section>
</section>
</section>

<section anchor="packages"><name>Packages</name>
<blockquote quotedFrom="Answer to whether there is a bit wise negation operator -- Ken Thompson
"><t>&quot;<sup>"</sup></t>
</blockquote><t>A package is a collection of functions and data.</t>
<t>You declare a package with the <tt>package</tt><iref item="keywords" subitem="package"/> keyword. The
filename does not have to match the package name. The convention for package
names is to use lowercase characters. Go packages may consist of multiple files,
but they share the <tt>package &lt;name&gt;</tt> line. Let's define a package <tt>even</tt> in the
file <tt>even.go</tt>.</t>
<t><iref item="functions" subitem="exported"/>
<iref item="functions" subitem="private"/>
<iref item="functions" subitem="public"/></t>

<sourcecode type="go">package even &lt;1&gt;

func Even(i int) bool { &lt;2&gt;
	return i%2 == 0
}

func odd(i int) bool { &lt;3&gt;
	return i%2 == 1
}
</sourcecode>
<t>Here <em>1</em> we start a new namespace: &quot;even&quot;. The function <tt>Even</tt> <em>2</em> starts with
a capital letter. This means the function is <em>exported</em>, and may be used outside
our package (more on that later). The function <tt>odd</tt> <em>3</em> does not start with
a capital letter, so it is a <em>private</em> function.</t>
<t>Now we just need to build the package. We create a directory under <tt>$GOPATH</tt>,
and copy <tt>even.go</tt> there (see <xref target="compiling-and-running-code"></xref> in <xref target="basics"></xref>).</t>

<artwork>% mkdir $GOPATH/src/even
% cp even.go $GOPATH/src/even
% go build
% go install
</artwork>
<t>Now we can use the package in our own program <tt>myeven.go</tt>:</t>

<sourcecode type="go">package main

import ( &lt;1&gt;
	&quot;even&quot; &lt;2&gt;
	&quot;fmt&quot;  &lt;3&gt;
)

func main() {
	i := 5
	fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.Even(i)) &lt;4&gt;
}
</sourcecode>
<t>Import <em>1</em> the following packages. The <em>local</em> package <tt>even</tt> is imported here
<em>2</em>. This <em>3</em> imports the official <tt>fmt</tt> package. And now we use <em>4</em> the
function from the <tt>even</tt> package. The syntax for accessing a function from
a package is <tt>&lt;package&gt;.FunctionName()</tt>. And finally we can build our program.</t>

<artwork>% go build myeven.go
% ./myeven
Is 5 even? false
</artwork>
<t>If we change our <tt>myeven.go</tt> at <em>4</em> to use the unexported function <tt>even.odd</tt>:
<tt>fmt.Printf(&quot;Is %d even? %v\n&quot;, i, even.odd(i))</tt> We get an error when compiling,
because we are trying to use a
<em>private</em> function:</t>

<artwork>myeven.go: cannot refer to unexported name even.odd
</artwork>
<t>Note that the &quot;starts with capital <tt>\rightarrow</tt> exported&quot;, &quot;starts with
lower-case <tt>\rightarrow</tt> private&quot; rule also extends to other names (new
types, global variables) defined in the package. Note that the term &quot;capital&quot; is
not limited to US-ASCII -- it extends to all bicameral alphabets (Latin, Greek,
Cyrillic, Armenian and Coptic).</t>

<section anchor="identifiers"><name>Identifiers</name>
<t>The Go standard library names some function with the old (Unix) names while
others are in CamelCase. The convention is to leave well-known legacy
not-quite-words alone rather than try to figure out where the capital letters
go:  <tt>Atoi</tt>, <tt>Getwd</tt>, <tt>Chmod</tt>. CamelCasing works best when you have whole words
to work with: <tt>ReadFile</tt>, <tt>NewWriter</tt>, <tt>MakeSlice</tt>. The convention in Go is to
use CamelCase rather than underscores to write multi-word names.</t>
<t>As we did above in our <tt>myeven</tt> program, accessing content from an imported
(with <tt>import</tt> <iref item="keywords" subitem="import"/>) package is done with using the package's
name and then a dot.  After <iref item="package" subitem="bytes"/> <tt>import &quot;bytes&quot;</tt> the importing
program can talk about <tt>bytes.Buffer</tt>. A package name should be good, short,
concise and evocative. The convention in Go is that package names are lowercase,
single word names.</t>
<t>The package name used in the <tt>import</tt> statement is the default name used. But if
the need arises (two different packages with the same name for instance), you
can override this default: <tt>import bar &quot;bytes&quot;</tt> The function <tt>Buffer</tt> is now
accessed as <tt>bar.Buffer</tt>.</t>
<t>Another convention is that the package name is the base name of its source
directory; the package in <tt>src/compress/gzip</tt> is imported as <tt>compress/gzip</tt> but
has name <tt>gzip</tt>, not <tt>compress/gzip</tt>.</t>
<t>It is important to avoid stuttering when naming things. For instance, the
buffered reader type in the <tt>bufio</tt> <iref item="package" subitem="bufio"/> package is called
<tt>Reader</tt>, not <tt>BufReader</tt>, because users see it as <tt>bufio.Reader</tt>, which is
a clear, concise name.</t>
<t>Similarly, the function to make new instances of <tt>ring.Ring</tt> (package
<tt>container/ring</tt>), would normally be called <tt>NewRing</tt>, but since <tt>Ring</tt> is the
only type exported by the package, and since the package is called
<tt>ring</tt><iref item="package" subitem="ring"/>, it's called just <tt>New</tt>. Clients of the package see
that as <tt>ring.New</tt>. Use the package structure to help you choose good names.</t>
<t>Another short example is <tt>once.Do</tt> (see package <tt>sync</tt>); <tt>once.Do(setup)</tt> reads
well and would not be improved by writing <tt>once.DoOrWaitUntilDone(setup)</tt>. Long
names don't automatically make things more readable.</t>
</section>

<section anchor="documenting-packages"><name>Documenting packages</name>
<t>When we created our <tt>even</tt> package, we skipped over an important item:
documentation. Each package should have a <em>package comment</em>, a block comment
preceding the <tt>package</tt> clause. In our case we should extend the beginning of
the package, with:</t>

<sourcecode type="go">// The even package implements a fast function for detecting if an integer
// is even or not.
package even
</sourcecode>
<t>When running <tt>go doc</tt> this will show up at the top of the page. When a package
consists of multiple files the package comment should only appear in one
file. A common convention (in really big packages) is to have a separate
<tt>doc.go</tt> that only holds the package comment. Here is a snippet from the
official <tt>regexp</tt> package:</t>

<sourcecode type="go">/*
    The regexp package implements a simple library for
    regular expressions.

    The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
*/
package regexp
</sourcecode>
<t>Each defined (and exported) function should have a small line of text
documenting the behavior of the function. Again to extend our <tt>even</tt> package:</t>

<sourcecode type="go">// Even returns true of i is even. Otherwise false is returned.
func Even(i int) bool {
</sourcecode>
<t>And even though <tt>odd</tt> is not exported, it's good form to document it as well.</t>

<sourcecode type="go">// odd is the opposite of Even.
func odd(i int) bool {
</sourcecode>
</section>

<section anchor="testing-packages"><name>Testing packages</name>
<t>In Go it is customary to write (unit) tests for your package. Writing tests
involves the <tt>testing</tt> package and the program <tt>go test</tt><iref item="tooling" subitem="go test"/>.
Both have excellent documentation.</t>
<t>The <tt>go test</tt> program runs all the test functions. Without any defined tests for
our <tt>even</tt> package, <tt>go test</tt> yields:</t>

<artwork>% go test
?       even    [no test files]
</artwork>
<t>Let us fix this by defining a test in a test file. Test files reside in the
package directory and are named <tt>*_test.go</tt>. Those test files are just like
other Go programs, but <tt>go test</tt> will only execute the test functions. Each test
function has the same signature and its name should start with
<tt>Test</tt>: <tt>func TestXxx(t *testing.T)</tt> .</t>
<t>When writing test you will need to tell <tt>go test</tt> whether a test was
successful or not. A successful test function just returns. When
the test fails you can signal this with the following
functions. These are the most important ones (see <tt>go doc testing</tt> or <tt>go help testfunc</tt> for more):</t>

<ul>
<li><t><tt>func (t *T) Fail()</tt>, <tt>Fail</tt> marks the test function as having failed but
continues execution.</t>
</li>
<li><t><tt>func (t *T) FailNow()</tt>, <tt>FailNow</tt> marks the test function as having failed
and stops its execution. Any remaining tests in this file are skipped, and
execution continues with the next test.</t>
</li>
<li><t><tt>func (t *T) Log(args ...interface{})</tt>, <tt>Log</tt> formats its arguments using
default formatting, analogous to <tt>Print()</tt>, and records the text in the error
log.</t>
</li>
<li><t><tt>func (t *T) Fatal(args ...interface{})</tt>, <tt>Fatal</tt> is equivalent to <tt>Log()</tt>
followed by <tt>FailNow()</tt>.</t>
</li>
</ul>
<t>Putting all this together we can write our test. First we pick a name:
<tt>even_test.go</tt>. Then we add the following contents:</t>

<sourcecode type="go">package even &lt;1&gt;

import &quot;testing&quot; &lt;2&gt;

func TestEven(t *testing.T) { &lt;3&gt;
	if !Even(2) {
		t.Log(&quot;2 should be even!&quot;)
		t.Fail()
	}
}
</sourcecode>
<t>A test file belongs to the current <em>1</em> package. This is not only convenient, but
also allows tests of unexported functions and structures. We then <em>2</em> import the
<tt>testing</tt> package. And finally the test we want to execute. The code here <em>3</em>
should hold no surprises: we check if the <tt>Even</tt> function works OK. And now, the
moment we have been waiting form executing the test.</t>

<artwork>% go test
ok      even    0.001s
</artwork>
<t>Our test ran and reported <tt>ok</tt>. Success! If we redefine our test function, we
can see the result of a failed test:</t>

<sourcecode type="go">// Entering the twilight zone
func TestEven(t *testing.T) {
    if Even(2) {
        t.Log(&quot;2 should be odd!&quot;)
        t.Fail()
    }
}
</sourcecode>
<t>We now get:</t>

<artwork>FAIL    even    0.004s
--- FAIL: TestEven (0.00 seconds)
    2 should be odd!
FAIL
</artwork>
<t>And you can act accordingly (by fixing the test for instance).</t>
<t>Writing new packages should go hand in hand with writing (some)
documentation and test functions. It will make your code better and it
shows that you really put in the effort.</t>
<t>The Go test suite also allows you to incorporate example functions which serve
as documentation <em>and</em> as tests. These functions need to start with <tt>Example</tt>.</t>

<sourcecode type="go">func ExampleEven() {
    if Even(2) {
        fmt.Printf(&quot;Is even\n&quot;)
    }
    // Output: &lt;1&gt;
    // Is even
}
</sourcecode>
<t>Those last two comments lines <em>1</em> are part of the example, <tt>go test</tt> uses those
to check the <em>generated</em> output with the text in the comments. If there is
a mismatch the test fails.</t>
</section>

<section anchor="useful-packages"><name>Useful packages</name>
<t>The standard libary of Go includes a huge number of packages. It is very
enlightening to browse the <tt>$GOROOT/src/pkg</tt> directory and look at the
packages. We cannot comment on each package, but the following are worth
a mention: </t>

<dl>
<dt><tt>fmt</tt></dt>
<dd><t><iref item="package" subitem="fmt"/>
Package <tt>fmt</tt> implements formatted I/O with functions analogous
to C's <tt>printf</tt> and <tt>scanf</tt>. The format verbs are derived
from C's but are simpler. Some verbs (%-sequences) that can be used:</t>

<ul>
<li><t><em>%v</em>, the value in a default format. when printing structs, the plus flag (%+v) adds field names.</t>
</li>
<li><t><em>%#v</em>, a Go-syntax representation of the value.</t>
</li>
<li><t><em>%T</em>, a Go-syntax representation of the type of the value.</t>
</li>
</ul></dd>
<dt><tt>io</tt></dt>
<dd><t><iref item="package" subitem="io"/>
This package provides basic interfaces to I/O primitives.
Its primary job is to wrap existing implementations of such primitives,
such as those in package os, into shared public interfaces that
abstract the functionality, plus some other related primitives.</t>
</dd>
<dt><tt>bufio</tt></dt>
<dd><t><iref item="package" subitem="bufio"/>
This package implements buffered I/O.  It wraps an
<tt>io.Reader</tt>
or
<tt>io.Writer</tt>
object, creating another object (Reader or Writer) that also implements
the interface but provides buffering and some help for textual I/O.</t>
</dd>
<dt><tt>sort</tt></dt>
<dd><t><iref item="package" subitem="sort"/>
The <tt>sort</tt> package provides primitives for sorting arrays
and user-defined collections.</t>
</dd>
<dt><tt>strconv</tt></dt>
<dd><t><iref item="package" subitem="strconv"/>
The <tt>strconv</tt> package implements conversions to and from
string representations of basic data types.</t>
</dd>
<dt><tt>os</tt></dt>
<dd><t><iref item="package" subitem="os"/>
The <tt>os</tt> package provides a platform-independent interface to operating
system functionality.  The design is Unix-like.</t>
</dd>
<dt><tt>sync</tt></dt>
<dd><t><iref item="package" subitem="sync"/>
The package <tt>sync</tt> provides basic synchronization primitives such as mutual
exclusion locks.</t>
</dd>
<dt><tt>flag</tt></dt>
<dd><t><iref item="package" subitem="flag"/>
The <tt>flag</tt> package implements command-line flag parsing.</t>
</dd>
<dt><tt>encoding/json</tt></dt>
<dd><t><iref item="package" subitem="encoding/json"/>
The <tt>encoding/json</tt> package implements encoding and decoding of JSON objects as
defined in RFC 4627 <xref target="RFC4627"></xref>.</t>
</dd>
<dt><tt>html/template</tt></dt>
<dd><t><iref item="package" subitem="html/template"/>
Data-driven templates for generating textual output such as HTML.</t>
<t>Templates are executed by applying them to a data structure.  Annotations in
the template refer to elements of the data structure (typically a field of
a struct or a key in a map) to control execution and derive values to be
displayed.  The template walks the structure as it executes and the &quot;cursor&quot;
@ represents the value at the current location in the structure.</t>
</dd>
<dt><tt>net/http</tt></dt>
<dd><t><iref item="package" subitem="net/http"/>
The <tt>net/http</tt> package implements parsing of HTTP requests, replies,
and URLs and provides an extensible HTTP server and a basic
HTTP client.</t>
</dd>
<dt><tt>unsafe</tt></dt>
<dd><t><iref item="package" subitem="unsafe"/>
The <tt>unsafe</tt> package contains operations that step around the type safety of Go programs.
Normally you don't need this package, but it is worth mentioning that <em>unsafe</em> Go programs
are possible.</t>
</dd>
<dt><tt>reflect</tt></dt>
<dd><t><iref item="package" subitem="reflect"/>
The <tt>reflect</tt> package implements run-time reflection, allowing a program to
manipulate objects with arbitrary types.  The typical use is to take a
value with static type <tt>interface{}</tt> and extract its dynamic type
information by calling <tt>TypeOf</tt>, which returns an object with interface
type <tt>Type</tt>. See <xref target="interfaces"></xref>, Section <xref target="introspection-and-reflection"></xref>.</t>
</dd>
<dt><tt>os/exec</tt></dt>
<dd><t><iref item="package" subitem="os/exec"/> The <tt>os/exec</tt> package runs external commands.</t>
</dd>
</dl>
</section>

<section anchor="exercises-2"><name>Exercises</name>

<section anchor="stack-as-package"><name>Stack as package</name>

<ol>
<li><t>See the Stack exercise. In this exercise we want to create a separate package
for that code. Create a proper package for your stack implementation, <tt>Push</tt>,
<tt>Pop</tt> and the <tt>Stack</tt> type need to be exported.</t>
</li>
<li><t>Write a simple unit test for this package.
You should at least test that a <tt>Pop</tt> works after a <tt>Push</tt>.</t>
</li>
</ol>
</section>

<section anchor="answer-12"><name>Answer</name>

<ol>
<li><t>There are a few details that should be changed to make a proper package
for our stack. First, the exported functions should begin with a capital
letter and so should <tt>Stack</tt>. The package file is named <tt>stack-as-package.go</tt>
and contains:</t>

<sourcecode type="go">package stack

// Stack holds the items.
type Stack struct {
	i    int
	data [10]int
}

// Push pushes an item on the stack.
func (s *Stack) Push(k int) {
	s.data[s.i] = k
	s.i++
}

// Pop pops an item from the stack.
func (s *Stack) Pop() (ret int) {
	s.i--
	ret = s.data[s.i]
	return
}
</sourcecode>
</li>
<li><t>To make the unit testing work properly you need to do some
preparations. We'll come to those in a minute. First the actual unit test.
Create a file with the name <tt>pushpop_test.go</tt>, with the following contents:</t>
</li>
</ol>

<sourcecode type="go">package stack

import &quot;testing&quot;

func TestPushPop(t *testing.T) {
	c := new(Stack)
	c.Push(5)
	if c.Pop() != 5 {
		t.Log(&quot;Pop doesn't give 5&quot;)
		t.Fail()
	}
}
</sourcecode>
<t>For <tt>go test</tt> to work we need to put our package files in a directory
under <tt>$GOPATH/src</tt>:</t>

<artwork>% mkdir $GOPATH/src/stack
% cp pushpop_test.go $GOPATH/src/stack
% cp stack-as-package.go $GOPATH/src/stack
</artwork>
<t>Yields:</t>

<artwork>% go test stack
ok stack 0.001s
</artwork>
</section>

<section anchor="calculator"><name>Calculator</name>

<ol>
<li><t>Create a reverse polish calculator. Use your stack package.</t>
</li>
</ol>
</section>

<section anchor="answer-13"><name>Answer</name>

<ol>
<li><t>This is one answer:</t>
</li>
</ol>

<sourcecode type="go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strconv&quot;
)

var reader *bufio.Reader = bufio.NewReader(os.Stdin)
var st = new(Stack)

type Stack struct {
	i    int
	data [10]int
}

func (s *Stack) push(k int) {
	if s.i+1 &gt; 9 {
		return
	}
	s.data[s.i] = k
	s.i++
}

func (s *Stack) pop() (ret int) {
	s.i--
	if s.i &lt; 0 {
		s.i = 0
		return
	}
	ret = s.data[s.i]
	return
}

func main() {
	for {
		s, err := reader.ReadString('\n')
		var token string
		if err != nil {
			return
		}
		for _, c := range s {
			switch {
			case c &gt;= '0' &amp;&amp; c &lt;= '9':
				token = token + string(c)
			case c == ' ':
				r, _ := strconv.Atoi(token)
				st.push(r)
				token = &quot;&quot;
			case c == '+':
				fmt.Printf(&quot;%d\n&quot;, st.pop()+st.pop())
			case c == '*':
				fmt.Printf(&quot;%d\n&quot;, st.pop()*st.pop())
			case c == '-':
				p := st.pop()
				q := st.pop()
				fmt.Printf(&quot;%d\n&quot;, q-p)
			case c == 'q':
				return
			default:
				//error
			}
		}
	}
}
</sourcecode>
</section>
</section>
</section>

<section anchor="beyond-the-basics"><name>Beyond the basics</name>
<blockquote quotedFrom="Go For C++ Programmers -- Go Authors
"><t>Go has pointers but not pointer arithmetic. You cannot use a pointer
variable to walk through the bytes of a string.</t>
</blockquote><t>In this chapter we delve deeper in to the language.</t>
<t>Go has pointers. There is however no pointer arithmetic, so they act more like
references than pointers that you may know from C. Pointers are useful. Remember
that when you call a function in Go, the variables are
<em>pass-by-value</em>. So, for efficiency and the possibility to modify a passed value
 <em>in</em> functions we have pointers.</t>
<t>You declare a pointer by prefixing the type with an '<tt>*</tt>': <tt>var p *int</tt>. Now <tt>p</tt>
is a pointer to an integer value. All newly declared variables are assigned
their zero value and pointers are no different. A newly declared pointer, or
just a pointer that points to nothing, has a nil-value <iref item="nil"/>. In other
languages this is often called a NULL pointer in Go it is just <tt>nil</tt>. To make
a pointer point to something you can use the address-of operator
<iref item="operators" subitem="address-of"/> (<tt>&amp;</tt>), which we demonstrate here:</t>

<sourcecode type="go">var p *int
fmt.Printf(&quot;%v&quot;, p) &lt;1&gt;

var i int	    &lt;2&gt;
p = &amp;i		    &lt;3&gt;

fmt.Printf(&quot;%v&quot;, p) &lt;4&gt;
</sourcecode>
<t>This <em>1</em> Prints <tt>nil</tt>. Declare <em>2</em> an integer variable <tt>i</tt>. Make <tt>p</tt> point <em>3</em>
to <tt>i</tt>, i.e. take the address of <tt>i</tt>. And this <em>4</em> will print something like
<tt>0x7ff96b81c000a</tt>. De-referencing a pointer is done by prefixing the pointer
variable with <tt>*</tt>.</t>
<t>As said, there is no pointer arithmetic, so if you write: <tt>*p++</tt>, it is
interpreted as <tt>(*p)++</tt>: first reference and then increment the
value.<iref item="operators" subitem="increment"/></t>

<section anchor="allocation"><name>Allocation</name>
<t>Go also has garbage collection, meaning that you don't have to worry about
memory deallocation.</t>
<t>To allocate memory Go has two primitives, <tt>new</tt> and <tt>make</tt>. They do different
things and apply to different types, which can be confusing, but the rules are
simple. The following sections show how to handle allocation in Go and hopefully
clarifies the somewhat artificial distinction between <tt>new</tt> <iref item="built-in" subitem="new"/>
and <tt>make</tt> <iref item="built-in" subitem="make"/>.</t>

<section anchor="allocation-with-new"><name>Allocation with new</name>
<t>The built-in function <tt>new</tt> is essentially the same as its namesakes in other
languages: <tt>new(T)</tt> allocates zeroed storage for a new item of type <tt>T</tt> and
returns its address, a value of type <tt>*T</tt>. Or in other words, it returns
a pointer to a newly allocated zero value of type <tt>T</tt>. This is important to
remember.</t>
<t>The documentation for <tt>bytes.Buffer</tt> states that &quot;the zero value for Buffer is
an empty buffer ready to use.&quot;. Similarly, <tt>sync.Mutex</tt> does not have an
explicit constructor or Init method. Instead, the zero value for a <tt>sync.Mutex</tt>
is defined to be an unlocked mutex.</t>
</section>

<section anchor="allocation-with-make"><name>Allocation with make</name>
<t>The built-in function <tt>make(T, args)</tt> serves a purpose different from <tt>new(T)</tt>.
It creates slices, maps, and channels <em>only</em>, and it returns an initialized (not
zero!) value of type <tt>T</tt>, and not a pointer: <tt>*T</tt>. The reason for the
distinction is that these three types are, under the covers, references to data
structures that must be initialized before use. A slice, for example, is
a three-item descriptor containing a pointer to the data (inside an array), the
length, and the capacity; until those items are initialized, the slice is <tt>nil</tt>.
For slices, maps, and channels, <tt>make</tt> initializes the internal data structure
and prepares the value for use.</t>
<t>For instance, <tt>make([]int, 10, 100)</tt> allocates an array of 100 ints and then
creates a slice structure with length 10 and a capacity of 100 pointing at the
first 10 elements of the array. In contrast, <tt>new([]int)</tt> returns a pointer to
a newly allocated, zeroed slice structure, that is, a pointer to a <tt>nil</tt> slice
value. These examples illustrate the difference between <tt>new</tt> and <tt>make</tt>.</t>

<sourcecode type="go">var p *[]int = new([]int)       &lt;1&gt;
var v  []int = make([]int, 100) &lt;2&gt;

var p *[]int = new([]int)       &lt;3&gt;
*p = make([]int, 100, 100)

v := make([]int, 100)           &lt;4&gt;
</sourcecode>
<t>Allocates <em>1</em> slice structure; rarely useful. <tt>v</tt> <em>2</em> refers to a new array of
100 ints. At <em>3</em> we make it unnecessarily complex, <em>4</em> is more idiomatic.</t>
<t>Remember that <tt>make</tt> applies only to maps, slices and channels and does not
return a pointer. To obtain an explicit pointer allocate with <tt>new</tt>.</t>

<aside><t><strong>new</strong> allocates; <strong>make</strong> initializes.</t>
<t>The above two paragraphs can be summarized as:</t>

<ul>
<li><t><tt>new(T)</tt> returns <tt>*T</tt> pointing to a zeroed <tt>T</tt></t>
</li>
<li><t><tt>make(T)</tt> returns an initialized <tt>T</tt></t>
</li>
</ul>
<t>And of course <tt>make</tt> is only used for slices, maps and channels.</t>
</aside>
</section>

<section anchor="constructors-and-composite-literals"><name>Constructors and composite literals</name>
<t>Sometimes the zero value isn't good enough and an initializing constructor is
necessary, as in this example taken from the package <tt>os</tt>.</t>

<sourcecode type="go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</sourcecode>
<t>There's a lot of boiler plate in there. We can simplify it using a
<em>composite literal</em> <iref item="literal" subitem="composite"/>, which is an expression that
 creates a new instance each time it is evaluated.</t>

<sourcecode type="go">func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f	&lt;1&gt;
}
</sourcecode>
<t>It is OK to return the address of a local variable <em>1</em> the storage associated
with the variable survives after the function returns.</t>
<t>In fact, taking the address of a composite literal allocates a fresh instance
each time it is evaluated, so we can combine these last two lines.</t>

<sourcecode type="go">return &amp;File{fd, name, nil, 0}
</sourcecode>
<t>The items (called fields) of a composite literal are laid out in order and must
all be present. However, by labeling the elements explicitly as field:value
pairs, the initializers can appear in any order, with the missing ones left as
their respective zero values. Thus we could say</t>

<sourcecode type="go">return &amp;File{fd: fd, name: name}
</sourcecode>
<t>As a limiting case, if a composite literal contains no fields at all, it creates
a zero value for the type. The expressions <tt>new(File)</tt> and <tt>&amp;File{}</tt> are
equivalent. In fact the use of <tt>new</tt> is discouraged.</t>
<t>Composite literals can also be created for arrays, slices, and maps, with the
field labels being indices or map keys as appropriate. In these examples, the
initializations work regardless of the values of <tt>Enone</tt>, and <tt>Einval</tt>, as long
as they are distinct:</t>

<sourcecode type="go">ar := [...]string{Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
sl := []string{Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
ma := map[int]string {Enone: &quot;no error&quot;, Einval: &quot;invalid argument&quot;}
</sourcecode>
</section>
</section>

<section anchor="defining-your-own-types"><name>Defining your own types</name>
<t>Of course Go allows you to define new types, it does this with the
<tt>type</tt><iref item="keywords" subitem="type"/> keyword: <tt>type foo int</tt></t>
<t>This creates a new type <tt>foo</tt> which acts like an <tt>int</tt>. Creating more sophisticated
types is done with the <tt>struct</tt> <iref item="keywords" subitem="struct"/> keyword. An example would
be when we want record somebody's name (<tt>string</tt>) and age (<tt>int</tt>) in a single
structure and make it a new type:</t>

<sourcecode type="go">package main

import &quot;fmt&quot;

type NameAge struct {
	name string // Both non exported fields.
	age  int
}

func main() {
	a := new(NameAge)
	a.name = &quot;Pete&quot;
	a.age = 42
	fmt.Printf(&quot;%v\n&quot;, a)
}
</sourcecode>
<t>Apropos, the output of <tt>fmt.Printf(&quot;%v\n&quot;, a)</tt> is <tt>&amp;{Pete 42}</tt></t>
<t>That is nice! Go knows how to print your structure. If you only want to print
one, or a few, fields of the structure you'll need to use <tt>.&lt;field name&gt;</tt>. For
example to only print the name:</t>

<sourcecode type="go">fmt.Printf(&quot;%s&quot;, a.name)
</sourcecode>

<section anchor="more-on-structure-fields"><name>More on structure fields</name>
<t>As said each item in a structure is called a field<iref item="field"/>. A struct with no
fields: <tt>struct {}</tt>. Or one with four fields:</t>

<sourcecode type="go">struct {
    x, y int
    A *[]int
    F func()
}
</sourcecode>
<t>If you omit the name for a field, you create an anonymous field (((field,
anonymous))), for instance:</t>

<sourcecode type="go">struct {
    T1        // Field name is T1.
    *T2       // Field name is T2.
    P.T3      // Field name is T3.
    x, y int  // Field names are x and y.
}
</sourcecode>
<t>Note that field names that start with a capital letter are exported, i.e. can be
set or read from other packages. Field names that start with a lowercase are
private to the current package. The same goes for functions defined in packages,
see <xref target="packages"></xref> for the details.</t>
</section>

<section anchor="methods"><name>Methods</name>
<t>If you create functions that work on your newly defined type, you can take two
routes:</t>

<ol>
<li><t>Create a function that takes the type as an argument.</t>
</li>
</ol>

<sourcecode type="go">func doSomething(n1 *NameAge, n2 int) { /* */ }
</sourcecode>

<ol start="2">
<li><t>Create a function that works on the type (see <em>receiver</em> in <xref target="functions"></xref>):</t>
</li>
</ol>

<sourcecode type="go">func (n1 *NameAge) doSomething(n2 int) { /* */ }
</sourcecode>
<t>This is a method call, which can be used as:</t>

<sourcecode type="go">var n *NameAge
n.doSomething(2)
</sourcecode>
<t>Whether to use a function or method is entirely up to the programmer, but if you
want to satisfy an interface (see the next chapter) you must use methods. If no
such requirement exists it is a matter of taste whether to use functions or
methods.</t>
<t>But keep the following in mind, this is quoted from <xref target="go_spec"></xref>:</t>
<blockquote><t>If <tt>x</tt> is
addressable and <tt>&amp;x</tt>'s method set contains <tt>m</tt>,
<tt>x.m()</tt> is shorthand for <tt>(&amp;x).m()</tt>.</t>
</blockquote><t>In the above case this means that the following is <em>not</em> an error:</t>

<sourcecode type="go">var n NameAge	    // Not a pointer
n.doSomething(2)
</sourcecode>
<t>Here Go will search the method list for <tt>n</tt> of type <tt>NameAge</tt>, come up empty and
will then <em>also</em> search the method list for the type <tt>*NameAge</tt> and will
translate this call to <tt>(&amp;n).doSomething(2)</tt>.</t>
<t>There is a subtle but major difference between the following type declarations.
Also see the Section &quot;Type Declarations&quot; <xref target="go_spec"></xref>. Suppose we have:</t>

<sourcecode type="go">// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock impl. */ }
func (m *Mutex) Unlock()  { /* Unlock impl. */ }
</sourcecode>
<t>We now create two types in two different manners:</t>

<ul>
<li><t><tt>type NewMutex Mutex</tt>.</t>
</li>
<li><t><tt>type PrintableMutex struct{Mutex}</tt>.</t>
</li>
</ul>
<t><tt>NewMutex</tt> is equal to <tt>Mutex</tt>, but it <em>does not</em> have <em>any</em> of the methods of
<tt>Mutex</tt>. In other words its method set is empty. But <tt>PrintableMutex</tt> <em>has</em>
<em>inherited</em> <iref item="methods" subitem="inherited"/> the method set from <tt>Mutex</tt>. The Go term
 for this is <em>embedding</em> <iref item="structures" subitem="embed"/>. In the words of <xref target="go_spec"></xref>:</t>
<blockquote><t>The method set of <tt>*PrintableMutex</tt> contains the methods
<tt>Lock</tt> and <tt>Unlock</tt> bound to its anonymous field <tt>Mutex</tt>.</t>
</blockquote></section>
</section>

<section anchor="conversions"><name>Conversions</name>
<t>Sometimes you want to convert a type to another type. This is possible in Go,
but there are some rules. For starters, converting from one value to another is
done by operators (that look like functions: <tt>byte()</tt>) and not all conversions
are allowed.</t>
<table anchor="tab-conversion"><name>Valid conversions, <tt>float64</tt> works the same as <tt>float32</tt>.</name>
<thead>
<tr>
<th>From</th>
<th><tt>b []byte</tt></th>
<th><tt>i []int</tt></th>
<th><tt>r []rune</tt></th>
<th><tt>s string</tt></th>
<th><tt>f float32</tt></th>
<th><tt>i int</tt></th>
</tr>
</thead>

<tbody>
<tr>
<td><strong>To</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td><tt>[]byte</tt></td>
<td>·</td>
<td></td>
<td></td>
<td><tt>[]byte(s)</tt></td>
<td></td>
<td></td>
</tr>

<tr>
<td><tt>[]int</tt></td>
<td></td>
<td>·</td>
<td></td>
<td><tt>[]int(s)</tt></td>
<td></td>
<td></td>
</tr>

<tr>
<td><tt>[]rune</tt></td>
<td></td>
<td></td>
<td></td>
<td><tt>[]rune(s)</tt></td>
<td></td>
<td></td>
</tr>

<tr>
<td><tt>string</tt></td>
<td><tt>string(b)</tt></td>
<td><tt>string(i)</tt></td>
<td><tt>string(r)</tt></td>
<td>·</td>
<td></td>
<td></td>
</tr>

<tr>
<td><tt>float32</tt></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>·</td>
<td><tt>float32(i)</tt></td>
</tr>

<tr>
<td><tt>int</tt></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><tt>int(f)</tt></td>
<td>·</td>
</tr>
</tbody>
</table>
<ul>
<li><t>From a <tt>string</tt> to a slice of bytes or runes.</t>

<sourcecode type="go">mystring := &quot;hello this is string&quot;
byteslice := []byte(mystring)
</sourcecode>
<t>Converts to a <tt>byte</tt> slice, each <tt>byte</tt> contains the integer value of the
corresponding byte in the string. Note that as strings in Go are encoded in
UTF-8 some characters in the string may end up in 1, 2, 3 or 4 bytes.</t>

<sourcecode type="go">runeslice  := []rune(mystring)
</sourcecode>
<t>Converts to an <tt>rune</tt> slice, each <tt>rune</tt> contains a Unicode code point.
Every character from the string corresponds to one rune.</t>
</li>
<li><t>From a slice of bytes or runes to a <tt>string</tt>.</t>

<sourcecode type="go">b := []byte{'h','e','l','l','o'} // Composite literal.
s := string(b)
i := []rune{257,1024,65}
r := string(i)
</sourcecode>
</li>
</ul>
<t>For numeric values the following conversions are defined:</t>

<ul>
<li><t>Convert to an integer with a specific (bit) length: <tt>uint8(int)</tt></t>
</li>
<li><t>From floating point to an integer value: <tt>int(float32)</tt>. This discards the
fraction part from the floating point value.</t>
</li>
<li><t>And the other way around: <tt>float32(int)</tt>.</t>
</li>
</ul>

<section anchor="user-defined-types-and-conversions"><name>User defined types and conversions</name>
<t>How can you convert between the types you have defined yourself? We create two
types here <tt>Foo</tt> and <tt>Bar</tt>, where <tt>Bar</tt> is an alias for <tt>Foo</tt>:</t>

<sourcecode type="go">type foo struct { int }  // Anonymous struct field.
type bar foo             // bar is an alias for foo.
</sourcecode>
<t>Then we:</t>

<sourcecode type="go">var b bar = bar{1} // Declare `b` to be a `bar`.
var f foo = b	   // Assign `b` to `f`.
</sourcecode>
<t>Which fails on the last line with:
<tt>cannot use b (type bar) as type foo in assignment</tt></t>
<t>This can be fixed with a conversion: <tt>var f foo = foo(b)</tt></t>
<t>Note that converting structures that are not identical in their fields is more
difficult. Also note that converting <tt>b</tt> to a plain <tt>int</tt> also fails; an integer
is not the same as a structure containing an integer.</t>
</section>
</section>

<section anchor="exercises-3"><name>Exercises</name>

<section anchor="map-function-with-interfaces"><name>Map function with interfaces</name>

<ol>
<li><t>Use the answer from the earlier map exercise but now
make it generic using interfaces. Make it at least work for
ints and strings.</t>
</li>
</ol>
</section>

<section anchor="answer-14"><name>Answer</name>

<ol>
<li><t></t>
</li>
</ol>

<sourcecode type="go">package main

import &quot;fmt&quot;

// Define the empty interface as a type.
type e interface{}

func mult2(f e) e {
	switch f.(type) {
	case int:
		return f.(int) * 2
	case string:
		return f.(string) + f.(string) + f.(string) + f.(string)
	}
	return f
}

func Map(n []e, f func(e) e) []e {
	m := make([]e, len(n))
	for k, v := range n {
		m[k] = f(v)
	}
	return m
}

func main() {
	m := []e{1, 2, 3, 4}
	s := []e{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;}
	mf := Map(m, mult2)
	sf := Map(s, mult2)
	fmt.Printf(&quot;%v\n&quot;, mf)
	fmt.Printf(&quot;%v\n&quot;, sf)
}
</sourcecode>
</section>

<section anchor="pointers"><name>Pointers</name>

<ol>
<li><t>Suppose we have defined the following structure:</t>

<sourcecode type="go">type Person struct {
    name string
    age	 int
}
</sourcecode>
<t>What is the difference between the following two lines?</t>

<sourcecode type="go">var p1 Person
p2 := new(Person)
</sourcecode>
</li>
<li><t>What is the difference between the following two allocations?</t>

<sourcecode type="go">func Set(t *T) {
    x = t
}
</sourcecode>
<t>and</t>

<sourcecode type="go">func Set(t T) {
    x= &amp;t
}
</sourcecode>
</li>
</ol>
</section>

<section anchor="answer-15"><name>Answer</name>

<ol>
<li><t>The expression, <tt>var p1 Person</tt> allocates a <tt>Person</tt>-<em>value</em> to <tt>p1</tt>. The type of <tt>p1</tt> is <tt>Person</tt>.
The second line: <tt>p2 := new(Person)</tt> allocates memory and assigns a <em>pointer</em> to <tt>p2</tt>. The type of <tt>p2</tt> is
<tt>*Person</tt>.</t>
</li>
<li><t>In the first function, <tt>x</tt> points to the same thing that <tt>t</tt> does, which is the same thing that the
actual argument points to. So in the second function, we have an &quot;extra&quot; variable containing a copy of the
interesting value. In the second function, <tt>x</tt> points to a new (heap-allocated) variable <tt>t</tt> which contains
a copy of whatever the actual argument value is.</t>
</li>
</ol>
</section>

<section anchor="linked-list"><name>Linked List</name>

<ol>
<li><t>Make use of the package <tt>container/list</tt> to create
a (doubly) linked list. Push the values 1, 2 and 4 to the list and then
print it.</t>
</li>
<li><t>Create your own linked list implementation. And perform the same actions
as above.</t>
</li>
</ol>
</section>

<section anchor="answer-16"><name>Answer</name>

<ol>
<li><t>The following is the implementation of a program using doubly
linked lists from <tt>container/list</tt>.</t>
</li>
</ol>

<sourcecode type="go">package main

import (
	&quot;container/list&quot;
	&quot;fmt&quot;
)

func main() {
	l := list.New()
	l.PushBack(1)
	l.PushBack(2)
	l.PushBack(4)

	for e := l.Front(); e != nil; e = e.Next() {
		fmt.Printf(&quot;%v\n&quot;, e.Value)
	}
}
</sourcecode>

<ol start="2">
<li><t>The following is a program implementing a simple doubly
linked list supporting <tt>int</tt> values.</t>
</li>
</ol>

<sourcecode type="go">package main

import (
	&quot;errors&quot; &lt;1&gt;
	&quot;fmt&quot;
)

type Value int &lt;2&gt;

type Node struct { &lt;3&gt;
	Value
	prev, next *Node
}

type List struct {
	head, tail *Node
}

func (l *List) Front() *Node { &lt;4&gt;
	return l.head
}

func (n *Node) Next() *Node {
	return n.next
}

func (l *List) Push(v Value) *List {
	n := &amp;Node{Value: v} &lt;5&gt;

	if l.head == nil { &lt;6&gt;
		l.head = n
	} else {
		l.tail.next = n &lt;7&gt;
		n.prev = l.tail &lt;8&gt;
	}
	l.tail = n &lt;9&gt;

	return l
}

var errEmpty = errors.New(&quot;List is empty&quot;)

func (l *List) Pop() (v Value, err error) {
	if l.tail == nil { &lt;10&gt;
		err = errEmpty
	} else {
		v = l.tail.Value     &lt;11&gt;
		l.tail = l.tail.prev &lt;12&gt;
		if l.tail == nil {
			l.head = nil &lt;13&gt;
		}
	}

	return v, err
}

func main() {
	l := new(List)

	l.Push(1)
	l.Push(2)
	l.Push(4)

	for n := l.Front(); n != nil; n = n.Next() {
		fmt.Printf(&quot;%v\n&quot;, n.Value)
	}

	fmt.Println()

	for v, err := l.Pop(); err == nil; v, err = l.Pop() {
		fmt.Printf(&quot;%v\n&quot;, v)
	}
}
</sourcecode>
<t>Import &lt;<em>1</em>&gt; the packages we will need. At &lt;<em>2</em>&gt; we declare a type for the value our list will contain,
this is not strictly neccesary. And at &lt;<em>3</em>&gt; we declare a type for the each node in our list.
At &lt;<em>4</em>&gt; we define the <tt>Front</tt> method for our list.
When pushing, create a new Node &lt;<em>5</em>&gt; with the provided value. If the list is empty &lt;<em>6</em>&gt;,
put the new node at the head. Otherwise &lt;<em>7</em>&gt; put it at the tail and make sure &lt;<em>8</em>&gt;
the new node points back to the previously existing one. At &lt;<em>9</em>&gt; we re-adjust tail
to the newly inserted node.</t>
<t>In the Pop <em>10</em> method, we return an error if the list is empty. If it is not empty <em>11</em>
we save the last value. And then <em>12</em> discard the last node from the list. Finally at <em>13</em>
we make sure the list is consistent if it becomes empty.</t>
</section>

<section anchor="cat"><name>Cat</name>

<ol>
<li><t>Write a program which mimics the Unix program <tt>cat</tt>.</t>
</li>
<li><t>Make it support the <tt>-n</tt> flag, where each line is numbered.</t>
</li>
<li><t>The solution to the above question given in contains a bug. Can you spot and fix it?</t>
</li>
</ol>
</section>

<section anchor="answer-17"><name>Answer</name>

<ol>
<li><t>The following is implemention of <tt>cat</tt> which also supports a -n flag to number each line.</t>
</li>
</ol>

<sourcecode type="go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot; &lt;1&gt;
	&quot;os&quot;
)

var numberFlag = flag.Bool(&quot;n&quot;, false, &quot;number each line&quot;) // &lt;&lt;2&gt;&gt;

func cat(r *bufio.Reader) { &lt;3&gt;
	i := 1
	for {
		buf, e := r.ReadBytes('\n') &lt;4&gt;
		if e == io.EOF {            &lt;5&gt;
			break
		}
		if *numberFlag { &lt;6&gt;
			fmt.Fprintf(os.Stdout, &quot;%5d  %s&quot;, i, buf)
			i++
		} else { &lt;7&gt;
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() == 0 {
		cat(bufio.NewReader(os.Stdin))
	}
	for i := 0; i &lt; flag.NArg(); i++ {
		f, e := os.Open(flag.Arg(i))
		if e != nil {
			fmt.Fprintf(os.Stderr, &quot;%s: error reading from %s: %s\n&quot;,
				os.Args[0], flag.Arg(i), e.Error())
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</sourcecode>
<t>At <em>1</em> we include all the packages we need.
 Here <em>2</em> we define a new flag &quot;n&quot;, which defaults to off. Note that we get the help (-h) for free.
 Start the function <em>3</em> that actually reads the file's contents and displays it;
 Read one line at the time at <em>4</em>. And stop <em>5</em> if we hit the end.
 If we should number each line, print the line number and then the line itself <em>6</em>.
 Otherwise <em>7</em> we could just print the line.</t>

<ol start="2">
<li><t>The bug show itself when the last line of the input does not
contain a newline. Or worse, when the input contains one line without a
closing newline nothing is shown at all. A better solution is the following
program.</t>
</li>
</ol>

<sourcecode type="go">package main

import (
	&quot;bufio&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;os&quot;
)

var numberFlag = flag.Bool(&quot;n&quot;, false, &quot;number each line&quot;)

func cat(r *bufio.Reader) {
	i := 1
	for {
		buf, e := r.ReadBytes('\n')
		if e == io.EOF &amp;&amp; string(buf) == &quot;&quot; {
			break
		}
		if *numberFlag {
			fmt.Fprintf(os.Stdout, &quot;%5d  %s&quot;, i, buf)
			i++
		} else {
			fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)
		}
	}
	return
}

func main() {
	flag.Parse()
	if flag.NArg() == 0 {
		cat(bufio.NewReader(os.Stdin))
	}
	for i := 0; i &lt; flag.NArg(); i++ {
		f, e := os.Open(flag.Arg(i))
		if e != nil {
			fmt.Fprintf(os.Stderr, &quot;%s: error reading from %s: %s\n&quot;,
				os.Args[0], flag.Arg(i), e.Error())
			continue
		}
		cat(bufio.NewReader(f))
	}
}
</sourcecode>
</section>

<section anchor="method-calls"><name>Method calls</name>

<ol>
<li><t>Suppose we have the following
program. Note the package <tt>container/vector</tt> was once part
of Go, but was removed when the <tt>append</tt> built-in was introduced.
However, for this question this isn't important. The package implemented
a stack-like structure, with push and pop methods.</t>

<sourcecode type="go">package main


import &quot;container/vector&quot;


func main() {
    k1 := vector.IntVector{}
    k2 := &amp;vector.IntVector{}
    k3 := new(vector.IntVector)
    k1.Push(2)
    k2.Push(3)
    k3.Push(4)
}
</sourcecode>
<t>What are the types of <tt>k1</tt>, <tt>k2</tt> and <tt>k3</tt>?</t>
</li>
<li><t>Now, this program compiles and runs OK. All the <tt>Push</tt>
operations work even though the variables are of a different type. The
documentation for <tt>Push</tt> says:</t>
<blockquote><t><tt>func (p *IntVector) Push(x int)</tt>
Push appends x to the end of the vector.</t>
</blockquote><t>So the receiver has to be of type <tt>*IntVector</tt>, why does the code
above (the Push statements) work correctly then?</t>
</li>
</ol>
</section>

<section anchor="answer-18"><name>Answer</name>

<ol>
<li><t>The type of <tt>k1</tt> is <tt>vector.IntVector</tt>. Why? We use
a composite literal (the <tt>{}</tt>), so we get a value of that type
back. The variable <tt>k2</tt> is of <tt>*vector.IntVector</tt>, because we
take the address (<tt>&amp;</tt>) of the composite literal. And finally
<tt>k3</tt> has also the type <tt>*vector.IntVector</tt>, because <tt>new</tt>
returns a pointer to the type.</t>
</li>
<li><t>The answer is given in <xref target="go_spec"></xref> in the section &quot;Calls&quot;,
where among other things it says:</t>
</li>
</ol>
<blockquote><t>A method call <tt>x.m()</tt> is valid if the method set of (the type of)
<tt>x</tt>
contains <tt>m</tt> and the argument list can be assigned to the parameter list
of <tt>m</tt>. If <tt>x</tt> is addressable and <tt>&amp;x</tt>'s method set
contains <tt>m</tt>, <tt>x.m()</tt> is shorthand for <tt>(&amp;x).m()</tt>.</t>
</blockquote><t>In other words because <tt>k1</tt> is addressable and
<tt>*vector.IntVector</tt> <em>does</em> have the <tt>Push</tt> method, the
call <tt>k1.Push(2)</tt> is translated by Go into
<tt>(&amp;k1).Push(2)</tt> which makes the type system happy again (and
you too -- now you know this).</t>
</section>
</section>
</section>

<section anchor="interfaces"><name>Interfaces</name>
<blockquote quotedFrom="eXistenZ -- Ted Pikul
"><t>I have this phobia about having my body penetrated surgically. You know what
I mean?</t>
</blockquote><t>In Go, the word <em>interface</em><iref item="interface"/> is overloaded to mean several
different things. Every type has an interface, which is the <em>set of methods
defined</em> for <iref item="interface" subitem="set of methods"/> that type. This bit of code defines
a struct type <tt>S</tt> with one field, and defines two methods for <tt>S</tt>. </t>
<figure><name>Defining a struct and methods on it.
</name>
<sourcecode type="go">type S struct { i int }
func (p *S) Get() int  { return p.i }
func (p *S) Put(v int) { p.i = v }
</sourcecode>
</figure><t>You can also define an <iref item="interface" subitem="type"/>interface type, which is simply
a set of methods. This defines an interface <tt>I</tt> with two methods:</t>

<sourcecode type="go">type I interface {
    Get() int
    Put(int)
}
</sourcecode>
<t><tt>S</tt> is a valid <em>implementation</em> for interface <tt>I</tt>, because it defines the two
methods which <tt>I</tt> requires. Note that this is true even though there is no
explicit declaration that <tt>S</tt> implements <tt>I</tt>.</t>
<t>A Go program can use this fact via yet another meaning of interface, which is an
interface value: <iref item="interface" subitem="value"/></t>

<sourcecode type="go">func f(p I) { &lt;1&gt;
    fmt.Println(p.Get()) &lt;2&gt;
    p.Put(1) &lt;3&gt;
}
</sourcecode>
<t>At <em>1</em> we declare a function that takes an interface type as the argument.
Because <tt>p</tt> implements <tt>I</tt>, it <em>must</em> have the <tt>Get()</tt> method, which we call at
<em>2</em>. And the same holds true for the <tt>Put()</tt> method at <em>3</em>. Because <tt>S</tt>
implements <tt>I</tt>, we can call the function <tt>f</tt> passing in a pointer to a value of
type <tt>S</tt>: <tt>var s S; f(&amp;s)</tt></t>
<t>The reason we need to take the address of <tt>s</tt>, rather than a value of type <tt>S</tt>,
is because we defined the methods on <tt>s</tt> to operate on pointers, see the
definition in the code above. This is not a requirement -- we could have defined
the methods to take values -- but then the <tt>Put</tt> method would not work as
expected.</t>
<t>The fact that you do not need to declare whether or not a type implements an
interface means that Go implements a form of duck typing <iref item="duck" subitem="typing"/>
<xref target="duck_typing"></xref>. This is not pure duck typing, because when possible the
Go compiler will statically check whether the type implements the interface.
However, Go does have a purely dynamic aspect, in that you can convert from one
interface type to another. In the general case, that conversion is checked at
run time. If the conversion is invalid -- if the type of the value stored in
the existing interface value does not satisfy the interface to which it is being
converted -- the program will fail with a run time error.</t>
<t>Interfaces in Go are similar to ideas in several other programming languages:
pure abstract virtual base classes in C++, typeclasses in Haskell or duck typing
in Python. However there is no other language which combines interface values,
static type checking, dynamic run time conversion, and no requirement for
explicitly declaring that a type satisfies an interface. The result in Go is
powerful, flexible, efficient, and easy to write.</t>

<section anchor="which-is-what"><name>Which is what?</name>
<t>Let's define another type <tt>R</tt> that also implements the interface <tt>I</tt>:</t>

<sourcecode type="go">type R struct { i int }
func (p *R) Get() int  { return p.i }
func (p *R) Put(v int) { p.i = v }
</sourcecode>
<t>The function <tt>f</tt> can now accept variables of type <tt>R</tt> and <tt>S</tt>.</t>
<t>Suppose you need to know the actual type in the function <tt>f</tt>. In Go you can
figure that out by using a type switch<iref item="type switch"/>.</t>

<sourcecode type="go">func f(p I) {
    switch t := p.(type) { &lt;1&gt;
        case *S: &lt;2&gt;
        case *R: &lt;2&gt;
        default: &lt;3&gt;
    }
}
</sourcecode>
<t>At <em>1</em> we use the type switch, note that the <tt>.(type)</tt> syntax is <em>only</em> valid
within a <tt>switch</tt> statement. We store the value in the variable <tt>t</tt>. The
subsequent cases <em>2</em> each check for a different <em>actual</em> type. And we can even
have a <tt>default</tt> <em>3</em> clause. It is worth pointing out that both <tt>case R</tt> and
<tt>case s</tt> aren't possible, because <tt>p</tt> needs to be a pointer in order to satisfy
<tt>i</tt>.</t>
<t>A type switch isn't the only way to discover the type at <em>run-time</em>.</t>

<sourcecode type="go">if t, ok := something.(I); ok { &lt;1&gt;
    // ...
}
</sourcecode>
<t>You can also use a &quot;comma, ok&quot; form <em>1</em> to see if an interface type implements
a specific interface. If <tt>ok</tt> is true, <tt>t</tt> will hold the type of <tt>something</tt>.
When you are sure a variable implements an interface you can use: <tt>t := something.(I)</tt> .</t>
</section>

<section anchor="empty-interface"><name>Empty interface</name>
<t>Since every type satisfies the empty interface: <tt>interface{}</tt> we can create
a generic function which has an empty interface as its argument:</t>

<sourcecode type="go">func g(something interface{}) int {
    return something.(I).Get()
}
</sourcecode>
<t>The <tt>return something.(I).Get()</tt> is the tricky bit in this function. The value
<tt>something</tt> has type <tt>interface{}</tt>, meaning no guarantee of any methods at all:
it could contain any type. The <tt>.(I)</tt> is a type assertion <iref item="type assertion"/>
which converts <tt>something</tt> to an interface of type <tt>I</tt>. If we have that type we
can invoke the <tt>Get()</tt> function. So if we create a new variable of the type
<tt>*S</tt>, we can just call <tt>g()</tt>, because <tt>*S</tt> also implements the empty interface.</t>

<sourcecode type="go">s = new(S)
fmt.Println(g(s));
</sourcecode>
<t>The call to <tt>g</tt> will work fine and will print 0. If we however invoke <tt>g()</tt> with
a value that does not implement <tt>I</tt> we have a problem:</t>

<sourcecode type="go">var i int
fmt.Println(g(i))
</sourcecode>
<t>This compiles, but when we run this we get slammed with: &quot;panic: interface
conversion: int is not main.I: missing method Get&quot;.</t>
<t>Which is completely true, the built-in type <tt>int</tt> does not have a <tt>Get()</tt>
method.</t>
</section>

<section anchor="methods-1"><name>Methods</name>
<t>Methods are functions that have a receiver (see <xref target="functions"></xref>).
You can define methods on any type (except on non-local types, this includes
built-in types: the type <tt>int</tt> can not have methods).
You can however make a new integer type with its own methods. For example:</t>

<sourcecode type="go">type Foo int

func (self Foo) Emit() {
    fmt.Printf(&quot;%v&quot;, self)
}

type Emitter interface {
    Emit()
}
</sourcecode>
<t>Doing this on non-local (types defined in other packages) types yields an error
&quot;cannot define new methods on non-local type int&quot;.</t>
</section>

<section anchor="methods-on-interface-types"><name>Methods on interface types</name>
<t>An interface defines a set of methods. A method contains the actual code. In
other words, an interface is the definition and the methods are the
implementation. So a receiver can not be an interface type, doing so results in
a &quot;invalid receiver type ...&quot; compiler error. The authoritative word from the
language spec <xref target="go_spec"></xref>:</t>
<blockquote><t>The receiver type must be of the form <tt>T</tt> or <tt>*T</tt> where <tt>T</tt> is a type name. <tt>T</tt>
is called the receiver base type or just base type. The base type must not be
a pointer or interface type and must be declared in the same package as the
method.</t>
</blockquote>
<aside><t>Creating a pointer to an interface value is a useless action in Go. It is in
fact illegal to create a pointer to an interface value. The release notes for an
earlier Go release that made them illegal leave no room for doubt:</t>
<blockquote><t>The language change is that uses of pointers to interface values no longer
automatically de-reference the pointer.  A pointer to an interface value is
more often a beginner's bug than correct code.</t>
</blockquote></aside>
</section>

<section anchor="interface-names"><name>Interface names</name>
<t>By convention, one-method interfaces are named by the method name plus the <em>-er</em>
suffix: Read<em>er</em>, Writ<em>er</em>, Formatt<em>er</em> etc.</t>
<t>There are a number of such names and it's productive to honor them and the
function names they capture. <tt>Read</tt>, <tt>Write</tt>, <tt>Close</tt>, <tt>Flush</tt>, <tt>String</tt> and so
on have canonical signatures and meanings. To avoid confusion, don't give your
method one of those names unless it has the same signature and meaning.
Conversely, if your type implements a method with the same meaning as a method
on a well-known type, give it the same name and signature; call your
string-converter method <tt>String</tt> not <tt>ToString</tt>. </t>
</section>

<section anchor="a-sorting-example"><name>A sorting example</name>
<t>Recall the Bubblesort exercise, where we sorted an array of integers:</t>

<sourcecode type="go">func bubblesort(n []int) {
    for i := 0; i &lt; len(n)-1; i++ {
        for j := i + 1; j &lt; len(n); j++ {
            if n[j] &lt; n[i] {
                n[i], n[j] = n[j], n[i]
            }
        }
    }
}
</sourcecode>
<t>A version that sorts strings is identical except for the signature of the
function: <tt>func bubblesortString(n []string) { /* ... */ }</tt> . Using this
approach would lead to two functions, one for each type. By using interfaces we
can make this more <iref item="generic"/> generic. Let's create a new function that will
sort both strings and integers, something along the lines of this non-working
example:</t>

<sourcecode type="go">func sort(i []interface{}) {  &lt;1&gt;
    switch i.(type) {         &lt;2&gt;
    case string:              &lt;3&gt;
        // ...
    case int:
        // ...
    }
    return /* ... */          &lt;4&gt;
}
</sourcecode>
<t>Our function will receive a slice of empty interfaces at <em>1</em>. We then <em>2</em> use a
type switch to find out what the actual type of the input is. And then <em>3</em>
then sort accordingly. And, when done, return <em>4</em> the sorted slice.</t>
<t>But when we call this function with <tt>sort([]int{1, 4, 5})</tt>, it fails with:
&quot;cannot use i (type []int) as type []interface { } in function argument&quot;</t>
<t>This is because Go can not easily convert to a <em>slice</em> of interfaces.
Just converting to an interface is easy, but to a slice is much more costly.
The full mailing list discussion on this subject can be found at
<xref target="go_nuts_interfaces"></xref>. To keep a long story short: Go does not (implicitly) convert slices for you.</t>
<t>So what is the Go way of creating such a &quot;generic&quot; function?
Instead of doing the type inference ourselves with a type switch, we let
Go do it implicitly:
The following steps are required:</t>

<ul>
<li><t>Define an interface type (called <tt>Sorter</tt> here) with a number of methods
needed for sorting. We will at least need a function to get the length of the
slice, a function to compare two values and a swap function.</t>

<sourcecode type="go">type Sorter interface {
    Len() int           // len() as a method.
    Less(i, j int) bool // p[j] &lt; p[i] as a method.
    Swap(i, j int)      // p[i], p[j] = p[j], p[i] as a method.
}
</sourcecode>
</li>
<li><t>Define new types for the slices we want to sort. Note that we declare slice types:</t>

<sourcecode type="go">type Xi []int
type Xs []string
</sourcecode>
</li>
<li><t>Implementation of the methods of the <tt>Sorter</tt> interface.
For integers:</t>

<sourcecode type="go">func (p Xi) Len() int               {return len(p)}
func (p Xi) Less(i int, j int) bool {return p[j] &lt; p[i]}
func (p Xi) Swap(i int, j int)      {p[i], p[j] = p[j], p[i]}
</sourcecode>
<t>And for strings:</t>

<sourcecode type="go">func (p Xs) Len() int               {return len(p)}
func (p Xs) Less(i int, j int) bool {return p[j] &lt; p[i]}
func (p Xs) Swap(i int, j int)      {p[i], p[j] = p[j], p[i]}
</sourcecode>
</li>
<li><t>Write a <em>generic</em> Sort function that works on the <tt>Sorter</tt> interface.</t>

<sourcecode type="go">func Sort(x Sorter) { &lt;1&gt;
    for i := 0; i &lt; x.Len() - 1; i++ { &lt;2&gt;
        for j := i + 1; j &lt; x.Len(); j++ {
            if x.Less(i, j) {
                x.Swap(i, j)
            }
        }
    }
}
</sourcecode>
<t>At <em>1</em> <tt>x</tt> is now of the <tt>Sorter</tt> type and using the defined methods for this interface we implement
Bubblesort at <em>2</em>.</t>
<t>Now we can use our <em>generic</em> <tt>Sort</tt> function as follows:</t>

<sourcecode type="go">ints := Xi{44, 67, 3, 17, 89, 10, 73, 9, 14, 8}
strings := Xs{&quot;nut&quot;, &quot;ape&quot;, &quot;elephant&quot;, &quot;zoo&quot;, &quot;go&quot;}


Sort(ints)
fmt.Printf(&quot;%v\n&quot;, ints)
Sort(strings)
fmt.Printf(&quot;%v\n&quot;, strings)
</sourcecode>
</li>
</ul>
</section>

<section anchor="listing-interfaces-in-interfaces"><name>Listing interfaces in interfaces</name>
<t>Take a look at the following example of an interface definition, this one is
from the package <tt>container/heap</tt>:</t>

<sourcecode type="go">type Interface interface {
    sort.Interface
    Push(x interface{})
    Pop() interface{}
}
</sourcecode>
<t>Here another interface is listed inside the definition of <tt>heap.Interface</tt>, this
may look odd, but is perfectly valid, remember that on the surface an interface is nothing
more than a listing of methods. <tt>sort.Interface</tt> is also such a listing, so it is
perfectly legal to include it in the interface.</t>
</section>

<section anchor="introspection-and-reflection"><name>Introspection and reflection</name>
<t>In the following example we want to look at the &quot;tag&quot; (here named &quot;namestr&quot;)
defined in the type definition of <tt>Person</tt>. To do this we need the
<tt>reflect</tt><iref item="package" subitem="reflect"/> package (there is no other way in Go). Keep in
mind that looking at a tag means going back to the <em>type</em> definition. So we use
the <tt>reflect</tt> package to figure out the type of the variable and <em>then</em> access
the tag.</t>
<figure><name>Introspection using reflection.
</name>
<sourcecode type="go">type Person struct {
    name string &quot;namestr&quot;
    age  int
}

func ShowTag(i interface{}) { &lt;1&gt;
    switch t := reflect.TypeOf(i); t.Kind() {
    case reflect.Ptr: &lt;2&gt;
        tag := t.Elem().Field(0).Tag
    //             &lt;&lt;3&gt;&gt;     &lt;&lt;4&gt;&gt;       &lt;&lt;5&gt;&gt;
</sourcecode>
</figure><t>We are calling <tt>ShowTag</tt> at <em>1</em> with a <tt>*Person</tt>, so at <em>2</em> we're expecting
a <tt>reflect.Ptr</tt>. We are dealing with a <tt>Type</tt> <em>3</em> and according to the
documentation :</t>
<blockquote><t>Elem returns a type's element type.
It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.</t>
</blockquote><t>So on <tt>t</tt> we use <tt>Elem()</tt> to get the value the pointer points to. We have now
dereferenced the pointer and are &quot;inside&quot; our structure. We then <em>4</em> use
<tt>Field(0)</tt> to access the zeroth field.</t>
<t>The struct <tt>StructField</tt> has a <tt>Tag</tt> member which returns the tag-name as
a string. So on the <tt>0^{th}</tt> field we can unleash <tt>.Tag</tt> <em>5</em> to access this
name: <tt>Field(0).Tag</tt>. This gives us <tt>namestr</tt>.</t>
<t>To make the difference between types and values more clear, take a look at the
following code:</t>
<figure><name>Reflection and the type and value.
</name>
<sourcecode type="go">func show(i interface{}) {
    switch t := i.(type) {
    case *Person:
        t := reflect.TypeOf(i)  &lt;1&gt;
        v := reflect.ValueOf(i) &lt;2&gt;
        tag := t.Elem().Field(0).Tag &lt;3&gt;
        name := v.Elem().Field(0).String() &lt;4&gt;
    }
}
</sourcecode>
</figure><t>At <em>1</em> we create <tt>t</tt> the type data of <tt>i</tt>, and <tt>v</tt> gets the actual values at
<em>2</em>. Here at <em>3</em> we want to get to the &quot;tag&quot;. So we need <tt>Elem()</tt> to redirect
the pointer, access the first field and get the tag. Note that we operate on <tt>t</tt>
a <tt>reflect.Type</tt>. Now <em>4</em> we want to get access to the <em>value</em> of one of the
members and we employ <tt>Elem()</tt> on <tt>v</tt> to do the redirection. we have &quot;arrived&quot;
at the structure. Then we go to the first field <tt>Field(0)</tt> and invoke the
<tt>String()</tt> method on it.</t>
<t>Peeling away the layers using reflection.</t>
<t>Setting a value works similarly as getting a value, but only works on
<em>exported</em> members. Again some code:</t>
<figure><name>Reflect with <em>private</em> member.
</name>
<sourcecode type="go">type Person struct {
    name string
    age  int
}

func Set(i interface{}) {
    switch i.(type) {
    case *Person:
        r := reflect.ValueOf(i)
        r.Elem(0).Field(0).SetString(&quot;Albert Einstein&quot;)
    }
}
</sourcecode>
</figure><figure><name>Reflect with <em>public</em> member.
</name>
<sourcecode type="go">type Person struct {
    Name string
    age  int
}

func Set(i interface{}) {
    switch i.(type) {
    case *Person:
        r := reflect.ValueOf(i)
        r.Elem().Field(0).SetString(&quot;Albert Einstein&quot;)
    }
}
</sourcecode>
</figure><t>The first program compiles and runs, but when you run it, you are greeted with a
stack trace and a <em>run time</em> error:
&quot;panic: reflect.Value.SetString using value obtained using unexported field&quot;.</t>
<t>The second program works OK and sets the member <tt>Name</tt> to &quot;Albert Einstein&quot;.
Of course this only works when you call <tt>Set()</tt> with a pointer argument.</t>
</section>

<section anchor="exercises-4"><name>Exercises</name>
<t>### Interfaces and max()</t>
<t>In the maximum exercise we created a max function that works on a slice of
integers.  The question now is to create a program that shows the maximum number
and that works for both integers and floats.  Try to make your program as
generic as possible, although that is quite difficult in this case.</t>

<section anchor="answer-19"><name>Answer</name>
<t>The following program calculates a maximum. It is as generic as you can get with
Go.</t>

<sourcecode type="go">package main

import &quot;fmt&quot;

func Less(l, r interface{}) bool { &lt;1&gt;
    switch l.(type) {
    case int:
        if _, ok := r.(int); ok {
            return l.(int) &lt; r.(int) &lt;2&gt;
        }
    case float32:
        if _, ok := r.(float32); ok {
            return l.(float32) &lt; r.(float32) &lt;3&gt;
        }
    }
    return false
}

func main() {
    var a, b, c int = 5, 15, 0
    var x, y, z float32 = 5.4, 29.3, 0.0

    if c = a; Less(a, b) { &lt;4&gt;
        c = b
    }
    if z = x; Less(x, y) { &lt;4&gt;
        z = y
    }
    fmt.Println(c, z)
}
</sourcecode>
<t>We could have chosen to make the return type of this <em>1</em> function an
<tt>interface{}</tt>, but that would mean that a caller would always have to do a type
assertion to extract the actual type from the interface. At <em>2</em> we compare the
parameters. All parameters are confirmed to be integers, so this is legit. And
at <em>3</em> we do the some for floats. At <em>4</em> we get the maximum value for <tt>a</tt>, <tt>b</tt>
and <tt>x</tt> and <tt>y</tt>.</t>
</section>

<section anchor="pointers-and-reflection"><name>Pointers and reflection</name>
<t>One of the last paragraphs in section <xref target="introspection-and-reflection"></xref>
has the following words:</t>
<blockquote><t>The code on the right works OK and sets the member <tt>Name</tt>
to &quot;Albert Einstein&quot;. Of course this only works when you call <tt>Set()</tt>
with a pointer argument.</t>
</blockquote><t>Why is this the case?</t>
</section>

<section anchor="answer-20"><name>Answer</name>
<t>When called with a non-pointer argument the variable is a copy (call-by-value).
So you are doing the reflection voodoo on a copy. And thus you are <em>not</em>
changing the original value, but only this copy.</t>
</section>
</section>
</section>

<section anchor="concurrency"><name>Concurrency</name>
<blockquote quotedFrom="Google I/O 2010 -- Rob Pike
">
<ul>
<li><t>Parallelism is about performance.</t>
</li>
<li><t>Concurrency is about program design.</t>
</li>
</ul>
</blockquote><t>In this chapter we will show off Go's ability for concurrent programming using
channels and goroutines. Goroutines are the central entity in Go's ability for
concurrency.</t>
<t>But what <em>is</em> a goroutine, from <xref target="effective_go"></xref>:</t>
<blockquote><t>They're called goroutines because the existing terms -- threads, coroutines,
processes, and so on -- convey inaccurate connotations. A goroutine has a simple
model: <em>it is a function executing in parallel with other goroutines in the same
address space</em>. It is lightweight, costing little more than the allocation of
stack space. And the stacks start small, so they are cheap, and grow by
allocating (and freeing) heap storage as required.</t>
</blockquote><t>A goroutine <iref item="goroutine"/> is a normal function, except that you start
it with the keyword <tt>go</tt>. <iref item="keywords" subitem="go"/></t>

<sourcecode type="go">ready(&quot;Tea&quot;, 2)	    // Normal function call.
go ready(&quot;Tea&quot;, 2)  // ... as goroutine.
</sourcecode>

<sourcecode type="go">func ready(w string, sec int) {
	time.Sleep(time.Duration(sec) * time.Second)
	fmt.Println(w, &quot;is ready!&quot;)
}

func main() {
	go ready(&quot;Tea&quot;, 2)    //&lt;1&gt;
	go ready(&quot;Coffee&quot;, 1) //&lt;1&gt;
	fmt.Println(&quot;I'm waiting&quot;)
	time.Sleep(5 * time.Second) //&lt;2&gt;
</sourcecode>
<t>Figure: Go routines in action.</t>
<t>The following idea for a program was taken from <xref target="go_course_day3"></xref>. We run
a function as two goroutines, the goroutines wait for an amount of time and then
print something to the screen. At <em>1</em> we start the goroutines. The <tt>main</tt>
function waits long enough at <em>2</em>, so that both goroutines will have printed
their text. Right now we wait for 5 seconds, but in fact we have no idea how
long we should wait until all goroutines have exited. This outputs:</t>

<sourcecode type="go">I'm waiting         // Right away
Coffee is ready!    // After 1 second
Tea is ready!       // After 2 seconds
</sourcecode>
<t>If we did not wait for the goroutines (i.e. remove the last line at <em>2</em>) the
program would be terminated immediately and any running goroutines would
<em>die with it</em>.</t>
<t>To fix this we need some kind of mechanism which allows us to
communicate with the goroutines. This mechanism is available to us in the form
of channels <iref item="channels"/>. A channel can be compared to a two-way pipe in Unix
shells: you can send to and receive values from it. Those values can only be of
a specific type: the type of the channel. If we define a channel, we must also
define the type of the values we can send on the channel. Note that we must use
<tt>make</tt> to create a channel:</t>

<sourcecode type="go">ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
</sourcecode>
<t>Makes <tt>ci</tt> a channel on which we can send and receive integers,
makes <tt>cs</tt> a channel for strings and <tt>cf</tt> a channel for types
that satisfy the empty interface.
Sending on a channel and receiving from it, is done with the same operator:
<tt>&lt;-</tt>. <iref item="operators" subitem="channel"/></t>
<t>Depending on the operands it figures out what to do:</t>

<sourcecode type="go">ci &lt;- 1   // *Send* the integer 1 to the channel ci.
&lt;-ci      // *Receive* an integer from the channel ci.
i := &lt;-ci // *Receive* from the channel ci and store it in i.
</sourcecode>
<t>Let's put this to use.</t>

<sourcecode type="go">var c chan int &lt;1&gt;

func ready(w string, sec int) {
    time.Sleep(time.Duration(sec) * time.Second)
    fmt.Println(w, &quot;is ready!&quot;)
    c &lt;- 1	&lt;2&gt;
}

func main() {
    c = make(chan int) &lt;3&gt;
    go ready(&quot;Tea&quot;, 2) &lt;4&gt;
    go ready(&quot;Coffee&quot;, 1) &lt;4&gt;
    fmt.Println(&quot;I'm waiting, but not too long&quot;)
    &lt;-c &lt;5&gt;
    &lt;-c &lt;5&gt;
}
</sourcecode>
<t>At <em>1</em> we declare <tt>c</tt> to be a variable that is a channel of ints. That is: this
channel can move integers. Note that this variable is global so that the
goroutines have access to it. At <em>2</em> in the <tt>ready</tt> function we send the integer
1 on the channel. In our <tt>main</tt> function we initialize <tt>c</tt> at <em>3</em> and start our
goroutines <em>4</em>. At <em>5</em> we Wait until we receive a value from the channel, the
value we receive is discarded. We have started two goroutines, so we expect two
values to receive.</t>
<t>There is still some remaining ugliness; we have to read twice from the channel
<em>5</em>). This is OK in this case, but what if we don't know how many goroutines we
started? This is where another Go built-in comes in: <tt>select</tt> (((keywords,
select))). With <tt>select</tt> you can (among other things) listen for incoming data
on a channel.</t>
<t>Using <tt>select</tt> in our program does not really make it shorter, because we run
too few go-routines. We remove last lines and replace them with the following:</t>

<sourcecode type="go">L: for {
    select {
    case &lt;-c:
        i++
        if i &gt; 1 {
            break L
        }
    }
}
</sourcecode>
<t>We will now wait as long as it takes. Only when we have received more than one
reply on the channel <tt>c</tt> will we exit the loop <tt>L</tt>.</t>

<section anchor="make-it-run-in-parallel"><name>Make it run in parallel</name>
<t>While our goroutines were running concurrently, they were not running in
parallel. When you do not tell Go anything there can only be one goroutine
running at a time. With <tt>runtime.GOMAXPROCS(n)</tt> you can set the number of
goroutines that can run in parallel. From the documentation:</t>
<blockquote><t>GOMAXPROCS sets the maximum number of CPUs that can be executing
simultaneously and returns the previous setting. If n &lt; 1, it does not
change the current setting. <em>This call will go away when the scheduler
improves.</em></t>
</blockquote><t>If you do not want to change any source code you can also set an environment
variable <tt>GOMAXPROCS</tt> to the desired value.</t>
<t>Note that the above discussion relates to older versions of Go. From
version 1.5 and above, <tt>GOMAXPROCS</tt> defaults to the number of CPU
cores<xref target="go_1_5_release_notes"></xref>.</t>
</section>

<section anchor="more-on-channels"><name>More on channels</name>
<t>When you create a channel in Go with <tt>ch := make(chan bool)</tt>, an unbuffered
channel <iref item="channel" subitem="unbuffered"/> for bools is created. What does this mean for
your program? For one, if you read (<tt>value := &lt;-ch</tt>) it will block until there
is data to receive. Secondly anything sending (<tt>ch &lt;- true</tt>) will block until there
is somebody to read it. Unbuffered channels make a perfect tool for
synchronizing multiple goroutines. <iref item="channel" subitem="blocking read"/> <iref item="channel" subitem="blocking write"/></t>
<t>But Go allows you to specify the buffer size of a channel, which is quite simply
how many elements a channel can hold. <tt>ch := make(chan bool, 4)</tt>, creates
a buffered channel of bools that can hold 4 elements. The first 4 elements in
this channel are written without any blocking. When you write the 5<sup>th</sup></t>
<t>In conclusion, the following is true in Go:</t>
<artwork type="math">

\textsf{ch := make(chan type, value)}
\left\{
\begin{array}{ll}
value == 0 &amp; \rightarrow \textsf{unbuffered} \\
value &gt;  0 &amp; \rightarrow \textsf{buffer }{} value{} \textsf{ elements}
\end{array}
\right.
</artwork>
<artwork type="math">

\textsf{ch := make(chan type, value)}
\left\{
\begin{array}{ll}
value == 0 &amp; \rightarrow \textsf{unbuffered} \\
value &gt;  0 &amp; \rightarrow \textsf{buffer }{} value{} \textsf{ elements}
\end{array}
\right.
</artwork>
<t>When a channel is closed the reading side needs to know this. The following code
will check if a channel is closed.</t>

<sourcecode type="go">x, ok = &lt;-ch
</sourcecode>
<t>Where <tt>ok</tt> is set to <tt>true</tt> the channel is not closed
<em>and</em> we've read something. Otherwise <tt>ok</tt> is set to <tt>false</tt>. In that case the
channel was closed and the value received is a zero value of the
channel's type.</t>
</section>

<section anchor="exercises-5"><name>Exercises</name>

<section anchor="channels"><name>Channels</name>

<ol>
<li><t>Modify the program you created in exercise <xref target="for-loop"></xref> to use
channels, in other words, the function called in the body should now be
a goroutine and communication should happen via channels. You should not
worry yourself on how the goroutine terminates.</t>
</li>
<li><t>There are a few annoying issues left if you resolve question 1 above. One of
the problems is that the goroutine isn't neatly cleaned up when <tt>main.main()</tt>
exits. And worse, due to a race condition between the exit of <tt>main.main()</tt>
and <tt>main.shower()</tt> not all numbers are printed. It should print up until 9,
but sometimes it prints only to 8. Adding a second quit-channel you can
remedy both issues. Do this.</t>
</li>
</ol>
</section>

<section anchor="answer-21"><name>Answer</name>

<ol>
<li><t>A possible program is:</t>
</li>
</ol>

<sourcecode type="go">package main

import &quot;fmt&quot;

func main() {
	ch := make(chan int)
	go shower(ch)
	for i := 0; i &lt; 10; i++ {
		ch &lt;- i
	}
}

func shower(c chan int) {
	for {
		j := &lt;-c
		fmt.Printf(&quot;%d\n&quot;, j)
	}
}
</sourcecode>
<t>We start in the usual way, then at line 6 we create a new channel of
   ints. In the next line we fire off the function <tt>shower</tt> with
   the <tt>ch</tt> variable as it argument, so that we may communicate with
   it. Next we start our for-loop (lines 8-10) and in the loop
   we send (with <tt>&lt;-</tt>) our number to the function (now a goroutine) <tt>shower</tt>.</t>
<t>In the function <tt>shower</tt> we wait (as this blocks) until we receive a number
   (line 15). Any received number is printed (line 16) and then continue the
   endless loop started on line 14.</t>

<ol start="2">
<li><t>An answer is</t>
</li>
</ol>

<sourcecode type="go">package main

import &quot;fmt&quot;

func main() {
	ch := make(chan int)
	quit := make(chan bool)
	go shower(ch, quit)
	for i := 0; i &lt; 10; i++ {
		ch &lt;- i
	}
	quit &lt;- false	// or true, does not matter
}

func shower(c chan int, quit chan bool) {
	for {
		select {
		case j := &lt;-c:
			fmt.Printf(&quot;%d\n&quot;, j)
		case &lt;-quit:
			break
		}
	}
}
</sourcecode>
<t>On line 20 we read from the quit channel and we discard the value we read. We
   could have used <tt>q := &lt;-quit</tt>, but then we would have used the variable only
   once --- which is illegal in Go. Another trick you might have pulled out of
   your hat may be: <tt>_ = &lt;-quit</tt>. This is valid in Go, but idomatic Go is the
   one given on line 20.</t>
</section>

<section anchor="fibonacci-ii"><name>Fibonacci II</name>
<t>This is the same exercise as an earlier one <xref target="fibonacci"></xref> in
exercise. For completeness the complete question:</t>
<blockquote><t>The Fibonacci sequence starts as follows: <tt>1, 1, 2, 3, 5, 8, 13, \ldots</tt>
Or in mathematical terms:
<tt>x_1 = 1; x_2 = 1; x_n = x_{n-1} + &gt; x_{n-2}\quad\forall n &gt; 2</tt>.</t>
<t>Write a function that takes an <tt>int</tt> value and gives
that many terms of the Fibonacci sequence.</t>
</blockquote><t><em>But</em> now the twist: You must use channels.</t>
</section>

<section anchor="answer-22"><name>Answer</name>
<t>The following program calculates the Fibonacci numbers using channels.</t>

<sourcecode type="go">package main
import &quot;fmt&quot;

func dup3(in &lt;-chan int) (&lt;-chan int, &lt;-chan int, &lt;-chan int) {
	a, b, c := make(chan int, 2), make(chan int, 2), make(chan int, 2)
	go func() {
		for {
			x := &lt;-in
			a &lt;- x
			b &lt;- x
			c &lt;- x
		}
	}()
	return a, b, c
}

func fib() &lt;-chan int {
	x := make(chan int, 2)
	a, b, out := dup3(x)
	go func() {
		x &lt;- 0
		x &lt;- 1
		&lt;-a
		for {
			x &lt;- &lt;-a+&lt;-b
		}
	}()
	return out
}

func main() {
	x := fib()
	for i := 0; i &lt; 10; i++ {
		fmt.Println(&lt;-x)
	}
}

// See sdh33b.blogspot.com/2009/12/fibonacci-in-go.html
</sourcecode>
</section>
</section>
</section>

<section anchor="communication"><name>Communication</name>
<blockquote quotedFrom="-- Anne Morrow Lindbergh
"><t>Good communication is as stimulating as black coffee, and just as hard
to sleep after.</t>
</blockquote><t>In this chapter we are going to look at the building blocks in Go for
communicating with the outside world. We will look at files, directories,
networking and executing other programs. Central to Go's I/O are the interfaces
<tt>io.Reader</tt> and <tt>io.Writer</tt>. The <tt>io.Reader</tt> interface specifies one method
<tt>Read(p []byte) (n int, err err)</tt>.</t>
<t>Reading from (and writing to) files is easy in Go. This program
only uses the <tt>os</tt> package to read data from the file <tt>/etc/passwd</tt>.</t>

<sourcecode type="go">package main

import (
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	buf := make([]byte, 1024)
	f, e := os.Open(&quot;/etc/passwd&quot;) &lt;1&gt;
	if e != nil {
		log.Fatalf(e)
	}
	defer f.Close() &lt;2&gt;
	for {
		n, e := f.Read(buf) &lt;3&gt;
		if e != nil {
			log.Fatalf(e) &lt;4&gt;
		}
		if n == 0 { &lt;5&gt;
			break
		}
		os.Stdout.Write(buf[:n]) &lt;6&gt;
	}
}
</sourcecode>
<t>We open the file at <em>1</em> with <tt>os.Open</tt> that returns a <tt>*os.File</tt>
<tt>*os.File</tt> implements <tt>io.Reader</tt> and <tt>io.Writer</tt> interface.
After the <tt>Open</tt> we directly put the <tt>f.Close()</tt> which we defer until the function
return. At <em>3</em> we call <tt>Read</tt> on <tt>f</tt> and read up to 1024 bytes at the time. If anything
fails we bail out at <em>4</em>. If the number of bytes read is 0 we've read the end of the
file <em>5</em>. And at <em>6</em> we output the buffer to standard output.</t>
<t>If you want to use buffered <iref item="io" subitem="buffered"/> I/O there is the
<tt>bufio</tt><iref item="package" subitem="bufio"/> package:</t>

<sourcecode type="go">package main

import (
	&quot;bufio&quot;
	&quot;log&quot;
	&quot;os&quot;
)

func main() {
	buf := make([]byte, 1024)
	f, e := os.Open(&quot;/etc/passwd&quot;) &lt;1&gt;
	if e != nil {
		log.Fatalf(e)
	}
	defer f.Close()
	r := bufio.NewReader(f) &lt;2&gt;
	w := bufio.NewWriter(os.Stdout)
	defer w.Flush() &lt;3&gt;
	for {
		n, e := r.Read(buf) &lt;4&gt;
		if e != nil {
			log.Fatalf(e)
		}
		if n == 0 {
			break
		}
		w.Write(buf[0:n]) &lt;5&gt;
	}
}
</sourcecode>
<t>Again, we open <em>1</em> the file. Then at <em>2</em> we
Turn <tt>f</tt> into a buffered <tt>Reader</tt>. <tt>NewReader</tt> expects an <tt>io.Reader</tt>, so you this will work.
Then at <em>4</em> we read and at <em>5</em> we write. We also call <tt>Flush()</tt> at <em>3</em> to flush all output.
This entire program could be optimized further by using <tt>io.Copy</tt>.</t>

<section anchor="io-reader"><name>io.Reader</name>
<t>As mentioned above the <tt>io.Reader</tt> <iref item="io.Reader"/> is an important interface in the language Go. A lot
(if not all) functions that need to read from something take an <tt>io.Reader</tt><iref item="package" subitem="io"/>
as input. To fulfill the interface a type needs to implement that one method.
The writing side <tt>io.Writer</tt>, has the <tt>Write</tt> method.</t>
<t>If you think of a new type in your program or package and you make it fulfill the <tt>io.Reader</tt>
or <tt>io.Writer</tt> interface, <em>the whole standard Go library can be used</em> on that type!</t>
</section>

<section anchor="some-examples"><name>Some examples</name>
<t>The previous program reads a file in its entirety, but a more common scenario is that
you want to read a file on a line-by-line basis. The following snippet shows a way
to do just that (we're discarding the error returned from <tt>os.Open</tt> here to keep
the examples smaller -- don't ever do this in real life code).</t>

<sourcecode type="go">f, _ := os.Open(&quot;/etc/passwd&quot;); defer f.Close()
r := bufio.NewReader(f) &lt;1&gt;
s, ok := r.ReadString('\n') &lt;2&gt;
</sourcecode>
<t>At <em>1</em> make <tt>f</tt> a <tt>bufio</tt> to have access to the <tt>ReadString</tt> method. Then at <em>2</em> we read
a line from the input, <tt>s</tt>  now holds a string which we can manipulate with, for instance,
the <tt>strings</tt> package.</t>
<t>A more robust method (but slightly more complicated) is <tt>ReadLine</tt>, see the documentation
of the <tt>bufio</tt> package.</t>
<t>A common scenario in shell scripting is that you want to check if a directory
exists and if not, create one.</t>

<sourcecode type="go">if [ ! -e name ]; then          if f, e := os.Stat(&quot;name&quot;); e != nil {
    mkdir name                      os.Mkdir(&quot;name&quot;, 0755)
else                            } else {
    # error                         // error
fi                              }
</sourcecode>
<t>The similarity between these two examples (and with other scripting languages)
have prompted comments that Go has a &quot;script&quot;-like feel to it, i.e. programming
in Go can be compared to programming in an interpreted language (Python, Ruby,
Perl or PHP).</t>
</section>

<section anchor="command-line-arguments"><name>Command line arguments</name>
<t>Arguments from the command line are available inside your program via the string
slice <tt>os.Args</tt>, provided you have imported the package <tt>os</tt>. The <tt>flag</tt> package
<iref item="package" subitem="flag"/>
has a more sophisticated interface, and also provides a way to parse flags. Take
this example from a DNS query tool:</t>

<sourcecode type="go">dnssec := flag.Bool(&quot;dnssec&quot;, false, &quot;Request DNSSEC records&quot;) &lt;1&gt;
port := flag.String(&quot;port&quot;, &quot;53&quot;, &quot;Set the query port&quot;) &lt;2&gt;
flag.Usage = func() {   &lt;3&gt;
    fmt.Fprintf(os.Stderr, &quot;Usage: %s [OPTIONS] [name ...]\n&quot;, os.Args[0])
    flag.PrintDefaults() &lt;4&gt;
}
flag.Parse() &lt;4&gt;
</sourcecode>
<t>At <em>1</em> we define a <tt>bool</tt> flag <tt>-dnssec</tt>. Note that this function returns
a <em>pointer</em> to the value, the <tt>dnssec</tt> is now a pointer to a <tt>bool</tt>. At <em>2</em> we
define an <tt>strings</tt> flag. Then at <em>3</em> we <em>redefine</em> the <tt>Usage</tt> variable of the
flag package so we can add some extra text. The <tt>PrintDefaults</tt> at <em>4</em> will
output the default help for the flags that are defined. Note even without
redefining a <tt>flag.Usage</tt> the flag <tt>-h</tt> is supported and will just output the help text
for each of the flags. Finally at <em>4</em> we call <tt>Parse</tt> that parses the command
line and fills the variables.</t>
<t>After the flags have been parsed you can used them: <tt>if *dnssec { ... }</tt></t>
</section>

<section anchor="executing-commands"><name>Executing commands</name>
<t>The <tt>os/exec</tt><iref item="package" subitem="os/exec"/> package has functions to run external
commands, and is the premier way to execute commands from within a Go program.
It works by defining a <tt>*exec.Cmd</tt> structure for which it defines a number of
methods. Let's execute <tt>ls -l</tt>:</t>

<sourcecode type="go">import &quot;os/exec&quot;

cmd := exec.Command(&quot;/bin/ls&quot;, &quot;-l&quot;)
err := cmd.Run()
</sourcecode>
<t>The above example just runs &quot;ls -l&quot; without doing anything with the returned
data, capturing the standard output from a command is done as follows:</t>

<sourcecode type="go">cmd := exec.Command(&quot;/bin/ls&quot;, &quot;-l&quot;)
buf, err := cmd.Output()
</sourcecode>
<t>And <tt>buf</tt> is byte slice, that you can further use in your program.</t>
</section>

<section anchor="networking"><name>Networking</name>
<t>All network related types and functions can be found in the package <tt>net</tt>. One
of the most important functions in there is <tt>Dial</tt><iref item="networking" subitem="Dial"/>. When
you <tt>Dial</tt> into a remote system the function returns a <tt>Conn</tt> interface type,
which can be used to send and receive information. The function <tt>Dial</tt> neatly
abstracts away the network family and transport. So IPv4 or IPv6, TCP or UDP can
all share a common interface.</t>
<t>Dialing a remote system (port 80) over TCP, then UDP and lastly TCP over IPv6
looks like this:</t>

<sourcecode type="go">conn, e := Dial(&quot;tcp&quot;, &quot;192.0.32.10:80&quot;)
conn, e := Dial(&quot;udp&quot;, &quot;192.0.32.10:80&quot;)
conn, e := Dial(&quot;tcp&quot;, &quot;[2620:0:2d0:200::10]:80&quot;)
</sourcecode>
<t>If there were no errors (returned in <tt>e</tt>), you can use <tt>conn</tt> to read and write.
And <tt>conn</tt> implements the <tt>io.Reader</tt> and <tt>io.Writer</tt> interface. </t>
<t>But these are the low level nooks and crannies, you will almost always use
higher level packages, such as the <tt>http</tt> package. For instance a simple Get for
http:</t>

<sourcecode type="go">package main

import (
    &quot;fmt&quot;
    &quot;http&quot;
    &quot;io/ioutil&quot;
)

func main() {
    r, err := http.Get(&quot;http://www.google.com/robots.txt&quot;)
    if err != nil {
        fmt.Printf(&quot;%s\n&quot;, err.String())
        return
    }
    b, err := ioutil.ReadAll(r.Body)
    r.Body.Close()
    if err == nil {
        fmt.Printf(&quot;%s&quot;, string(b))
    }
}
</sourcecode>
</section>

<section anchor="exercises-6"><name>Exercises</name>

<section anchor="finger-daemon"><name>Finger daemon</name>
<t>Write a finger daemon that works with the finger(1) command.</t>
<t>From the <eref target="https://www.debian.org">Debian</eref> package description:</t>
<blockquote><t>Fingerd is a simple daemon based on RFC 1196 <xref target="RFC1196"></xref> that provides an interface to the
&quot;finger&quot; program at most network sites.  The program is supposed to return a
friendly, human-oriented status report on either the system at the moment or a
particular person in depth.</t>
</blockquote><t>Stick to the basics and only support a username argument. If the user has a <tt>.plan</tt> file
show the contents of that file. So your program needs to be able to figure out:</t>

<ul>
<li><t>Does the user exist?</t>
</li>
<li><t>If the user exists, show the contents of the <tt>.plan</tt> file.</t>
</li>
</ul>
</section>

<section anchor="answer-23"><name>Answer</name>

<aside><t>This solution is from Fabian Becker.</t>
</aside>

<sourcecode type="go">package main

import (
	&quot;bufio&quot;
	&quot;errors&quot;
	&quot;flag&quot;
	&quot;io/ioutil&quot;
	&quot;net&quot;
	&quot;os/user&quot;
)

func main() {
	flag.Parse()
	ln, err := net.Listen(&quot;tcp&quot;, &quot;:79&quot;)
	if err != nil {
		panic(err)
	}
	for {
		conn, err := ln.Accept()
		if err != nil {
			continue
		}
		go handleConnection(conn)
	}
}

func handleConnection(conn net.Conn) {
	defer conn.Close()
	reader := bufio.NewReader(conn)
	usr, _, _ := reader.ReadLine()

	if info, err := getUserInfo(string(usr)); err != nil {
		conn.Write([]byte(err.Error()))
	} else {
		conn.Write(info)
	}
}

func getUserInfo(usr string) ([]byte, error) {
	u, e := user.Lookup(usr)
	if e != nil {
		return nil, e
	}
	data, err := ioutil.ReadFile(u.HomeDir + &quot;.plan&quot;)
	if err != nil {
		return data, errors.New(&quot;User doesn't have a .plan file!\n&quot;)
	}
	return data, nil
}
</sourcecode>
</section>

<section anchor="echo-server"><name>Echo server</name>
<t>Write a simple echo server. Make it listen to TCP port number 8053 on localhost.
It should be able to read a line (up to the newline), echo back that line and
then close the connection.</t>
<t>Make the server concurrent so that every request is taken care of in a separate
goroutine.</t>
</section>

<section anchor="answer-24"><name>Answer</name>
<t>A simple echo server might be:</t>

<sourcecode type="go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;net&quot;
)

func main() {
	l, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8053&quot;)
	if err != nil {
		fmt.Printf(&quot;Failure to listen: %s\n&quot;, err.Error())
	}
	for {
		if c, err := l.Accept(); err == nil {
			Echo(c)
		}
	}
}

func Echo(c net.Conn) {
	defer c.Close()
	line, err := bufio.NewReader(c).ReadString('\n')
	if err != nil {
		fmt.Printf(&quot;Failure to read: %s\n&quot;, err.Error())
		return
	}
	_, err = c.Write([]byte(line))
	if err != nil {
		fmt.Printf(&quot;Failure to write: %s\n&quot;, err.Error())
		return
	}
}
</sourcecode>
<t>When started you should see the following:</t>

<artwork>% nc 127.0.0.1 8053
Go is *awesome*
Go is *awesome*
</artwork>
<t>To make the connection handling concurrent we <em>only need to change one line</em> in our
echo server, the line:</t>

<sourcecode type="go">if c, err := l.Accept(); err == nil { Echo(c) }
</sourcecode>
<t>becomes:</t>

<sourcecode type="go">if c, err := l.Accept(); err == nil { go Echo(c) }
</sourcecode>
</section>

<section anchor="word-and-letter-count"><name>Word and Letter Count</name>
<t>Write a small program that reads text from standard input and performs the
following actions:</t>

<ul>
<li><t>Count the number of characters (including spaces).</t>
</li>
<li><t>Count the number of words.</t>
</li>
<li><t>Count the numbers of lines</t>
</li>
</ul>
<t>In other words implement wc(1) (check you local manual page), however you only
have to read from standard input.</t>
</section>

<section anchor="answer-25"><name>Answer</name>
<t>The following program is an implementation of wc(1).</t>

<sourcecode type="go">package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {
	var chars, words, lines int
	r := bufio.NewReader(os.Stdin) &lt;1&gt;
	for {
		switch s, ok := r.ReadString('\n'); true { &lt;2&gt;
		case ok != nil: &lt;3&gt;
			fmt.Printf(&quot;%d %d %d\n&quot;, chars, words, lines)
			return
		default: &lt;4&gt;
			chars += len(s)
			words += len(strings.Fields(s))
			lines++
		}
	}
}
</sourcecode>
<t>At <em>1</em> we create a new reader that reads from standard input, we then read from
the input at <em>2</em>. And at <em>3</em> we check the value of <tt>ok</tt> and if we received an
error, we assume it was because of a EOF, So we print the current values;.
Otherwise <em>4</em> we count the charaters, words and increment the number lines.</t>
</section>

<section anchor="uniq"><name>Uniq</name>
<t>Write a Go program that mimics the function of the Unix <tt>uniq</tt> command. This
program should work as follows, given a list with the following items:</t>

<artwork>'a' 'b' 'a' 'a' 'a' 'c' 'd' 'e' 'f' 'g'
</artwork>
<t>it should print only those items which don't have the same successor:</t>

<artwork>'a' 'b' 'a' 'c' 'd' 'e' 'f' 'g'
</artwork>
<t>The next listing is a Perl implementation of the algorithm.</t>

<sourcecode type="pl">#!/usr/bin/perl
my @a = qw/a b a a a c d e f g/;
print my $first = shift @a;
foreach (@a) {
    if ($first ne $_) { print; $first = $_; }
}
</sourcecode>
</section>

<section anchor="answer-26"><name>Answer</name>
<t>The following is a <tt>uniq</tt> implementation in Go.</t>

<sourcecode type="go">package main

import &quot;fmt&quot;

func main() {
	list := []string{&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;}
	first := list[0]

	fmt.Printf(&quot;%s &quot;, first)
	for _, v := range list[1:] {
		if first != v {
			fmt.Printf(&quot;%s &quot;, v)
			first = v
		}
	}
}
</sourcecode>
</section>

<section anchor="quine"><name>Quine</name>
<t>A <em>Quine</em> is a program that prints itself. Write a Quine in Go.</t>
</section>

<section anchor="answer-27"><name>Answer</name>

<aside><t>This solution is from Russ Cox. It was posted to the Go Nuts mailing list.</t>
</aside>

<sourcecode type="go">/* Go quine */
package main
import &quot;fmt&quot;
func main() {
 fmt.Printf(&quot;%s%c%s%c\n&quot;, q, 0x60, q, 0x60)
}
var q = `/* Go quine */
package main
import &quot;fmt&quot;
func main() {
 fmt.Printf(&quot;%s%c%s%c\n&quot;, q, 0x60, q, 0x60)
}
var q = `
</sourcecode>
</section>

<section anchor="processes"><name>Processes</name>
<t>Write a program that takes a list of all running processes and prints how many
child processes each parent has spawned. The output should look like:</t>

<artwork>Pid 0 has 2 children: [1 2]
Pid 490 has 2 children: [1199 26524]
Pid 1824 has 1 child: [7293]
</artwork>

<ul>
<li><t>For acquiring the process list, you'll need to capture the output of <tt>ps -e
-opid,ppid,comm</tt>. This output looks like:</t>

<artwork>  PID  PPID COMMAND
 9024  9023 zsh
19560  9024 ps
</artwork>
</li>
<li><t>If a parent has one child you must print <tt>child</tt>, if there is more than one
print <tt>children</tt>.</t>
</li>
<li><t>The process list must be numerically sorted, so you start with pid 0 and work
your way up.</t>
</li>
</ul>
<t>Here is a Perl version to help you on your way (or to create complete and utter confusion).</t>

<sourcecode type="pl">#!/usr/bin/perl -l
my (%child, $pid, $parent);
my @ps=`ps -e -opid,ppid,comm`;	  # capture the output from `ps`
foreach (@ps[1..$#ps]) {	  # discard the header line
  ($pid, $parent, undef) = split; # split the line, discard 'comm'
  push @{$child{$parent}}, $pid;  # save the child PIDs on a list
}
# Walk through the sorted PPIDs
foreach (sort { $a &lt;=&gt; $b } keys %child) {
  print &quot;Pid &quot;, $_, &quot; has &quot;, @{$child{$_}}+0, &quot; child&quot;,
    @{$child{$_}} == 1 ? &quot;: &quot; : &quot;ren: &quot;, &quot;[@{$child{$_}}]&quot;;
}
</sourcecode>
</section>

<section anchor="answer-28"><name>Answer</name>
<t>There is lots of stuff to do here. We can divide our program
up in the following sections:</t>

<ul>
<li><t>Starting \verb|ps| and capturing the output.</t>
</li>
<li><t>Parsing the output and saving the child PIDs for each PPID.</t>
</li>
<li><t>Sorting the PPID list.</t>
</li>
<li><t>Printing the sorted list to the screen.</t>
</li>
</ul>
<t>In the solution presented below, we've used a <tt>map[int][]int</tt>, i.e. a map
indexed with integers, pointing to a slice of ints -- which holds the PIDs. The
builtin <tt>append</tt> is used to grow the integer slice.</t>
<t>A possible program is:</t>

<sourcecode type="go">package main

import (
	&quot;fmt&quot;
	&quot;os/exec&quot;
	&quot;sort&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
)

func main() {
	ps := exec.Command(&quot;ps&quot;, &quot;-e&quot;, &quot;-opid,ppid,comm&quot;)
	output, _ := ps.Output()
	child := make(map[int][]int)
	for i, s := range strings.Split(string(output), &quot;\n&quot;) {
		if i == 0 { // kill first line
			continue
		}
		if len(s) == 0 { // kill last line
			continue
		}
		f := strings.Fields(s)
		fpp, _ := strconv.Atoi(f[1]) // parent's pid
		fp, _ := strconv.Atoi(f[0])  // child's pid
		child[fpp] = append(child[fpp], fp)
	}
	schild := make([]int, len(child))
	i := 0
	for k, _ := range child {
		schild[i] = k
		i++
	}
	sort.Ints(schild)
	for _, ppid := range schild {
		fmt.Printf(&quot;Pid %d has %d child&quot;, ppid, len(child[ppid]))
		if len(child[ppid]) == 1 {
			fmt.Printf(&quot;: %v\n&quot;, child[ppid])
			continue
		}
		fmt.Printf(&quot;ren: %v\n&quot;, child[ppid])
	}
}
</sourcecode>
</section>

<section anchor="number-cruncher"><name>Number cruncher</name>

<ul>
<li><t>Pick six (6) random numbers from this list: <tt>1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
25, 50, 75, 100</tt> Numbers may be picked multiple times.</t>
</li>
<li><t>Pick one (1) random number (<tt>i</tt>) in the range: <tt>1 \ldots 1000</tt>.</t>
</li>
<li><t>Tell how, by combining the first 6 numbers (or a subset thereof)
with the operators <tt>+,-,*</tt> and <tt>/</tt>, you can make <tt>i</tt>.</t>
</li>
</ul>
<t>An example. We have picked the numbers: 1, 6, 7, 8, 8 and 75. And <tt>i</tt> is
977. This can be done in many different ways, one way is:
<tt> ((((1 * 6) * 8) + 75) * 8) - 7 = 977</tt>
or
<tt> (8*(75+(8*6)))-(7/1) = 977</tt></t>
<t>Implement a number cruncher that works like that. Make it print the solution in
a similar format (i.e. output should be infix with parenthesis) as used above.</t>
<t>Calculate <em>all</em> possible solutions and show them (or only show how many there
are). In the example above there are 544 ways to do it.</t>
</section>

<section anchor="answer-29"><name>Answer</name>
<t>The following is one possibility. It uses recursion and backtracking to get
an answer. When starting <tt>permrec</tt> we give 977 as the first argument:</t>

<artwork>% ./permrec 977
1+(((6+7)*75)+(8/8)) = 977  #1
...                         ...
((75+(8*6))*8)-7 = 977      #542
(((75+(8*6))*8)-7)*1 = 977  #543
(((75+(8*6))*8)-7)/1 = 977  #544
</artwork>

<sourcecode type="go">package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;strconv&quot;
)

const (
	_ = 1000 * iota
	ADD
	SUB
	MUL
	DIV
	MAXPOS = 11
)

var mop = map[int]string{ADD: &quot;+&quot;, SUB: &quot;-&quot;, MUL: &quot;*&quot;, DIV: &quot;/&quot;}
var (
	ok    bool
	value int
)

type Stack struct {
	i    int
	data [MAXPOS]int
}

func (s *Stack) Reset()     { s.i = 0 }
func (s *Stack) Len() int   { return s.i }
func (s *Stack) Push(k int) { s.data[s.i] = k; s.i++ }
func (s *Stack) Pop() int   { s.i--; return s.data[s.i] }

var found int
var stack = new(Stack)

func main() {
	flag.Parse()
	list := []int{1, 6, 7, 8, 8, 75, ADD, SUB, MUL, DIV}
	magic, ok := strconv.Atoi(flag.Arg(0)) // Arg0 is i
	if ok != nil {
		return
	}
	f := make([]int, MAXPOS)
	solve(f, list, 0, magic)
}

func solve(form, numberop []int, index, magic int) {
	var tmp int
	for i, v := range numberop {
		if v == 0 {
			goto NEXT
		}
		if v &lt; ADD { // it's a number, save it
			tmp = numberop[i]
			numberop[i] = 0
		}
		form[index] = v
		value, ok = rpncalc(form[0 : index+1])

		if ok &amp;&amp; value == magic {
			if v &lt; ADD {
				numberop[i] = tmp // reset and go on
			}
			found++
			fmt.Printf(&quot;%s = %d  #%d\n&quot;, rpnstr(form[0:index+1]), value, found)
		}

		if index == MAXPOS-1 {
			if v &lt; ADD {
				numberop[i] = tmp // reset and go on
			}
			goto NEXT
		}
		solve(form, numberop, index+1, magic)
		if v &lt; ADD {
			numberop[i] = tmp // reset and go on
		}
	NEXT:
	}
}

func rpnstr(r []int) (ret string) { // Convert rpn to infix notation
	s := make([]string, 0) // Still memory intensive
	for k, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
			var a, b string
			a, s = s[len(s)-1], s[:len(s)-1]
			b, s = s[len(s)-1], s[:len(s)-1]
			if k == len(r)-1 {
				s = append(s, b+mop[t]+a)
			} else {
				s = append(s, &quot;(&quot;+b+mop[t]+a+&quot;)&quot;)
			}
		default:
			s = append(s, strconv.Itoa(t))
		}
	}
	for _, v := range s {
		ret += v
	}
	return
}

func rpncalc(r []int) (int, bool) {
	stack.Reset()
	for _, t := range r {
		switch t {
		case ADD, SUB, MUL, DIV:
			if stack.Len() &lt; 2 {
				return 0, false
			}
			a := stack.Pop()
			b := stack.Pop()
			if t == ADD {
				stack.Push(b + a)
			}
			if t == SUB {
				// disallow negative subresults
				if b-a &lt; 0 {
					return 0, false
				}
				stack.Push(b - a)
			}
			if t == MUL {
				stack.Push(b * a)
			}
			if t == DIV {
				if a == 0 {
					return 0, false
				}
				// disallow fractions
				if b%a != 0 {
					return 0, false
				}
				stack.Push(b / a)
			}
		default:
			stack.Push(t)
		}
	}
	if stack.Len() == 1 { // there is only one!
		return stack.Pop(), true
	}
	return 0, false
}
</sourcecode>
</section>
</section>
</section>

</middle>

<back>
<references><name>Informative References</name>
<reference anchor="cite_fizzbuzz">
  <front>
    <title>Using fizzbuzz to find developers...</title>
    <author fullname="Imran On Tech" initials="I. O." surname="Tech" />
    <date year="2010" />
  </front>
</reference>
<reference anchor="go_1_5_release_notes">
  <front>
    <title>Go 1.5 Release Notes</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="https://golang.org/doc/go1.5" />
</reference>
<reference anchor="go_course_day3">
  <front>
    <title>The Go programming language, day 3</title>
    <author fullname="Rob Pike" initials="R." surname="Pike" />
    <date year="2010" />
  </front>
  <format type="PDF" target="http://golang.org/doc/GoCourseDay3.pdf" />
</reference>
<reference anchor="iota">
  <front>
    <title>Iota</title>
    <author fullname="Wikipedia" initials="" surname="Wikipedia" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://en.wikipedia.org/wiki/Iota" />
</reference>
<reference anchor="csp">
  <front>
    <title>Communicating sequential processes (csp)</title>
    <author fullname="C. A. R. Hoare" initials="C. A. R." surname="Hoare" />
    <date year="1985" />
  </front>
  <format type="PDF" target="http://www.usingcsp.com/cspbook.pdf" />
</reference>
<reference anchor="go_tutorial">
  <front>
    <title>Go tutorial</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://golang.org/doc/go_tutorial.html" />
</reference>
<reference anchor="go_blog_panic">
  <front>
    <title>Defer, panic, and recover</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="https://blog.golang.org/defer-panic-and-recover" />
</reference>
<reference anchor="go_spec">
  <front>
    <title>Go language specification</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target=" http://golang.org/doc/go_spec.html" />
</reference>
<reference anchor="RFC1196">
  <front>
    <title>The finger user information protocol</title>
    <author fullname="D. Zimmerman" initials="D." surname="Zimmerman" />
    <date year="1990" />
  </front>
  <format type="TXT" target="http://www.ietf.org/rfc/rfc1196.txt" />
</reference>
<reference anchor="go_interfaces">
  <front>
    <title>Go interfaces</title>
    <author fullname="Ian Lance Taylor" initials="I. L." surname="Taylor" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://www.airs.com/blog/archives/277" />
</reference>
<reference anchor="go_web">
  <front>
    <title>Go website</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://golang.org/" />
</reference>
<reference anchor="effective_go">
  <front>
    <title>Effective Go</title>
    <author fullname="Go Authors" initials="G." surname="Authors" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://golang.org/doc/effective_go.html" />
</reference>
<reference anchor="bubblesort">
  <front>
    <title>Bubble sort</title>
    <author fullname="Wikipedia" initials="" surname="Wikipedia" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://en.wikipedia.org/wiki/Bubble_sort" />
</reference>
<reference anchor="duck_typing">
  <front>
    <title>Duck typing</title>
    <author fullname="Wikipedia" initials="" surname="Wikipedia" />
    <date year="2010" />
  </front>
  <format type="HTML" target="http://en.wikipedia.org/wiki/Duck_typing" />
</reference>
<reference anchor="RFC4627">
  <front>
    <title>The application/json media type for javascript object notation (json)</title>
    <author fullname="D. Crockford" initials="D." surname="Crockford" />
    <date year="2006" />
  </front>
  <format type="TXT" target="http://www.ietf.org/rfc/rfc4627.txt" />
</reference>
<reference anchor="go_nuts_interfaces">
  <front>
    <title>Function accepting a slice of interface types</title>
    <author fullname="Go Community" initials="G." surname="Community" />
    <date year="2010" />
  </front>
</reference>
</references>
</back>

</rfc>
