<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.10 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-cbor-cddl-latest" category="std">

  <front>
    <title abbrev="CDDL">Concise data definition language (CDDL): a notational convention to express CBOR and JSON data structures</title>

    <author initials="H." surname="Birkholz" fullname="Henk Birkholz">
      <organization abbrev="Fraunhofer SIT">Fraunhofer SIT</organization>
      <address>
        <postal>
          <street>Rheinstrasse 75</street>
          <city>Darmstadt</city>
          <code>64295</code>
          <country>Germany</country>
        </postal>
        <email>henk.birkholz@sit.fraunhofer.de</email>
      </address>
    </author>
    <author initials="C." surname="Vigano" fullname="Christoph Vigano">
      <organization abbrev="Universität Bremen">Universität Bremen</organization>
      <address>
        <email>christoph.vigano@uni-bremen.de</email>
      </address>
    </author>
    <author initials="C." surname="Bormann" fullname="Carsten Bormann">
      <organization>Universitaet Bremen TZI</organization>
      <address>
        <postal>
          <street>Bibliothekstr. 1</street>
          <city>Bremen</city>
          <code>D-28359</code>
          <country>Germany</country>
        </postal>
        <phone>+49-421-218-63921</phone>
        <email>cabo@tzi.org</email>
      </address>
    </author>

    <date year="2019" month="February" day="12"/>

    <area>Applications</area>
    <workgroup>CBOR</workgroup>
    

    <abstract>


<t>This document proposes a notational convention to express CBOR data
structures (RFC 7049, Concise Binary Object Representation).
Its main goal is to provide an easy and unambiguous way to express structures
for protocol messages and data formats that use CBOR or JSON.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>In this document,
a notational convention to express CBOR <xref target="RFC7049"/> data structures is defined.</t>

<t>The main goal for the convention is to provide a unified notation that can
be used when defining protocols that use CBOR.  We term the convention
“Concise data definition language”, or CDDL.</t>

<t>The CBOR notational convention has the following goals:</t>

<t><list style="format (G%d)">
  <t>Provide an unambiguous description of the overall structure of a CBOR data item.</t>
  <t>Be flexible in expressing the multiple ways in which data can be
represented in the CBOR data format.</t>
  <t>Able to express common CBOR datatypes and structures.</t>
  <t>Provide a single format that is both readable and editable for
humans and processable by machine.</t>
  <t>Enable automatic checking of CBOR data items for data format compliance.</t>
  <t>Enable extraction of specific elements from CBOR data for further processing.</t>
</list></t>

<t>Not an original goal per se, but a convenient side effect of the JSON
generic data model being a subset of the CBOR generic data model, is
the fact that CDDL can also be used for describing JSON data
structures (see <xref target="sec-json"/>).</t>

<t>This document has the following structure:</t>

<t>The syntax of CDDL is defined in <xref target="syntax"/>.
Examples of CDDL and related CBOR data items (“instances”, which all
happen to be in JSON form) are given in
<xref target="examples"/>. <xref target="usage"/> discusses usage of CDDL. Examples are provided
early in the text to better illustrate concept definitions.
A formal definition of CDDL using ABNF grammar is provided in <xref target="abnf"/>.
Finally, a <spanx style="emph">prelude</spanx> of standard CDDL definitions that is
automatically prepended to and thus available in every
CBOR specification is listed in <xref target="prelude"/>.</t>

<section anchor="requirements-notation" title="Requirements notation">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL
NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”,
“MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they
appear in all capitals, as shown here.</t>

</section>
<section anchor="terminology" title="Terminology">

<t>New terms are introduced in <spanx style="emph">cursive</spanx>, which is rendered in plain text
as the new term surrouded by underscores.
CDDL text in the running text is in <spanx style="verb">typewriter</spanx>, which is rendered in
plain text as the CDDL text in double quotes (double quotes are also
used in the usual English sense; the reader is expected to
disambiguate this by context).</t>

<t>In this specification, the term “byte” is used in its now customary
sense as a synonym for “octet”.</t>

</section>
</section>
<section anchor="the-style-of-data-structure-specification" title="The Style of Data Structure Specification">

<t>CDDL focuses on styles of specification that are in use in the
community employing the data model as pioneered by JSON and now
refined in CBOR.</t>

<t>There are a number of more or less atomic elements of a CBOR data
model, such as numbers, simple values (false, true, nil), text and
byte strings;
CDDL does not focus on specifying their structure.  CDDL of course
also allows adding a CBOR tag to a data item.</t>

<t>Beyond those atomic elements, further components of a
data structure definition language
are the data types used for composition: arrays and maps in CBOR
(called arrays and objects in JSON).  While these are only two
representation formats, they are used to specify four loosely
distinguishable styles of composition:</t>

<t><list style="symbols">
  <t>A <spanx style="emph">vector</spanx>, an array of elements that are mostly of the same
semantics.  The set of signatures associated with a signed data item
is a typical application of a vector.</t>
  <t>A <spanx style="emph">record</spanx>, an array the elements of which have different,
positionally defined semantics, as detailed in the data structure
definition.  A 2D point, specified as an array of an x coordinate
(which comes first) and a y coordinate (coming second) is an example
of a record, as is the pair of exponent (first) and mantissa
(second) in a CBOR decimal fraction.</t>
  <t>A <spanx style="emph">table</spanx>, a map from a domain of map keys to a domain of map
values, that are mostly of the same semantics.  A set of language
tags, each mapped to a text string translated to that specific language,
is an example of a table.  The key domain is usually not limited to
a specific set by the specification, but open for the
application, e.g., in a table mapping IP addresses to MAC addresses,
the specification does not attempt to foresee all possible IP
addresses.
In a language such as JavaScript, a <spanx style="verb">Map</spanx> (as opposed to a plain
<spanx style="verb">Object</spanx>) would often be employed to achieve the generality of the
key domain.</t>
  <t>A <spanx style="emph">struct</spanx>, a map from a domain of map keys as defined by the
specification to a domain of map values the semantics of each of
which is bound to a specific map key.  This is what many people have
in mind when they think about JSON objects; CBOR adds the ability to
use map keys that are not just text strings.  Structs can be used to
solve similar problems as records; the use of explicit map keys
facilitates optionality and extensibility.</t>
</list></t>

<t>Two important concepts provide the foundation for CDDL:</t>

<t><list style="numbers">
  <t>Instead of defining all four types of composition in CDDL separately,
or even defining one kind for arrays (vectors and records) and one
kind for maps (tables and structs), there is only one kind of
composition in CDDL: the <spanx style="emph">group</spanx> (<xref target="group"/>).</t>
  <t>The other important concept is that of a <spanx style="emph">type</spanx>.  The entire CDDL
specification defines a type (the one defined by its first <spanx style="emph">rule</spanx>),
which formally is the set of CBOR data items that are acceptable as
“instances” for
this specification.  CDDL predefines a number of basic types such as
<spanx style="verb">uint</spanx> (unsigned integer) or <spanx style="verb">tstr</spanx> (text string), often making use of
a simple formal notation for CBOR data items.  Each value that
can be expressed as a CBOR data item also is a type in its own right,
e.g. <spanx style="verb">1</spanx>.  A type can be built as a <spanx style="emph">choice</spanx> of other types, e.g., an
<spanx style="verb">int</spanx> is either a <spanx style="verb">uint</spanx> or a <spanx style="verb">nint</spanx> (negative integer).
Finally, a type can be built as an array or a map from a group.</t>
</list></t>

<t>The rest of this section introduces a number of basic concepts of
CDDL, and <xref target="syntax"/> defines additional syntax.
<xref target="matching"/> gives a concise summary of the semantics of CDDL.</t>

<section anchor="group" title="Groups and Composition in CDDL">

<t>CDDL Groups are lists of group <spanx style="emph">entries</spanx>, each of which can be a
name/value pair or a more complex group expression (which then in turn
stands for a sequence of name/value pairs).  A CDDL group is a
production in a grammar that matches certain sequences of name/value pairs but not others.
The grammar is based on the concepts of Parsing Expression Grammars
(see <xref target="sec-peg"/>).</t>

<t>In an array context, only the value of the name/value pair is represented; the name is
annotation only (and can be left off from the group specification if not needed).
In a map context, the names become the map keys (“member keys”).</t>

<t>In an array context, the actual sequence of elements in the group is
important, as that sequence is the information that allows associating actual
array elements with entries in the group.
In a map context, the sequence of entries in a group is not relevant
(but there is still a need to write down group entries in a sequence).</t>

<t>An array matches a specification given as a group when the group
matches a sequence of name/value pairs the value parts of which
exactly match the elements of the array in order.</t>

<t>A map matches a specification given as a group when the group
matches a sequence of name/value pairs such that all of these
name/value pairs are present in the map and the map has no name/value
pair that is not covered by the group.</t>

<t>A simple example of using a group directly in a map definition is:</t>

<figure title="Using a group directly in a map" anchor="group-in-map"><artwork type="CDDL" align="center"><![CDATA[
person = {
  age: int,
  name: tstr,
  employer: tstr,
}
]]></artwork></figure>

<t>The three entries of the group are written between the curly braces
that create the map:
Here, “age”, “name”, and “employer” are the names that turn into the
map key text strings, and “int” and “tstr” (text string) are the types
of the map values under these keys.</t>

<t>A group by itself (without creating a map around it) can be placed in
(round) parentheses, and given a name by using it in a rule:</t>

<figure title="A basic group" anchor="basic-group"><artwork type="CDDLx" align="center"><![CDATA[
pii = (
  age: int,
  name: tstr,
  employer: tstr,
)
]]></artwork></figure>

<t>This separate, named group definition allows us to rephrase <xref target="group-in-map"/> as:</t>

<figure title="Using a group by name" anchor="group-by-name"><artwork type="CDDLx" align="center"><![CDATA[
person = {
  pii
}
]]></artwork></figure>

<t>Note that the (curly) braces signify the creation of a map; the groups
themselves are neutral as to whether they will be used in a map or an array.</t>

<t>As shown in <xref target="group-in-map"/>, the parentheses for groups are optional
when there is some other set of brackets present.  Note that they can
still be used, leading to the not so realistic, but perfectly valid example:</t>

<figure title="Using a parenthesized group in a map" anchor="paren-group-in-map"><artwork type="CDDL" align="center"><![CDATA[
person = {(
  age: int,
  name: tstr,
  employer: tstr,
)}
]]></artwork></figure>

<t>Groups can be used to factor out common parts of structs, e.g.,
instead of writing copy/paste style specifications such as in
<xref target="group_redundancy"/>, one can factor out the common subgroup, choose a
name for it, and write only the specific parts into the individual
maps (<xref target="group_factorization"/>).</t>

<figure title="Maps with copy/paste" anchor="group_redundancy"><artwork type="CDDL" align="center"><![CDATA[
person = {
  age: int,
  name: tstr,
  employer: tstr,
}

dog = {
  age: int,
  name: tstr,
  leash-length: float,
}
]]></artwork></figure>

<figure title="Using a group for factorization" anchor="group_factorization"><artwork type="CDDL" align="center"><![CDATA[
person = {
  identity,
  employer: tstr,
}

dog = {
  identity,
  leash-length: float,
}

identity = (
  age: int,
  name: tstr,
)
]]></artwork></figure>

<t>Note that the lists inside the braces in the above definitions
constitute (anonymous) groups, while <spanx style="verb">identity</spanx> is a named group.</t>

<section anchor="composition_usage" title="Usage">

<t>Groups are the instrument used in composing data structures with
CDDL. It is a matter of style in defining those structures whether to
define groups (anonymously) right in their contexts or whether to
define them in a separate rule and to reference them with their
respective name (possibly more than once).</t>

<t>With this, one is allowed to define all small parts of their data structures
and compose bigger protocol units with those or to have only one big
protocol data unit that has all definitions ad hoc where needed.</t>

</section>
<section anchor="composition_syntax" title="Syntax">

<t>The composition syntax is intended to be concise and easy to read:</t>

<t><list style="symbols">
  <t>The start and end of a group can be marked by ‘(‘ and ‘)’</t>
  <t>Definitions of entries inside of a group are noted as follows:
<spanx style="emph">keytype =&gt; valuetype,</spanx> (read “keytype maps to valuetype”).
The comma is actually optional (not just in the final entry), but it is
considered good style to set it.  The double arrow can be replaced by a colon
in the common case of directly using a text string or integer literal as a
key (see <xref target="structs"/>; this is also the common way of naming elements
of an array just for documentation, see <xref target="arrays"/>).</t>
</list></t>

<t>A basic entry consists of a <spanx style="emph">keytype</spanx> and a <spanx style="emph">valuetype</spanx>, both of which
are types (<xref target="types"/>); this entry matches any name-value pair the
name of which is in the keytype and the value of which is in the valuetype.</t>

<t>A group defined as a sequence of group entries matches any
sequence of name-value pairs that is composed by concatenation in
order of what the entries match.</t>

<t>A group definition can also contain choices between groups, see <xref target="choices"/>.</t>

</section>
</section>
<section anchor="types" title="Types">

<section anchor="values" title="Values">

<t>Values such as numbers and strings can be used in place of a type.
(For instance, this is a very common thing to do for a keytype, common
enough that CDDL provides additional convenience syntax for this.)</t>

<t>The value notation is based on the C language, but does not offer all
the syntactic variations (see <xref target="abnf"/> for details).  The value notation for numbers
inherits from C the distinction between integer values (no fractional
part or exponent given — NR1 <xref target="ISO6093"/>) and floating point values
(where a fractional part and/or an exponent is present — NR2 or NR3),
so the type <spanx style="verb">1</spanx> does not include any floating point numbers while the
types <spanx style="verb">1e3</spanx> and <spanx style="verb">1.5</spanx> are both floating point numbers and do not
include any integer numbers.</t>

</section>
<section anchor="choices" title="Choices">

<t>Many places that allow a type also allow a choice between types,
delimited by a “/” (slash).  The entire choice construct can be put
into parentheses if this is required to make the construction
unambiguous (please see <xref target="abnf"/> for the details).</t>

<t>Choices of values can be used to express enumerations:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
attire = "bow tie" / "necktie" / "Internet attire"
protocol = 6 / 17
]]></artwork></figure>

<t>Similarly as for types, CDDL also allows choices between groups,
delimited by a “//” (double slash).  Note that the “//” operator
binds much more weakly than the other CDDL operators, so each line
within <spanx style="verb">delivery</spanx> in
the following example is its own alternative in the group choice:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
address = { delivery }

delivery = (
street: tstr, ? number: uint, city //
po-box: uint, city //
per-pickup: true )

city = (
name: tstr, zip-code: uint
)
]]></artwork></figure>

<t>A group choice matches the union of the sets of name-value pair
sequences that the alternatives in the choice can.</t>

<t>Both for type choices and for group choices, additional alternatives
can be added to a rule later in separate rules by using “/=” and “//=”,
respectively, instead of “=”:</t>

<figure><artwork align="center"><![CDATA[
attire /= "swimwear"

delivery //= (
lat: float, long: float, drone-type: tstr
)
]]></artwork></figure>

<t>It is not an error if a name is first used with a “/=” or “//=”
(there is no need to “create it” with “=”).</t>

<section anchor="ranges" title="Ranges">

<t>Instead of naming all the values that make up a choice, CDDL allows
building a <spanx style="emph">range</spanx> out of two values that are in an ordering
relationship: A lower bound (first value) and an upper bound (second value).
A range can be inclusive of both bounds given (denoted by joining two
values by “..”), or include the lower bound and exclude the upper bound (denoted
by instead using “…”).
If the lower bound exceeds the upper bound, the resulting type is
the empty set (this behavior can be desirable when generics,
<xref target="generics"/>, are being used).</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
device-address = byte
max-byte = 255
byte = 0..max-byte ; inclusive range
first-non-byte = 256
byte1 = 0...first-non-byte ; byte1 is equivalent to byte
]]></artwork></figure>

<t>CDDL currently only allows ranges between integers (matching integer
values) or between floating point values (matching floating point
values).  If both are needed in a type, a type choice between the two
kinds of ranges can be (clumsily) used:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
int-range = 0..10 ; only integers match
float-range = 0.0..10.0 ; only floats match
BAD-range1 = 0..10.0 ; NOT DEFINED
BAD-range2 = 0.0..10 ; NOT DEFINED
numeric-range = int-range / float-range
]]></artwork></figure>

<t>(See also the control operators .lt/.ge and .le/.gt in <xref target="fortran"/>.)</t>

<t>Note that the dot is a valid name continuation character in CDDL, so</t>

<t><list style='empty'>
  <t>min..max</t>
</list></t>

<t>is not a range expression but a single name.  When using a
name as the left hand side of a range operator, use spacing as in</t>

<t><list style='empty'>
  <t>min .. max</t>
</list></t>

<t>to separate off the range operator.</t>

</section>
<section anchor="turning-a-group-into-a-choice" title="Turning a group into a choice">

<t>Some choices are built out of large numbers of values, often integers,
each of which is best given a semantic name in the specification.
Instead of naming each of these integers and then accumulating these
into a choice, CDDL allows building a choice from a group by prefixing
it with a “&amp;” character:</t>

<!-- color = [terminal-color, extended-color] -->
<figure><artwork type="CDDL" align="center"><![CDATA[
terminal-color = &basecolors
basecolors = (
  black: 0, red: 1,  green: 2,  yellow: 3,
  blue: 4,  magenta: 5,  cyan: 6,  white: 7,
)
extended-color = &(
  basecolors,
  orange: 8,  pink: 9,  purple: 10,  brown: 11,
)
]]></artwork></figure>

<t>As with the use of groups in arrays (<xref target="arrays"/>), the member names have
only documentary value (in particular, they might be used by a tool
when displaying integers that are taken from that choice).</t>

</section>
</section>
<section anchor="representation-types" title="Representation Types">

<t>CDDL allows the specification of a data item type by referring to the
CBOR representation (major types and additional information, Section 2 of <xref target="RFC7049"/>).  How this is used
should be evident from the prelude (<xref target="prelude"/>): a hash mark (<spanx style="verb">#</spanx>)
optionally followed by a number from 0 to 7 identifying the major
type, which then can be followed by a dot and a number specifying the
additional information.  This construction specifies the set of values that can be
serialized in CBOR (i.e., <spanx style="verb">any</spanx>), by the given major type if one is
given, or by the given major type with the additional information if
both are given.  Where a major type of 6 (Tag) is used, the type of
the tagged item can be specified by appending it in parentheses.</t>

<t>Note that although this notation is based on the CBOR
serialization, it is about a set of values at the data model level,
e.g. <spanx style="verb">#7.25</spanx> specifies the set of values that can be represented as
half-precision floats; it does not mandate that these values also do
have to be serialized as half-precision floats: CDDL does not provide
any language means to restrict the choice of serialization variants.
This also enables the use of CDDL with JSON, which uses a
fundamentally different way of serializing (some of) the same values.</t>

<t>It may be necessary to make use of representation types outside the
prelude, e.g., a specification could start by making use of an
existing tag in a more specific way, or define a new tag not defined
in the prelude:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
my_breakfast = #6.55799(breakfast)   ; cbor-any is too general!
breakfast = cereal / porridge
cereal = #6.998(tstr)
porridge = #6.999([liquid, solid])
liquid = milk / water
milk = 0
water = 1
solid = tstr
]]></artwork></figure>

</section>
<section anchor="root-type" title="Root type">

<t>There is no special syntax to identify the root of a CDDL data
structure definition: that role is simply taken by the first rule
defined in the file.</t>

<t>This is motivated by the usual top-down approach for defining data
structures, decomposing a big data structure unit into smaller parts;
however, except for the root type, there is no need to strictly follow
this sequence.</t>

<t>(Note that there is no way to use a group as a root – it must be a
type.)</t>

</section>
</section>
</section>
<section anchor="syntax" title="Syntax">

<t>In this section, the overall syntax of CDDL is shown, alongside some
examples just illustrating syntax.
(The definition will not attempt to be overly formal; refer to <xref target="abnf"/>
for the details.)</t>

<section anchor="general-conventions" title="General conventions">

<t>The basic syntax is inspired by ABNF <xref target="RFC5234"/>, with</t>

<t><list style="symbols">
  <t>rules, whether they define groups or types, are defined with a name,
followed by an equals sign “=” and the actual definition according
to the respective syntactic rules of that definition.</t>
  <t>A name can consist of any of the characters from the set
{‘A’ to ‘Z’, ‘a’ to ‘z’, ‘0’ to ‘9’, ‘_’, ‘-‘, ‘@’, ‘.’,
‘$’}, starting with
an alphabetic character (including ‘@’, ‘_’, ‘$’) and ending in
such a character or
or a digit.
  <list style="symbols">
      <t>Names are case sensitive.</t>
      <t>It is preferred style to start a name with a lower case letter.</t>
      <t>The hyphen is preferred over the underscore (except in a
“bareword” (<xref target="structs"/>), where the semantics may actually require an underscore).</t>
      <t>The period may be useful for larger specifications, to express
some module structure (as in <spanx style="verb">tcp.throughput</spanx>
vs. <spanx style="verb">udp.throughput</spanx>).</t>
      <t>A number of names are predefined in the CDDL prelude, as listed in <xref target="prelude"/>.</t>
      <t>Rule names (types or groups) do not appear in the actual CBOR encoding, but
names used as “barewords” in member keys do.</t>
    </list></t>
  <t>Comments are started by a ‘;’ (semicolon) character and finish at the end of a line
(LF or CRLF).</t>
  <t>outside strings, whitespace (spaces, newlines, and comments) is used
to separate syntactic elements for readability (and to separate
identifiers, range operators, or numbers that follow each other); it is otherwise
completely optional.</t>
  <t>Hexadecimal numbers are preceded by ‘0x’ (without quotes, lower case
x), and are case insensitive.  Similarly, binary numbers are preceded
by ‘0b’. <!-- ABNF borken here --></t>
  <t>Text strings are enclosed by double quotation ‘”’ characters.
They follow the conventions for strings as defined in section 7 of <xref target="RFC8259"/>.
(ABNF users may want to note that there is no support in CDDL for the
concept of case insensitivity in text strings; if necessary, regular
expressions can be used (<xref target="regexp"/>).)</t>
  <t>Byte strings are enclosed by single quotation “’” characters and may
be prefixed by “h” or “b64”.  If unprefixed, the string is interpreted
as with a text string, except that single quotes must be escaped and
that the UTF-8 bytes resulting are marked as a byte string (major type
2).
If prefixed as “h” or “b64”, the string is interpreted as a sequence
of pairs of hex digits (base16, Section 8 of <xref target="RFC4648"/>) or a
base64(url) string (Sections 4 or 5 of <xref target="RFC4648"/>),
respectively (as with the
diagnostic notation in section 6 of <xref target="RFC7049"/>; cf. <xref target="textbin"/>); any white space
present within the string (including comments) is ignored in the prefixed case.</t>
  <t>CDDL uses UTF-8 <xref target="RFC3629"/> for its encoding.</t>
</list></t>

<t>Example:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
; This is a comment
person = { g }

g = (
  "name": tstr,
  age: int,  ; "age" is a bareword
)
]]></artwork></figure>

</section>
<section anchor="occurrence" title="Occurrence">

<t>An optional <spanx style="emph">occurrence</spanx> indicator can be given in front of a
group entry.  It is either one of the characters ‘?’ (optional), ‘*’
(zero or more), or ‘+’ (one or more), or is of the form n*m, where n
and m are optional unsigned integers and n is the lower limit (default
0) and m is the upper limit (default no limit) of occurrences.</t>

<t>If no occurrence indicator is specified, the group entry is to occur exactly
once (as if 1*1 were specified).
A group entry with an occurrence indicator matches sequences of
name-value pairs that are composed by concatenating a number of sequences that the basic
group entry matches, where the number needs to be allowed by the
occurrence indicator.</t>

<t>Note that CDDL, outside any directives/annotations that could possibly
be defined, does not make any
prescription as to whether arrays or maps use the definite length or
indefinite length encoding.  I.e., there is no correlation between
leaving the size of an array “open” in the spec and the fact that it
is then interchanged with definite or indefinite length.</t>

<t>Please also note that CDDL can describe flexibility that the data
model of the target representation does not have.  This is rather
obvious for JSON, but also is relevant for CBOR:</t>

<figure><artwork type="CDDL"><![CDATA[
apartment = {
  kitchen: size,
  * bedroom: size,
}
size = float ; in m2
]]></artwork></figure>

<t>The previous specification does not mean that CBOR is changed to allow
to use the key “bedroom” more than once.  In other words, due to the
restrictions imposed by the data model, the third line pretty much turns
into:</t>

<figure><artwork type="CDDLx"><![CDATA[
  ? bedroom: size,
]]></artwork></figure>

<t>(Occurrence indicators beyond one still are useful in maps for groups
that allow a variety of keys.)</t>

</section>
<section anchor="predefined-names-for-types" title="Predefined names for types">

<t>CDDL predefines a number of names.
This subsection summarizes these names, but please see <xref target="prelude"/> for
the exact definitions.</t>

<t>The following keywords for primitive datatypes are defined:</t>

<t><list style="hanging">
  <t hangText='“bool”'>
  Boolean value (major type 7, additional information 20 or 21).</t>
  <t hangText='“uint”'>
  An unsigned integer (major type 0).</t>
  <t hangText='“nint”'>
  A negative integer (major type 1).</t>
  <t hangText='“int”'>
  An unsigned integer or a negative integer.</t>
  <t hangText='“float16”'>
  A number representable as an IEEE 754 half-precision float (major type 7, additional information 25).</t>
  <t hangText='“float32”'>
  A number representable as an IEEE 754 single-precision float (major type 7, additional information 26).</t>
  <t hangText='“float64”'>
  A number representable as an IEEE 754 double-precision float (major type 7, additional information 27).</t>
  <t hangText='“float”'>
  One of float16, float32, or float64.</t>
  <t hangText='“bstr” or “bytes”'>
  A byte string (major type 2).</t>
  <t hangText='“tstr” or “text”'>
  Text string (major type 3)</t>
</list></t>

<t>(Note that there are no predefined names for arrays or maps; these are
defined with the syntax given below.)</t>

<t>In addition, a number of types are defined in the prelude that are
associated with CBOR tags, such as <spanx style="verb">tdate</spanx>, <spanx style="verb">bigint</spanx>, <spanx style="verb">regexp</spanx> etc.</t>

</section>
<section anchor="arrays" title="Arrays">

<t>Array definitions surround a group with square brackets.</t>

<t>For each entry, an occurrence indicator as specified in <xref target="occurrence"/> is permitted.</t>

<t>For example:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
unlimited-people = [* person]
one-or-two-people = [1*2 person]
at-least-two-people = [2* person]
person = (
    name: tstr,
    age: uint,
)
]]></artwork></figure>

<t>The group <spanx style="verb">person</spanx> is defined in such a way that repeating it in the
array each time generates alternating names and ages, so these are four valid
values for a data item of type <spanx style="verb">unlimited-people</spanx>:</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
["roundlet", 1047, "psychurgy", 2204, "extrarhythmical", 2231]
[]
["aluminize", 212, "climograph", 4124]
["penintime", 1513, "endocarditis", 4084, "impermeator", 1669,
 "coextension", 865]
]]></artwork></figure>

</section>
<section anchor="maps" title="Maps">

<t>The syntax for specifying maps merits special attention, as well as a
number of optimizations and conveniences, as it is likely to be the
focal point of many specifications employing CDDL.  While the syntax
does not strictly distinguish struct and table usage of maps, it
caters specifically to each of them.</t>

<t>But first, let’s reiterate a feature of CBOR that it has inherited
from JSON: The key/value pairs in CBOR maps have no fixed ordering.
(One could imagine situations where fixing the ordering may be of use.
For example, a decoder could look for values related with integer keys
1, 3 and 7.  If the order were fixed and the decoder encounters the
key 4 without having encountered key 3, it could conclude that key 3
is not available without doing more complicated bookkeeping.
Unfortunately, neither JSON nor CBOR support this, so no attempt was
made to support this in CDDL either.)</t>

<section anchor="structs" title="Structs">

<t>The “struct” usage of maps is similar to the way JSON objects are used
in many JSON applications.</t>

<t>A map is defined in the same way as defining an array (see <xref target="arrays"/>), except
for using curly braces “{}” instead of square brackets “[]”.</t>

<t>An occurrence indicator as specified in <xref target="occurrence"/> is permitted for each
group entry.</t>

<t>The following is an example of a structure:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
Geography = [
  city           : tstr,
  gpsCoordinates : GpsCoordinates,
]

GpsCoordinates = {
  longitude      : uint,            ; multiplied by 10^7
  latitude       : uint,            ; multiplied by 10^7
}
]]></artwork></figure>

<t>When encoding, the Geography structure is encoded using a CBOR array
with two entries (the keys for the group entries are ignored),
whereas the GpsCoordinates are encoded as a CBOR map with two
key/value pairs.</t>

<t>Types used in a structure can be defined in separate rules or just in
place (potentially placed inside parentheses, such as for choices).
E.g.:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
located-samples = {
  sample-point: int,
  samples: [+ float],
}

]]></artwork></figure>

<t>where <spanx style="verb">located-samples</spanx> is the datatype to be used when referring to the struct,
and <spanx style="verb">sample-point</spanx> and <spanx style="verb">samples</spanx> are the keys to be used.
This is actually a complete example: an identifier that is followed by a
colon can be directly used as the text string for a member key (we speak of a
“bareword” member key), as can a double-quoted string or a number.
(When other types, in particular ones that contain more than one value, are used as
the types of keys, they are followed by a double arrow, see below.)</t>

<t>If a text string key does not match the syntax for an identifier (or
if the specifier just happens to prefer using double quotes), the text
string syntax can also be used in the member key position, followed by
a colon.  The above example could therefore have been written with
quoted strings in the member key positions.</t>

<t>More generally, types specified in other ways than the cases described
above can be used in a keytype position by following them with a
double arrow — in particular, the double arrow is necessary if a type
is named by an identifier (which, when followed by a colon, would
be interpreted as a “bareword” and turned into a text string).
A literal text string also gives rise to a type (which contains a single
value only — the given string), so another
form for this example is:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
located-samples = {
  "sample-point" => int,
  "samples" => [+ float],
}
]]></artwork></figure>

<t>See <xref target="cuts-in-maps"/> below for how the colon shortcut described here
also adds some implied semantics.</t>

<t>A better way to demonstrate the double-arrow use may be:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
located-samples = {
  sample-point: int,
  samples: [+ float],
  * equipment-type => equipment-tolerances,
}
equipment-type = [name: tstr, manufacturer: tstr]
equipment-tolerances = [+ [float, float]]
]]></artwork></figure>

<t>The example below defines a struct with optional entries: display name
(as a text string), the name components first name and family name (as
text strings), and age information (as an unsigned integer).</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)
]]></artwork></figure>

<t>Note that the group definition for NameComponents does not generate
another map; instead, all four keys are directly in the struct built
by PersonalData.</t>

<t>In this example, all key/value pairs are optional from the perspective of CDDL.
With no occurrence indicator, an entry is mandatory.</t>

<t>If the addition of more entries not specified by the current
specification is desired, one can add this possibility explicitly:</t>

<figure title="Personal Data: Example for extensibility" anchor="xmp-personaldata"><artwork type="CDDL" align="center"><![CDATA[
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
  * tstr => any
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)
]]></artwork></figure>

<t>The CDDL tool reported on in <xref target="tool"/> generated as one acceptable instance for this specification:</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
{"familyName": "agust", "antiforeignism": "pretzel",
 "springbuck": "illuminatingly", "exuviae": "ephemeris",
 "kilometrage": "frogfish"}
]]></artwork></figure>

<t>(See <xref target="socketplug"/> for one way to explicitly identify an extension point.)</t>

</section>
<section anchor="tables" title="Tables">

<t>A table can be specified by defining a map with entries where the
keytype allows more than just a single value, e.g.:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
square-roots = {* x => y}
x = int
y = float
]]></artwork></figure>

<t>Here, the key in each key/value pair has datatype x (defined as int),
and the value has datatype y (defined as float).</t>

<t>If the specification does not need to restrict one of x or y (i.e., the application is free to
choose per entry), it can be replaced by the predefined name <spanx style="verb">any</spanx>.</t>

<t>As another example,
the following could be used as a conversion table converting from an integer
or float to a string:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
tostring = {* mynumber => tstr}
mynumber = int / float
]]></artwork></figure>

</section>
<section anchor="non-deterministic-order" title="Non-deterministic order">

<t>While the way arrays are matched is fully determined by the Parsing
Expression Grammar (PEG) formalism (see <xref target="sec-peg"/>), matching is more complicated for
maps, as maps do not have an inherent order.
For each candidate name/value pair that the PEG algorithm would try, a
matching member is picked out of the entire map.  For certain group expressions,
more than one member in the map may match.  Most often, this is
inconsequential, as the group expression tends to consume all matches:</t>

<figure><artwork type="CDDL"><![CDATA[
labeled-values = {
  ? fritz: number,
  * label => value
}
label = text
value = number
]]></artwork></figure>

<t>Here, if any member with the key <spanx style="verb">fritz</spanx> is present, this
will be picked by the first entry of the group; all remaining
text/number member will be picked by the second entry (and if anything
remains unpicked, the map does not match).</t>

<t>However, it is possible to construct group expressions where what is
actually picked is indeterminate, and does matter:</t>

<figure><artwork type="CDDL"><![CDATA[
do-not-do-this = {
  int => int,
  int => 6,
}
]]></artwork></figure>

<t>When this expression is matched against <spanx style="verb">{3: 5, 4: 6}</spanx>, the first
group entry might pick off the <spanx style="verb">3: 5</spanx>, leaving <spanx style="verb">4: 6</spanx> for matching the
second one.  Or it might pick off <spanx style="verb">4: 6</spanx>, leaving nothing for the
second entry.  This pathological non-determinism is caused by
specifying more general before more specific, and by having a general
rule that only consumes a subset of the map key/value pairs that it is able to
match — both tend not to occur in real-world specifications of maps.  At the time
of writing, CDDL tools cannot detect such cases automatically, and for
the present version of the CDDL specification, the
specification writer is simply urged to not write pathologically
non-deterministic specifications.</t>

<t>(The astute reader will be reminded of what was called “ambiguous
content models” in SGML and “non-deterministic content models” in XML.
That problem is related to the one described here, but the problem
here is specifically caused by the lack of order in maps, something
that the XML schema languages do not have to contend with.  Note that
Relax-NG’s <spanx style="verb">interleave</spanx> pattern handles lack of order explicitly on the
specification side, while the instances in XML always have determinate
order.)</t>

</section>
<section anchor="cuts-in-maps" title="Cuts in Maps">

<t>The extensibility idiom discussed above for structs has one problem:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
extensible-map-example = {
  ? "optional-key" => int,
  * tstr => any
}
]]></artwork></figure>

<t>In this example, there is one optional key “optional-key”, which, when
present, maps to an integer.  There is also a wild card for any future
additions.</t>

<t>Unfortunately, the data item</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
{ "optional-key": "nonsense" }
]]></artwork></figure>

<t>does match this specification:  While the first entry of the group
does not match, the second one (the wildcard) does.  This may be very
well desirable (e.g., if a future extension is to be allowed to extend
the type of “optional-key”), but in many cases isn’t.</t>

<t>In anticipation of a more general potential feature called “cuts”,
CDDL allows inserting a cut “^” into the definition of the map entry:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
extensible-map-example = {
  ? "optional-key" ^ => int,
  * tstr => any
}
]]></artwork></figure>

<t>A cut in this position means that once the member key matches the name
part of an entry that carries a cut,
other potential matches for the key of the member that occur in
later entries in the group of the map are no longer allowed.
In other words, when a group entry would pick a key/value pair based
on just a matching key, it “locks in” the pick — this rule applies
independent of whether the value matches as well, so when it does not,
the entire map fails to match.
In summary, the
example above no longer matches the specification as modified with the cut.</t>

<t>Since the desire for this kind of exclusive matching is so frequent,
the “:” shortcut is actually defined to include the cut semantics.  So
the preceding example (including the cut) can be written more simply
as:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
extensible-map-example = {
  ? "optional-key": int,
  * tstr => any
}
]]></artwork></figure>

<t>or even shorter, using a bareword for the key:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
extensible-map-example = {
  ? optional-key: int,
  * tstr => any
}
]]></artwork></figure>

</section>
</section>
<section anchor="tagsec" title="Tags">

<t>A type can make use of a CBOR tag (major type 6) by using the
representation type notation, giving #6.nnn(type) where nnn is an
unsigned integer giving the tag number and <spanx style="verb">type</spanx> is the type of the
data item being tagged.</t>

<t>For example, the following line from the CDDL prelude (<xref target="prelude"/>) defines <spanx style="verb">biguint</spanx> as
a type name for a positive bignum N:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
biguint = #6.2(bstr)
]]></artwork></figure>

<t>The tags defined by <xref target="RFC7049"/> are included in the prelude.
Additional tags since registered need to be added to a CDDL
specification as needed; e.g., a binary UUID tag could be referenced
as <spanx style="verb">buuid</spanx> in a specification after defining</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
buuid = #6.37(bstr)
]]></artwork></figure>

<t>In the following example, usage of the tag 32 for URIs is optional:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
my_uri = #6.32(tstr) / tstr
]]></artwork></figure>

</section>
<section anchor="unwrapping" title="Unwrapping">

<t>The group that is used to define a map or an array can often be reused
in the definition of another map or array.  Similarly, a type defined
as a tag carries an internal data item that one would like to refer
to.
In these cases, it is expedient to simply use the name of the map,
array, or tag type as a handle for the group or type defined inside it.</t>

<t>The “unwrap” operator (written by preceding a name by a tilde
character “~”) can be used to strip the type defined for a name by one
layer, exposing the underlying group (for maps and arrays) or type
(for tags).</t>

<t>For example, an application might want to define a basic and an
advanced header.  Without unwrapping, this might be done as follows:</t>

<figure><artwork type="CDDL"><![CDATA[
basic-header-group = (
  field1: int,
  field2: text,
)

basic-header = [ basic-header-group ]

advanced-header = [
  basic-header-group,
  field3: bytes,
  field4: number, ; as in the tagged type "time"
]
]]></artwork></figure>

<t>Unwrapping simplifies this to:</t>

<figure><artwork type="CDDL"><![CDATA[
basic-header = [
  field1: int,
  field2: text,
]

advanced-header = [
  ~basic-header,
  field3: bytes,
  field4: ~time,
]
]]></artwork></figure>

<t>(Note that leaving out the first unwrap operator in the latter example
would lead to nesting the basic-header in its own array inside the
advanced-header, while, with the unwrapped basic-header, the
definition of the group inside basic-header is essentially repeated
inside advanced-header, leading to a single array.  This can be used for
various applications often solved by inheritance in programming
languages.  The effect of unwrapping can also be described as
“threading in” the group or type inside the referenced type, which
suggested the thread-like “~” character.)</t>

</section>
<section anchor="controls" title="Controls">

<t>A <spanx style="emph">control</spanx> allows to relate a <spanx style="emph">target</spanx> type with a <spanx style="emph">controller</spanx> type
via a <spanx style="emph">control operator</spanx>.</t>

<t>The syntax for a control type is <spanx style="verb">target .control-operator controller</spanx>,
where control operators are special identifiers prefixed by a dot.
(Note that <spanx style="emph">target</spanx> or <spanx style="emph">controller</spanx> might need to be parenthesized.)</t>

<t>A number of control operators are defined at this point.
Further control operators may be defined by new
versions of this specification or by registering them according to the
procedures in <xref target="sec-controlreg"/>.</t>

<section anchor="control-operator-size" title="Control operator .size">

<t>A <spanx style="verb">.size</spanx> control controls the size of the target in bytes by the
control type.  The control is defined for text and byte strings, where
it directly controls the number of bytes in the string.  It is also
defined for unsigned integers (see below).
<xref target="control-size"/> shows example usage for byte strings.</t>

<figure title="Control for size in bytes" anchor="control-size"><artwork type="CDDL" align="center"><![CDATA[
full-address = [[+ label], ip4, ip6]
ip4 = bstr .size 4
ip6 = bstr .size 16
label = bstr .size (1..63)
]]></artwork></figure>

<t>When applied to an unsigned integer, the <spanx style="verb">.size</spanx> control restricts
the range of that integer by giving a maximum number of bytes that
should be needed in a computer representation of that unsigned integer.
In other words, <spanx style="verb">uint .size N</spanx> is equivalent to <spanx style="verb">0...BYTES_N</spanx>, where
BYTES_N == 256**N.</t>

<figure title="Control for integer size in bytes" anchor="control-int-size"><artwork type="CDDL" align="center"><![CDATA[
audio_sample = uint .size 3 ; 24-bit, equivalent to 0...16777216
]]></artwork></figure>

<t>Note that, as with value restrictions in CDDL, this control is not
a representation constraint; a number that fits into fewer bytes can
still be represented in that form, and an inefficient implementation
could use a longer form (unless that is restricted by some format
constraints outside of CDDL, such as the rules in Section 3.9 of
<xref target="RFC7049"/>).</t>

</section>
<section anchor="control-operator-bits" title="Control operator .bits">

<t>A <spanx style="verb">.bits</spanx> control on a byte string indicates that, in the
target, only the bits numbered by a number in the control type are
allowed to be set.  (Bits are counted the usual way, bit number <spanx style="verb">n</spanx>
being set in <spanx style="verb">str</spanx> meaning that <spanx style="verb">(str[n &gt;&gt; 3] &amp; (1 &lt;&lt; (n &amp; 7))) != 0</spanx>.)
Similarly, a <spanx style="verb">.bits</spanx> control on an unsigned integer <spanx style="verb">i</spanx> indicates
that for all unsigned integers <spanx style="verb">n</spanx> where <spanx style="verb">(i &amp; (1 &lt;&lt; n)) != 0</spanx>, <spanx style="verb">n</spanx>
must be in the control type.</t>

<figure title="Control for what bits can be set" anchor="control-bits"><artwork type="CDDL" align="center"><![CDATA[
tcpflagbytes = bstr .bits flags
flags = &(
  fin: 8,
  syn: 9,
  rst: 10,
  psh: 11,
  ack: 12,
  urg: 13,
  ece: 14,
  cwr: 15,
  ns: 0,
) / (4..7) ; data offset bits

rwxbits = uint .bits rwx
rwx = &(r: 2, w: 1, x: 0)
]]></artwork></figure>

<t>The CDDL tool reported on in <xref target="tool"/> generates the following ten example instances for <spanx style="verb">tcpflagbytes</spanx>:</t>

<figure><artwork type="CBORdiags" align="center"><![CDATA[
h'906d' h'01fc' h'8145' h'01b7' h'013d' h'409f' h'018e' h'c05f'
h'01fa' h'01fe'
]]></artwork></figure>

<t>These examples do not illustrate that the above CDDL specification
does not explicitly specify a size of two bytes: A valid all clear
instance of flag bytes could be <spanx style="verb">h''</spanx> or <spanx style="verb">h'00'</spanx> or even <spanx style="verb">h'000000'</spanx>
as well.</t>

</section>
<section anchor="regexp" title="Control operator .regexp">

<t>A <spanx style="verb">.regexp</spanx> control indicates that the text string given as a target
needs to match the XSD regular expression given as a value in the
control type.
XSD regular expressions are defined in Appendix F of <xref target="W3C.REC-xmlschema-2-20041028"/>.</t>

<figure title="Control with an XSD regexp" anchor="control-regexp"><artwork type="CDDL" align="center"><![CDATA[
nai = tstr .regexp "[A-Za-z0-9]+@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)+"
]]></artwork></figure>

<t>An example matching this regular expression:</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
"N1@CH57HF.4Znqe0.dYJRN.igjf"
]]></artwork></figure>

<section anchor="usage-considerations" title="Usage considerations">

<t>Note that XSD regular expressions do not support the usual \x or \u
escapes for hexadecimal expression of bytes or unicode code points.
However, in CDDL the XSD regular expressions are contained in text
strings, the literal notation for which provides \u escapes; this should
suffice for most applications that use regular expressions for text
strings.
(Note that this also means that there is one level of string escaping
before the XSD escaping rules are applied.)</t>

<t>XSD regular expressions support character class subtraction, a feature
often not found in regular expression libraries; specification writers
may want to use this feature sparingly.
Similar considerations apply to Unicode character classes; where these
are used, the specification that employs CDDL SHOULD identify which
Unicode versions are addressed.</t>

<t>Other surprises for infrequent users of XSD regular expressions may
include:</t>

<t><list style="symbols">
  <t>No direct support for case insensitivity.  While case insensitivity
has gone mostly out of fashion in protocol design, it is sometimes
needed and then needs to be expressed manually as in
<spanx style="verb">[Cc][Aa][Ss][Ee]</spanx>.</t>
  <t>The support for popular character classes such as \w and \d is based
on Unicode character properties, which is often not what is desired
in an ASCII-based protocol and thus might lead to surprises.  (\s
and \S do have their more conventional meanings, and <spanx style="verb">.</spanx> matches any
character but the line ending characters \r or \n.)</t>
</list></t>

</section>
<section anchor="discussion" title="Discussion">

<t>There are many flavors of regular expression in use in the programming
community.
For instance, perl-compatible regular expressions (PCRE) are widely
used and probably are more useful than XSD regular expressions.
However, there is no normative reference for PCRE that could be used
in the present document.
Instead, we opt for XSD regular expressions for now.
There is precedent for that choice in the IETF, e.g., in YANG <xref target="RFC7950"/>.</t>

<t>Note that CDDL uses controls as its main extension point.
This creates the opportunity to add further regular expression formats
in addition to the one referenced here if desired.
As an example, a control “.pcre” is defined in <xref target="I-D.bormann-cbor-cddl-freezer"/>.</t>

<!-- The character escape sequences \d, \D, \h, \H, \p, \P, \s, \S, \v, \V, -->
<!-- \w, and \W may appear in a character class, and add the characters -->
<!-- that they match to the class. -->

</section>
</section>
<section anchor="control-operators-cbor-and-cborseq" title="Control operators .cbor and .cborseq">

<t>A <spanx style="verb">.cbor</spanx> control on a byte string indicates that
the byte string carries a CBOR encoded data item.  Decoded, the
data item matches the type given as the right-hand side argument
(type1 in the following example).</t>

<t><list style='empty'>
  <t><spanx style="verb">bytes .cbor type1</spanx></t>
</list></t>

<t>Similarly, a <spanx style="verb">.cborseq</spanx> control on a byte string indicates that
the byte string carries a sequence of CBOR encoded data items.
When the data items are taken as an array, the array matches the type
given as the right-hand side argument (type2 in the following example).</t>

<t><list style='empty'>
  <t><spanx style="verb">bytes .cborseq type2</spanx></t>
</list></t>

<t>(The conversion of the encoded sequence to an array can be effected
for instance by wrapping the byte string between the two bytes 0x9f
and 0xff and decoding the wrapped byte string as a CBOR encoded data
item.)</t>

</section>
<section anchor="control-operators-within-and-and" title="Control operators .within and .and">

<t>A <spanx style="verb">.and</spanx> control on a type indicates that the data item matches
both that left hand side type and the type given as the right hand side.
(Formally, the resulting type is the intersection of the two types
given.)</t>

<t><list style='empty'>
  <t><spanx style="verb">type1 .and type2</spanx></t>
</list></t>

<t>A variant of the <spanx style="verb">.and</spanx> control is the <spanx style="verb">.within</spanx> control, which
expresses an additional intent: the left hand side type is meant to be
a subset of the right-hand-side type.</t>

<t><list style='empty'>
  <t><spanx style="verb">type1 .within type2</spanx></t>
</list></t>

<t>While both forms have the identical formal semantics (intersection),
the intention of the <spanx style="verb">.within</spanx> form is that the right hand side gives
guidance to the types allowed on the left hand side, which typically
is a socket (<xref target="socketplug"/>):</t>

<figure><artwork type="CDDL"><![CDATA[
message = $message .within message-structure
message-structure = [message_type, *message_option]
message_type = 0..255
message_option = any

$message /= [3, dough: text, topping: [* text]]
$message /= [4, noodles: text, sauce: text, parmesan: bool]
]]></artwork></figure>

<t>For <spanx style="verb">.within</spanx>, a tool might flag an error if type1 allows data items
that are not allowed by type2.  In contrast, for <spanx style="verb">.and</spanx>, there is no
expectation that type1 already is a subset of type2.</t>

</section>
<section anchor="fortran" title="Control operators .lt, .le, .gt, .ge, .eq, .ne, and .default">

<t>The controls .lt, .le, .gt, .ge, .eq, .ne specify a constraint on
the left hand side type to be a value less than, less than or equal,
greater than, greater than or equal, equal, or not equal, to a
value given as a right hand side type (containing just that single value).
In the present specification, the first four controls (.lt, .le,
.gt, .ge) are defined only for numeric types, as these have a natural
ordering relationship.</t>

<figure><artwork type="CDDL"><![CDATA[
speed = number .ge 0  ; unit: m/s
]]></artwork></figure>

<t>.ne and .eq are defined both for numeric values and values of other types.
If one of the values is not of a numeric type, equality is determined as follows:
Text strings are equal (satisfy .eq/do not satisfy .ne) if
they are byte-wise identical; the same applies for byte strings.
Arrays are equal if they have the same number
of elements, all of which are equal pairwise in order between the arrays.
Maps are equal if they have the same number of key/value pairs, and there
is pairwise equality between the key/value pairs between the two maps.
Tagged values are equal if they both have the same tag and the values
are equal.
Values of simple types match if they are the same values.
Numeric types that occur within arrays, maps, or tagged values are
equal if their numeric value is equal and they are both integers or
both floating point values.
All other cases are not equal (e.g., comparing a text string with a
byte string).</t>

<t>A variant of the <spanx style="verb">.ne</spanx> control is the <spanx style="verb">.default</spanx> control, which
expresses an additional intent: the value specified by the
right-hand-side type is intended as a default value for the left hand
side type given, and the implied .ne control is there to prevent
this value from being sent over the wire.
This control is only meaningful when the control type is used in
an optional context; otherwise there would be no way to express the
default value.</t>

<figure><artwork type="CDDL"><![CDATA[
timer = {
  time: uint,
  ? displayed-step: (number .gt 0) .default 1
}
]]></artwork></figure>

</section>
</section>
<section anchor="socketplug" title="Socket/Plug">

<t>Both for type choices and group choices, a mechanism is defined that
facilitates starting out with empty choices and assembling them later,
potentially in separate files that are concatenated to build the full
specification.</t>

<t>Per convention, CDDL extension points are marked with a leading dollar
sign (types) or two leading dollar signs (groups).  Tools honor that
convention by not raising an error if such a type or group is not
defined at all; the symbol is then taken to be an empty type choice
(group choice), i.e., no choice is available.</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
tcp-header = {seq: uint, ack: uint, * $$tcp-option}

; later, in a different file

$$tcp-option //= (
sack: [+(left: uint, right: uint)]
)

; and, maybe in another file

$$tcp-option //= (
sack-permitted: true
)
]]></artwork></figure>

<t>Names that start with a single “$” are “type sockets”, starting out as
an empty type, and intended to be extended via “/=”.
Names that start with a double “$$” are “group sockets”, starting out
as an empty group choice, and intended to be extended via “//=”.
In either case, it is not an error if there is no
definition for a socket at all; this then means there is no way to
satisfy the rule (i.e., the choice is empty).</t>

<t>As a convention, all definitions (plugs) for socket names must be augmentations, i.e., they
must be using “/=” and “//=”, respectively.</t>

<t>To pick up the example illustrated in <xref target="xmp-personaldata"/>, the
socket/plug mechanism could be used as shown in
<xref target="xmp-personaldata-sp"/>:</t>

<figure title="Personal Data example: Using socket/plug extensibility" anchor="xmp-personaldata-sp"><artwork type="CDDL" align="center"><![CDATA[
PersonalData = {
  ? displayName: tstr,
  NameComponents,
  ? age: uint,
  * $$personaldata-extensions
}

NameComponents = (
  ? firstName: tstr,
  ? familyName: tstr,
)

; The above already works as is.
; But then, we can add later:

$$personaldata-extensions //= (
  favorite-salsa: tstr,
)

; and again, somewhere else:

$$personaldata-extensions //= (
  shoesize: uint,
)
]]></artwork></figure>

</section>
<section anchor="generics" title="Generics">

<t>Using angle brackets, the left hand side of a rule can add formal
parameters after the name being defined, as in:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
messages = message<"reboot", "now"> / message<"sleep", 1..100>
message<t, v> = {type: t, value: v}
]]></artwork></figure>

<t>When using a generic rule, the formal parameters are bound to the
actual arguments supplied (also using angle brackets), within the
scope of the generic rule (as if there were a rule of the form
parameter = argument).</t>

<t>Generic rules can be used for establishing names for both types and
groups.</t>

<t>(There are some limitations to nesting of generics in the tool
described in <xref target="tool"/> at this time.)</t>

</section>
<section anchor="operator-precedence" title="Operator Precedence">

<t>As with any language that has multiple syntactic features such as
prefix and infix operators, CDDL has operators that bind more tightly
than others.  This is becoming more complicated than, say, in ABNF, as
CDDL has both types and groups, with operators that are specific to
these concepts.  Type operators (such as “/” for type choice) operate on
types, while group operators (such as “//” for group choice) operate
on groups.  Types can simply be used in groups, but groups need to be
bracketed (as arrays or maps) to become types.  So, type operators
naturally bind closer than group operators.</t>

<t>For instance, in</t>

<figure><artwork><![CDATA[
t = [group1]
group1 = (a / b // c / d)
a = 1 b = 2 c = 3 d = 4
]]></artwork></figure>

<t>group1 is a group choice between the type choice of a and b and the
type choice of c and d.  This becomes more relevant once member keys
and/or occurrences are added in:</t>

<figure><artwork><![CDATA[
t = {group2}
group2 = (? ab: a / b // cd: c / d)
a = 1 b = 2 c = 3 d = 4
]]></artwork></figure>

<t>is a group choice between the optional member “ab” of type a or b and
the member “cd” of type c or d.  Note that the optionality is attached
to the first choice (“ab”), not to the second choice.</t>

<t>Similarly, in</t>

<figure><artwork><![CDATA[
t = [group3]
group3 = (+ a / b / c)
a = 1 b = 2 c = 3
]]></artwork></figure>

<t>group3 is a repetition of a type choice between a, b, and c;  if just
a is to be repeatable, a group choice is needed to focus the occurrence:</t>

<t>(A comment has been that this could be counter-intuitive.  The
specification writer is encouraged to use parentheses liberally to
guide readers that are not familiar with CDDL precedence rules.)</t>

<figure><artwork><![CDATA[
t = [group4]
group4 = (+ a // b / c)
a = 1 b = 2 c = 3
]]></artwork></figure>

<t>group4 is a group choice between a repeatable a and a single b or c.</t>

<t>In general, as with many other languages with operator precedence
rules, it is best not to rely on them, but to insert parentheses for
readability:</t>

<figure><artwork><![CDATA[
t = [group4a]
group4a = ((+ a) // (b / c))
a = 1 b = 2 c = 3
]]></artwork></figure>

<t>The operator precedences, in sequence of loose to tight binding, are
defined in <xref target="abnf"/> and summarized in <xref target="prec"/>.  (Arities given are 1
for unary prefix operators and 2 for binary infix operators.)</t>

<texttable title="Summary of operator precedences" anchor="prec">
      <ttcol align='center'>Operator</ttcol>
      <ttcol align='right'>Ar</ttcol>
      <ttcol align='left'>Operates on</ttcol>
      <ttcol align='right'>Prec</ttcol>
      <c>=</c>
      <c>2</c>
      <c>name = type, name = group</c>
      <c>1</c>
      <c>/=</c>
      <c>2</c>
      <c>name /= type</c>
      <c>1</c>
      <c>//=</c>
      <c>2</c>
      <c>name //= group</c>
      <c>1</c>
      <c>//</c>
      <c>2</c>
      <c>group // group</c>
      <c>2</c>
      <c>,</c>
      <c>2</c>
      <c>group, group</c>
      <c>3</c>
      <c>*</c>
      <c>1</c>
      <c>* group</c>
      <c>4</c>
      <c>N*M</c>
      <c>1</c>
      <c>N*M group</c>
      <c>4</c>
      <c>+</c>
      <c>1</c>
      <c>+ group</c>
      <c>4</c>
      <c>?</c>
      <c>1</c>
      <c>? group</c>
      <c>4</c>
      <c>=&gt;</c>
      <c>2</c>
      <c>type =&gt; type</c>
      <c>5</c>
      <c>:</c>
      <c>2</c>
      <c>name: type</c>
      <c>5</c>
      <c>/</c>
      <c>2</c>
      <c>type / type</c>
      <c>6</c>
      <c>..</c>
      <c>2</c>
      <c>type..type</c>
      <c>7</c>
      <c>…</c>
      <c>2</c>
      <c>type…type</c>
      <c>7</c>
      <c>.ctrl</c>
      <c>2</c>
      <c>type .ctrl type</c>
      <c>7</c>
      <c>&amp;</c>
      <c>1</c>
      <c>&amp;group</c>
      <c>8</c>
      <c>~</c>
      <c>1</c>
      <c>~type</c>
      <c>8</c>
</texttable>

</section>
</section>
<section anchor="usage" title="Making Use of CDDL">

<t>In this section, we discuss several potential ways to employ CDDL.</t>

<section anchor="as-a-guide-to-a-human-user" title="As a guide to a human user">

<t>CDDL can be used to efficiently define the layout of CBOR data,
such that a human implementer can easily see how data is supposed to be encoded.</t>

<t>Since CDDL maps parts of the CBOR data to human readable names,
tools could be built that use CDDL to provide a human friendly representation
of the CBOR data,
and allow them to edit such data while remaining compliant to its CDDL definition.</t>

</section>
<section anchor="for-automated-checking-of-cbor-data-structure" title="For automated checking of CBOR data structure">

<t>CDDL has been specified such that a machine can handle the CDDL definition
and related CBOR data (and, thus, also JSON data).
For example,
a machine could use CDDL to check whether or not CBOR data is compliant
to its definition.</t>

<t>The need for thoroughness of such compliance checking depends on the application.
For example,
an application may decide not to check the data structure at all,
and use the CDDL definition solely as a means to indicate the structure of
the data to the programmer.</t>

<t>On the other end,
the application may also implement a checking mechanism that goes as
far as checking that all mandatory map members are available.</t>

<t>The matter in how far the data description must be enforced by an application
is left to the designers and implementers of that application,
keeping in mind related security considerations.</t>

<t>In no case the intention is that a CDDL tool would be “writing code” for
an implementation.</t>

</section>
<section anchor="for-data-analysis-tools" title="For data analysis tools">

<t>In the long run,
it can be expected that more and more data will be stored using the CBOR
data format.</t>

<t>Where there is data, there is data analysis and the need to process such
data automatically.
CDDL can be used for such automated data processing,
allowing tools to verify data, clean it,
and extract particular parts of interest from it.</t>

<t>Since CBOR is designed with constrained devices in mind,
a likely use of it would be small sensors.
An interesting use would thus be automated analysis of sensor data.</t>

</section>
</section>
<section anchor="security-considerations" title="Security considerations">

<t>This document presents a content rules language for expressing CBOR data
structures.
As such,
it does not bring any security issues on itself,
although specifications of protocols that use CBOR naturally need security
analyses when defined.
General guidelines for writing security considerations are defined in</t>

<t>Security Considerations Guidelines <xref target="RFC3552"/> (BCP 72).
Specifications using CDDL to define CBOR structures in protocols need to
follow those guidelines.
Additional topics that could be considered in a security
considerations section for a specification that uses CDDL to define
CBOR structures include the following:</t>

<t><list style="symbols">
  <t>Where could the language maybe cause confusion in a way that will
enable security issues?</t>
  <t>Where a CDDL matcher is part of the implementation of a system, the
security of the system ought not depend on the correctness of the
CDDL specification or CDDL implementation without any further
defenses in place.</t>
  <t>Where the CDDL includes extension points, the impact of extensions
on the security of the system needs to be carefully considered.</t>
</list></t>

<t>Writers of CDDL specifications are strongly encouraged to value
simplicity and transparency of the specification over its elegance.
Keep it as simple as possible while still expressing the needed
data model.</t>

<t>A related observation about formal description techniques in general
that is strongly recommended to be kept in mind by writers of CDDL
specifications: Just because CDDL makes it easier to handle complexity
in a specification, that does not make that complexity somehow less
bad (except maybe on the level of the humans having to grasp the
complex structure while reading the spec).</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<section anchor="sec-controlreg" title="CDDL control operator registry">

<t>IANA is requested to create a registry for control operators
<xref target="controls"/>.  The name of this registry is “CDDL Control Operators”.</t>

<t>Each entry in the subregistry must include the name of the control
operator (by convention given with the leading dot) and a reference to
its documentation.  Names must be composed of the leading dot followed
by a text string conforming to the production “id” in <xref target="abnf"/>.</t>

<t>Initial entries in this registry are as follows:</t>

<texttable>
      <ttcol align='left'>name</ttcol>
      <ttcol align='left'>documentation</ttcol>
      <c>.size</c>
      <c>[RFCthis]</c>
      <c>.bits</c>
      <c>[RFCthis]</c>
      <c>.regexp</c>
      <c>[RFCthis]</c>
      <c>.cbor</c>
      <c>[RFCthis]</c>
      <c>.cborseq</c>
      <c>[RFCthis]</c>
      <c>.within</c>
      <c>[RFCthis]</c>
      <c>.and</c>
      <c>[RFCthis]</c>
      <c>.lt</c>
      <c>[RFCthis]</c>
      <c>.le</c>
      <c>[RFCthis]</c>
      <c>.gt</c>
      <c>[RFCthis]</c>
      <c>.ge</c>
      <c>[RFCthis]</c>
      <c>.eq</c>
      <c>[RFCthis]</c>
      <c>.ne</c>
      <c>[RFCthis]</c>
      <c>.default</c>
      <c>[RFCthis]</c>
</texttable>

<t>All other control operator names are Unassigned.</t>

<t>The IANA policy for additions to this registry is “Specification
Required” as defined in <xref target="RFC8126"/> (which involves an Expert
Review) for names that do not include an internal dot, and “IETF
Review” for names that do include an internal dot.
The Expert is specifically instructed that other Standards Development
Organizations (SDOs) may want to define control operators that are
specific to their fields (e.g., based on a binary syntax already in
use at the SDO); the review process should strive to facilitate such
an undertaking.</t>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC3552" target='https://www.rfc-editor.org/info/rfc3552'>
<front>
<title>Guidelines for Writing RFC Text on Security Considerations</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<author initials='B.' surname='Korver' fullname='B. Korver'><organization /></author>
<date year='2003' month='July' />
<abstract><t>All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.   This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='72'/>
<seriesInfo name='RFC' value='3552'/>
<seriesInfo name='DOI' value='10.17487/RFC3552'/>
</reference>



<reference  anchor="RFC3629" target='https://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC4648" target='https://www.rfc-editor.org/info/rfc4648'>
<front>
<title>The Base16, Base32, and Base64 Data Encodings</title>
<author initials='S.' surname='Josefsson' fullname='S. Josefsson'><organization /></author>
<date year='2006' month='October' />
<abstract><t>This document describes the commonly used base 64, base 32, and base 16 encoding schemes.  It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4648'/>
<seriesInfo name='DOI' value='10.17487/RFC4648'/>
</reference>



<reference  anchor="RFC5234" target='https://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor="RFC7049" target='https://www.rfc-editor.org/info/rfc7049'>
<front>
<title>Concise Binary Object Representation (CBOR)</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2013' month='October' />
<abstract><t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t></abstract>
</front>
<seriesInfo name='RFC' value='7049'/>
<seriesInfo name='DOI' value='10.17487/RFC7049'/>
</reference>



<reference  anchor="RFC8126" target='https://www.rfc-editor.org/info/rfc8126'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='M.' surname='Cotton' fullname='M. Cotton'><organization /></author>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<date year='2017' month='June' />
<abstract><t>Many protocols make use of points of extensibility that use constants to identify various protocol parameters.  To ensure that the values in these fields do not have conflicting uses and to promote interoperability, their allocations are often coordinated by a central record keeper.  For IETF protocols, that role is filled by the Internet Assigned Numbers Authority (IANA).</t><t>To make assignments in a given registry prudently, guidance describing the conditions under which new values should be assigned, as well as when and how modifications to existing values can be made, is needed.  This document defines a framework for the documentation of these guidelines by specification authors, in order to assure that the provided guidance for the IANA Considerations is clear and addresses the various issues that are likely in the operation of a registry.</t><t>This is the third edition of this document; it obsoletes RFC 5226.</t></abstract>
</front>
<seriesInfo name='BCP' value='26'/>
<seriesInfo name='RFC' value='8126'/>
<seriesInfo name='DOI' value='10.17487/RFC8126'/>
</reference>



<reference  anchor="RFC8259" target='https://www.rfc-editor.org/info/rfc8259'>
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2017' month='December' />
<abstract><t>JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format.  It was derived from the ECMAScript Programming Language Standard.  JSON defines a small set of formatting rules for the portable representation of structured data.</t><t>This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.</t></abstract>
</front>
<seriesInfo name='STD' value='90'/>
<seriesInfo name='RFC' value='8259'/>
<seriesInfo name='DOI' value='10.17487/RFC8259'/>
</reference>



<reference  anchor="RFC7493" target='https://www.rfc-editor.org/info/rfc7493'>
<front>
<title>The I-JSON Message Format</title>
<author initials='T.' surname='Bray' fullname='T. Bray' role='editor'><organization /></author>
<date year='2015' month='March' />
<abstract><t>I-JSON (short for &quot;Internet JSON&quot;) is a restricted profile of JSON designed to maximize interoperability and increase confidence that software can process it successfully with predictable results.</t></abstract>
</front>
<seriesInfo name='RFC' value='7493'/>
<seriesInfo name='DOI' value='10.17487/RFC7493'/>
</reference>



<reference anchor="W3C.REC-xmlschema-2-20041028"
           target='http://www.w3.org/TR/2004/REC-xmlschema-2-20041028'>
<front>
<title>XML Schema Part 2: Datatypes Second Edition</title>

<author initials='P.' surname='Biron' fullname='Paul V. Biron'>
    <organization />
</author>

<author initials='A.' surname='Malhotra' fullname='Ashok Malhotra'>
    <organization />
</author>

<date month='October' day='28' year='2004' />
</front>

<seriesInfo name='World Wide Web Consortium Recommendation' value='REC-xmlschema-2-20041028' />
<format type='HTML' target='http://www.w3.org/TR/2004/REC-xmlschema-2-20041028' />
</reference>


<reference anchor="ISO6093" >
  <front>
    <title>Information processing -- Representation of numerical values in character strings for information interchange</title>
    <author >
      <organization>ISO</organization>
    </author>
    <date year="1985"/>
  </front>
  <seriesInfo name="ISO" value="6093"/>
</reference>




<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="RELAXNG" >
  <front>
    <title>Information technology — Document Schema Definition Language (DSDL) — Part 2: Regular-grammar-based validation — RELAX NG</title>
    <author >
      <organization>ISO/IEC</organization>
    </author>
    <date year="2008" month="December" day="15"/>
  </front>
  <seriesInfo name="ISO/IEC" value="19757-2"/>
</reference>




<reference  anchor="RFC7071" target='https://www.rfc-editor.org/info/rfc7071'>
<front>
<title>A Media Type for Reputation Interchange</title>
<author initials='N.' surname='Borenstein' fullname='N. Borenstein'><organization /></author>
<author initials='M.' surname='Kucherawy' fullname='M. Kucherawy'><organization /></author>
<date year='2013' month='November' />
<abstract><t>This document defines the format of reputation response data (&quot;reputons&quot;), the media type for packaging it, and definition of a registry for the names of reputation applications and response sets.</t></abstract>
</front>
<seriesInfo name='RFC' value='7071'/>
<seriesInfo name='DOI' value='10.17487/RFC7071'/>
</reference>



<reference  anchor="RFC8007" target='https://www.rfc-editor.org/info/rfc8007'>
<front>
<title>Content Delivery Network Interconnection (CDNI) Control Interface / Triggers</title>
<author initials='R.' surname='Murray' fullname='R. Murray'><organization /></author>
<author initials='B.' surname='Niven-Jenkins' fullname='B. Niven-Jenkins'><organization /></author>
<date year='2016' month='December' />
<abstract><t>This document describes the part of the Content Delivery Network Interconnection (CDNI) Control interface that allows a CDN to trigger activity in an interconnected CDN that is configured to deliver content on its behalf.  The upstream CDN can use this mechanism to request that the downstream CDN pre-position metadata or content or to request that it invalidate or purge metadata or content.  The upstream CDN can monitor the status of activity that it has triggered in the downstream CDN.</t></abstract>
</front>
<seriesInfo name='RFC' value='8007'/>
<seriesInfo name='DOI' value='10.17487/RFC8007'/>
</reference>



<reference anchor="I-D.newton-json-content-rules">
<front>
<title>A Language for Rules Describing JSON Content</title>

<author initials='A' surname='Newton' fullname='Andrew Newton'>
    <organization />
</author>

<author initials='P' surname='Cordell' fullname='Pete Cordell'>
    <organization />
</author>

<date month='September' day='28' year='2017' />

<abstract><t>This document describes a language for specifying and testing the expected content of JSON structures found in JSON-using protocols, software, and processes.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-newton-json-content-rules-09' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-newton-json-content-rules-09.txt' />
</reference>



<reference  anchor="RFC8152" target='https://www.rfc-editor.org/info/rfc8152'>
<front>
<title>CBOR Object Signing and Encryption (COSE)</title>
<author initials='J.' surname='Schaad' fullname='J. Schaad'><organization /></author>
<date year='2017' month='July' />
<abstract><t>Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size.  There is a need for the ability to have basic security services defined for this data format. This document defines the CBOR Object Signing and Encryption (COSE) protocol.  This specification describes how to create and process signatures, message authentication codes, and encryption using CBOR for serialization.  This specification additionally describes how to represent cryptographic keys using CBOR.</t></abstract>
</front>
<seriesInfo name='RFC' value='8152'/>
<seriesInfo name='DOI' value='10.17487/RFC8152'/>
</reference>



<reference anchor="I-D.ietf-anima-grasp">
<front>
<title>A Generic Autonomic Signaling Protocol (GRASP)</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='B' surname='Carpenter' fullname='Brian Carpenter'>
    <organization />
</author>

<author initials='B' surname='Liu' fullname='Bing Liu'>
    <organization />
</author>

<date month='July' day='13' year='2017' />

<abstract><t>This document specifies the GeneRic Autonomic Signaling Protocol (GRASP), which enables autonomic nodes and autonomic service agents to dynamically discover peers, to synchronize state with each other, and to negotiate parameter settings with each other.  GRASP depends on an external security environment that is described elsewhere.  The technical objectives and parameters for specific application scenarios are to be described in separate documents.  Appendices briefly discuss requirements for the protocol and existing protocols with comparable features.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-anima-grasp-15' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-anima-grasp-15.txt' />
</reference>



<reference  anchor="RFC8428" target='https://www.rfc-editor.org/info/rfc8428'>
<front>
<title>Sensor Measurement Lists (SenML)</title>
<author initials='C.' surname='Jennings' fullname='C. Jennings'><organization /></author>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'><organization /></author>
<author initials='J.' surname='Arkko' fullname='J. Arkko'><organization /></author>
<author initials='A.' surname='Keranen' fullname='A. Keranen'><organization /></author>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<date year='2018' month='August' />
<abstract><t>This specification defines a format for representing simple sensor measurements and device parameters in Sensor Measurement Lists (SenML).  Representations are defined in JavaScript Object Notation (JSON), Concise Binary Object Representation (CBOR), Extensible Markup Language (XML), and Efficient XML Interchange (EXI), which share the common SenML data model.  A simple sensor, such as a temperature sensor, could use one of these media types in protocols such as HTTP or the Constrained Application Protocol (CoAP) to transport the measurements of the sensor or to be configured.</t></abstract>
</front>
<seriesInfo name='RFC' value='8428'/>
<seriesInfo name='DOI' value='10.17487/RFC8428'/>
</reference>



<reference anchor="I-D.bormann-cbor-cddl-freezer">
<front>
<title>A feature freezer for the Concise Data Definition Language (CDDL)</title>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<date month='August' day='9' year='2018' />

<abstract><t>In defining the Concise Data Definition Language (CDDL), some features have turned up that would be nice to have.  In the interest of completing this specification in a timely manner, the present document collects nice-to-have features that did not make it into the first RFC for CDDL.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-bormann-cbor-cddl-freezer-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-bormann-cbor-cddl-freezer-01.txt' />
</reference>

<reference anchor="PEG" >
  <front>
    <title>Parsing expression grammars</title>
    <author initials="B." surname="Ford" fullname="Bryan Ford">
      <organization></organization>
    </author>
    <date year="2004"/>
  </front>
  <seriesInfo name="Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL" value="'04"/>
  <seriesInfo name="DOI" value="10.1145/964001.964011"/>
</reference>



<reference  anchor="RFC7950" target='https://www.rfc-editor.org/info/rfc7950'>
<front>
<title>The YANG 1.1 Data Modeling Language</title>
<author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role='editor'><organization /></author>
<date year='2016' month='August' />
<abstract><t>YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols.  This document describes the syntax and semantics of version 1.1 of the YANG language.  YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification.  There are a small number of backward incompatibilities from YANG version 1.  This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF).</t></abstract>
</front>
<seriesInfo name='RFC' value='7950'/>
<seriesInfo name='DOI' value='10.17487/RFC7950'/>
</reference>




    </references>


<section anchor="sec-peg" title="Parsing Expression Grammars (PEG)">

<t>This appendix is normative.</t>

<t>Since the 1950s, many grammar notations are based on Backus-Naur Form
(BNF), a notation for context-free grammars (CFGs) within Chomsky’s
generative system of grammars.  ABNF <xref target="RFC5234"/>, the Augmented Backus-Naur Form
widely used in IETF specifications and also inspiring the syntax of
CDDL, is an example of this.</t>

<t>Generative grammars can express ambiguity well, but this very property
may make them hard to use in recognition systems, spawning a number of
subdialects that pose constraints on generative grammars to be used
with parser generators, which may be hard to manage for the
specification writer.</t>

<t>Parsing Expression Grammars <xref target="PEG"/> provide an alternative formal
foundation for describing grammars that emphasizes recognition over
generation, and resolves what would have been ambiguity in generative
systems by introducing the concept of “prioritized choice”.</t>

<t>The notation for Parsing Expression Grammars is quite close to BNF,
with the usual “Extended BNF” features such as repetition added.
However, where BNF uses the unordered (symmetrical) choice operator
<spanx style="verb">|</spanx> (incidentally notated as <spanx style="verb">/</spanx> in ABNF), PEG provides a prioritized
choice operator <spanx style="verb">/</spanx>.  The two alternatives listed are to be tested in
left-to-right order, locking in the first successful match and
disregarding any further potential matches within the choice (but not
disabling alternatives in choices containing this choice, as a “cut”
would – <xref target="cuts-in-maps"/>}.</t>

<t>For example, the ABNF expressions</t>

<figure><artwork><![CDATA[
A = "a" "b" / "a"    (1)
]]></artwork></figure>

<t>and</t>

<figure><artwork><![CDATA[
A = "a" / "a" "b"    (2)
]]></artwork></figure>

<t>are equivalent in ABNF’s generative framework, but very different in
PEG: In (2), the second alternative will never match, as any input
string starting with an “a” will already succeed in the first
alternative, locking in the match.</t>

<t>Similarly, the occurrence indicators (<spanx style="verb">?</spanx>, <spanx style="verb">*</spanx>, <spanx style="verb">+</spanx>) are “greedy” in
PEG, i.e., they consume as much input as they match (and, as a
consequence, <spanx style="verb">a* a</spanx> in PEG notation or <spanx style="verb">*a a</spanx> in CDDL syntax
never can match anything as all input matching <spanx style="verb">a</spanx> is already consumed
by the initial <spanx style="verb">a*</spanx>, leaving nothing to match the second <spanx style="verb">a</spanx>).</t>

<t>Incidentally, the grammar of the CDDL language itself, as written in
ABNF in <xref target="abnf"/>, can be interpreted both in the generative framework
on which RFC 5234 is based, and as a PEG.  This was made possible by
ordering the choices in the grammar such that a successful match made
on the left hand side of a <spanx style="verb">/</spanx> operator is always the intended match,
instead of relying on the power of symmetrical choices (for example,
note the sequence of alternatives in the rule for <spanx style="verb">uint</spanx>, where the
lone zero is behind the longer match alternatives that start with a
zero).</t>

<t>The syntax used for expressing the PEG component of CDDL is based on
ABNF, interpreted in the obvious way with PEG semantics.  The ABNF
convention of notating occurrence indicators before the controlled
primary, and of allowing numeric values for minimum and maximum
occurrence around a <spanx style="verb">*</spanx> sign, is copied.  While PEG is only about
characters, CDDL has a richer set of elements, such as types and
groups.  Specifically, the following constructs map:</t>

<texttable>
      <ttcol align='left'>CDDL</ttcol>
      <ttcol align='left'>PEG</ttcol>
      <ttcol align='left'>Remark</ttcol>
      <c><spanx style="verb">=</spanx></c>
      <c><spanx style="verb">&lt;-</spanx></c>
      <c>/= and //= are abbreviations</c>
      <c><spanx style="verb">//</spanx></c>
      <c><spanx style="verb">/</spanx></c>
      <c>prioritized choice</c>
      <c><spanx style="verb">/</spanx></c>
      <c><spanx style="verb">/</spanx></c>
      <c>prioritized choice, limited to types only</c>
      <c><spanx style="verb">?</spanx> P</c>
      <c>P <spanx style="verb">?</spanx></c>
      <c>zero or one</c>
      <c><spanx style="verb">*</spanx> P</c>
      <c>P <spanx style="verb">*</spanx></c>
      <c>zero or more</c>
      <c><spanx style="verb">+</spanx> P</c>
      <c>P <spanx style="verb">+</spanx></c>
      <c>one or more</c>
      <c>A B</c>
      <c>A B</c>
      <c>sequence</c>
      <c>A, B</c>
      <c>A B</c>
      <c>sequence, comma is decoration only</c>
</texttable>

<t>The literal notation and the use of square brackets, curly braces,
tildes, ampersands, and hash marks is specific to CDDL and unrelated
to the conventional PEG notation.  The DOT (<spanx style="verb">.</spanx>) is replaced by the
unadorned <spanx style="verb">#</spanx> or its alias <spanx style="verb">any</spanx>.  Also, CDDL does not provide the
syntactic predicate operators NOT (<spanx style="verb">!</spanx>) or AND (<spanx style="verb">&amp;</spanx>) from PEG,
reducing expressiveness as well as complexity.</t>

<t>For more details about PEG’s theoretical foundation and interesting
properties of the operators such as associativity and distributivity,
the reader is referred to <xref target="PEG"/>.</t>

</section>
<section anchor="abnf" title="ABNF grammar">

<t>This appendix is normative.</t>

<t>The following is a formal definition of the CDDL syntax in Augmented
Backus-Naur Form (ABNF, <xref target="RFC5234"/>).  Note that, as is defined in
ABNF, the quote-delimited strings below are case-insensitive (while
string values and names are case-sensitive in CDDL).</t>

<figure title="CDDL ABNF" anchor="fig-abnf"><artwork type="ABNF" align="center"><![CDATA[
cddl = S 1*(rule S)
rule = typename [genericparm] S assignt S type
     / groupname [genericparm] S assigng S grpent

typename = id
groupname = id

assignt = "=" / "/="
assigng = "=" / "//="

genericparm = "<" S id S *("," S id S ) ">"
genericarg = "<" S type1 S *("," S type1 S ) ">"

type = type1 *(S "/" S type1)

type1 = type2 [S (rangeop / ctlop) S type2]
; space may be needed before the operator if type2 ends in a name

type2 = value
      / typename [genericarg]
      / "(" S type S ")"
      / "{" S group S "}"
      / "[" S group S "]"
      / "~" S typename [genericarg]
      / "&" S "(" S group S ")"
      / "&" S groupname [genericarg]
      / "#" "6" ["." uint] "(" S type S ")"
      / "#" DIGIT ["." uint]                ; major/ai
      / "#"                                 ; any

rangeop = "..." / ".."

ctlop = "." id

group = grpchoice *(S "//" S grpchoice)

grpchoice = *(grpent optcom)

grpent = [occur S] [memberkey S] type
       / [occur S] groupname [genericarg]  ; preempted by above
       / [occur S] "(" S group S ")"

memberkey = type1 S ["^" S] "=>"
          / bareword S ":"
          / value S ":"

bareword = id

optcom = S ["," S]

occur = [uint] "*" [uint]
      / "+"
      / "?"

uint = DIGIT1 *DIGIT
     / "0x" 1*HEXDIG
     / "0b" 1*BINDIG
     / "0"

value = number
      / text
      / bytes

int = ["-"] uint

; This is a float if it has fraction or exponent; int otherwise
number = hexfloat / (int ["." fraction] ["e" exponent ])
hexfloat = "0x" 1*HEXDIG ["." 1*HEXDIG] "p" exponent
fraction = 1*DIGIT
exponent = ["+"/"-"] 1*DIGIT

text = %x22 *SCHAR %x22
SCHAR = %x20-21 / %x23-5B / %x5D-7E / %x80-10FFFD / SESC
SESC = "\" (%x20-7E / %x80-10FFFD)

bytes = [bsqual] %x27 *BCHAR %x27
BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF
bsqual = "h" / "b64"

id = EALPHA *(*("-" / ".") (EALPHA / DIGIT))
ALPHA = %x41-5A / %x61-7A
EALPHA = ALPHA / "@" / "_" / "$"
DIGIT = %x30-39
DIGIT1 = %x31-39
HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
BINDIG = %x30-31

S = *WS
WS = SP / NL
SP = %x20
NL = COMMENT / CRLF
COMMENT = ";" *PCHAR CRLF
PCHAR = %x20-7E / %x80-10FFFD
CRLF = %x0A / %x0D.0A
]]></artwork></figure>

<t>Note that this ABNF does not attempt to reflect the detailed rules of
what can be in a prefixed byte string.</t>

</section>
<section anchor="matching" title="Matching rules">

<t>This appendix is normative.</t>

<t>In this appendix, we go through the ABNF syntax rules defined in
<xref target="abnf"/> and briefly describe the matching semantics of each syntactic
feature.  In this context, an instance (data item) “matches” a CDDL specification
if it is allowed by the CDDL specification; this is then broken down
to parts of specifications (type and group expressions) and parts of
instances (data items).</t>

<figure><artwork type="abnf"><![CDATA[
cddl = S 1*(rule S)
]]></artwork></figure>

<t>A CDDL specification is a sequence of one or more rules.  Each rule
gives a name to a right hand side expression, either a CDDL type or a
CDDL group.  Rule names can be used in the rule itself and/or other
rules (and tools can output warnings if that is not the case).  The
order of the rules is significant only in two cases:</t>

<t><list style="numbers">
  <t>The first rule defines the semantics of the entire specification;
hence, there is no need to give that root rule a special name or
special syntax in the language (as, e.g., with “start” in
Relax-NG); its name can be therefore chosen to be descriptive.
(As with all other rule names, the name of the initial rule may be
used in itself or in other rules).</t>
  <t>Where a rule contributes to a type or group choice (using <spanx style="verb">/=</spanx> or
<spanx style="verb">//=</spanx>), that choice is populated in the order the rules are given;
see below.</t>
</list></t>

<figure><artwork type="abnf"><![CDATA[
rule = typename [genericparm] S assignt S type
     / groupname [genericparm] S assigng S grpent

typename = id
groupname = id
]]></artwork></figure>

<t>A rule defines a name for a type expression (production <spanx style="verb">type</spanx>) or for
a group expression (production <spanx style="verb">grpent</spanx>), with the intention that the
semantics does not change when the name is replaced by its
(parenthesized if needed) definition.  Note that whether the name
defined by a rule stands for a type or a group isn’t always determined
by syntax alone: e.g., <spanx style="verb">a = b</spanx> can make <spanx style="verb">a</spanx> a type if <spanx style="verb">b</spanx> is a type, or a
group if <spanx style="verb">b</spanx> is a group.  More subtly, in <spanx style="verb">a = (b)</spanx>, <spanx style="verb">a</spanx> may be used as a
type if <spanx style="verb">b</spanx> is a type, or as a group both when <spanx style="verb">b</spanx> is a group and when
<spanx style="verb">b</spanx> is a type (a good convention to make the latter case stand out to
the human reader is to write <spanx style="verb">a = (b,)</spanx>).  (Note that the same dual
meaning of parentheses applies within an expression, but often can be
resolved by the context of the parenthesized expression.  On the more
general point, it may not
be clear immediately either whether <spanx style="verb">b</spanx> stands for a group or a type —
this semantic processing may need to span several levels of rule
definitions before a determination can be made.)</t>

<figure><artwork type="abnf"><![CDATA[
assignt = "=" / "/="
assigng = "=" / "//="
]]></artwork></figure>

<t>A plain equals sign defines the rule name as the equivalent of the
expression to the right; it is an error if the name already was
defined with a different expression.  A <spanx style="verb">/=</spanx> or <spanx style="verb">//=</spanx> extends a named type or a
group by additional choices; a number of these could be replaced by
collecting all the right hand sides and creating a single rule with a
type choice or a group choice built from the right hand sides in the
order of the rules given.  (It is
not an error to extend a rule name that has not yet been defined; this
makes the right hand side the first entry in the choice being
created.)</t>

<figure><artwork type="abnf"><![CDATA[
genericparm = "<" S id S *("," S id S ) ">"
genericarg = "<" S type1 S *("," S type1 S ) ">"
]]></artwork></figure>

<t>Rule names can have generic parameters, which cause temporary
assignments within the right hand sides to the parameter names from
the arguments given when citing the rule name.</t>

<figure><artwork type="abnf"><![CDATA[
type = type1 *(S "/" S type1)
]]></artwork></figure>

<t>A type can be given as a choice between one or more types.  The choice
matches a data item if the data item matches any one of the types given
in the choice.  The choice uses Parsing Expression Grammar semantics
as discussed in <xref target="sec-peg"/>:
The first choice that matches wins.  (As a result, the order of rules
that contribute to a single rule name can very well matter.)</t>

<figure><artwork type="abnf"><![CDATA[
type1 = type2 [S (rangeop / ctlop) S type2]
]]></artwork></figure>

<t>Two types can be combined with a range operator (which see below) or a
control operator (see <xref target="controls"/>).</t>

<figure><artwork type="abnf"><![CDATA[
type2 = value
]]></artwork></figure>

<t>A type can be just a single value (such as 1 or “icecream” or
h’0815’), which matches only a data item with that specific value (no
conversions defined),</t>

<figure><artwork type="abnf"><![CDATA[
      / typename [genericarg]
]]></artwork></figure>

<t>or be defined by a rule giving a meaning to a name (possibly after
supplying generic arguments as required by the generic parameters),</t>

<figure><artwork type="abnf"><![CDATA[
      / "(" S type S ")"
]]></artwork></figure>

<t>or be defined in a parenthesized type expression (parentheses may be
necessary to override some operator precedence), or</t>

<figure><artwork type="abnf"><![CDATA[
      / "{" S group S "}"
]]></artwork></figure>

<t>a map expression, which matches a valid CBOR map the key/value pairs
of which can be ordered in such a way that the resulting sequence
matches the group expression, or</t>

<figure><artwork type="abnf"><![CDATA[
      / "[" S group S "]"
]]></artwork></figure>

<t>an array expression, which matches a CBOR array the elements of which,
when taken as values and complemented by a wildcard (matches anything)
key each, match the group, or</t>

<figure><artwork type="abnf"><![CDATA[
      / "~" S typename [genericarg]
]]></artwork></figure>

<t>an “unwrapped” group (see <xref target="unwrapping"/>), which matches the group
inside a type defined as a map or an array by wrapping the group, or</t>

<figure><artwork type="abnf"><![CDATA[
      / "&" S "(" S group S ")"
      / "&" S groupname [genericarg]
]]></artwork></figure>

<t>an enumeration expression, which matches any a value that is within
the set of values that the values of the group given can take, or</t>

<figure><artwork type="abnf"><![CDATA[
      / "#" "6" ["." uint] "(" S type S ")"
]]></artwork></figure>

<t>a tagged data item, tagged with the <spanx style="verb">uint</spanx> given and containing the
type given as the tagged value, or</t>

<figure><artwork type="abnf"><![CDATA[
      / "#" DIGIT ["." uint]                ; major/ai
]]></artwork></figure>

<t>a data item of a major type (given by the DIGIT), optionally
constrained to the additional information given by the uint, or</t>

<figure><artwork type="abnf"><![CDATA[
      / "#"                                 ; any
]]></artwork></figure>

<t>any data item.</t>

<figure><artwork type="abnf"><![CDATA[
rangeop = "..." / ".."
]]></artwork></figure>

<t>A range operator can be used to join two type expressions that stand
for either two integer values or two floating point values; it matches
any value that is between the two values, where the first value is
always included in the matching set and the second value is included
for <spanx style="verb">..</spanx> and excluded for <spanx style="verb">...</spanx>.</t>

<figure><artwork type="abnf"><![CDATA[
ctlop = "." id
]]></artwork></figure>

<t>A control operator ties a <spanx style="emph">target</spanx> type to a <spanx style="emph">controller</spanx> type as
defined in <xref target="controls"/>.  Note that control operators are an extension
point for CDDL; additional documents may want to define additional
control operators.</t>

<figure><artwork type="abnf"><![CDATA[
group = grpchoice *(S "//" S grpchoice)
]]></artwork></figure>

<t>A group matches any sequence of key/value pairs that matches any of
the choices given (again using Parsing Expression Grammar semantics).</t>

<figure><artwork type="abnf"><![CDATA[
grpchoice = *(grpent optcom)
]]></artwork></figure>

<t>Each of the component groups is given as a sequence of group entries.
For a match, the sequence of key/value pairs given needs to match the sequence of
group entries in the sequence given.</t>

<figure><artwork type="abnf"><![CDATA[
grpent = [occur S] [memberkey S] type
]]></artwork></figure>

<t>A group entry can be given by a value type, which needs to be matched by
the value part of a single element, and optionally a memberkey type, which
needs to be matched by the key part of the element, if the memberkey
is given.
If the memberkey is not given, the entry can only be used for matching
arrays, not for maps.
(See below how that is modified by the occurrence indicator.)</t>

<figure><artwork type="abnf"><![CDATA[
       / [occur S] groupname [genericarg]  ; preempted by above
]]></artwork></figure>

<t>A group entry can be built from a named group, or</t>

<figure><artwork type="abnf"><![CDATA[
       / [occur S] "(" S group S ")"
]]></artwork></figure>

<t>from a parenthesized group, again with a possible occurrence indicator.</t>

<figure><artwork type="abnf"><![CDATA[
memberkey = type1 S ["^" S] "=>"
          / bareword S ":"
          / value S ":"
]]></artwork></figure>

<t>Key types can be given by a type expression, a bareword (which stands
for a type that just contains a string value created from this bareword), or a value (which stands
for a type that just contains this value).  A key value matches its
key type if the key value is a member of the key type, unless a cut
preceding it in the group applies (see <xref target="cuts-in-maps"/> how map
matching is influenced by the presence of the cuts denoted by “^” or
“:” in previous entries).</t>

<figure><artwork type="abnf"><![CDATA[
bareword = id
]]></artwork></figure>

<t>A bareword is an alternative way to write a type with a single text
string value; it can only be used in the syntactic context given above.</t>

<figure><artwork type="abnf"><![CDATA[
optcom = S ["," S]
]]></artwork></figure>

<t>(Optional commas do not influence the matching.)</t>

<figure><artwork type="abnf"><![CDATA[
occur = [uint] "*" [uint]
      / "+"
      / "?"
]]></artwork></figure>

<t>An occurrence indicator modifies the group given to its right by
requiring the group to match the sequence to be matched exactly for a
certain number of times (see <xref target="occurrence"/>) in sequence, i.e. it acts
as a (possibly infinite) group choice that contains choices with the
group repeated each of the occurrences times.</t>

<t>The rest of the ABNF describes syntax for value notation that should
be familiar from programming languages, with the possible exception of
h’..’ and b64’..’ for byte strings, as well as syntactic elements such
as comments and line ends.</t>

<!-- # (Not used.) -->

</section>
<section anchor="prelude" title="Standard Prelude">

<t>This appendix is normative.</t>

<t>The following prelude is automatically added to each CDDL file.
(Note that technically, it is a postlude, as it does not disturb the
selection of the first rule as the root of the definition.)</t>

<figure title="CDDL Prelude" anchor="fig-prelude"><artwork type="CDDL" align="center"><![CDATA[
any = #

uint = #0
nint = #1
int = uint / nint

bstr = #2
bytes = bstr
tstr = #3
text = tstr

tdate = #6.0(tstr)
time = #6.1(number)
number = int / float
biguint = #6.2(bstr)
bignint = #6.3(bstr)
bigint = biguint / bignint
integer = int / bigint
unsigned = uint / biguint
decfrac = #6.4([e10: int, m: integer])
bigfloat = #6.5([e2: int, m: integer])
eb64url = #6.21(any)
eb64legacy = #6.22(any)
eb16 = #6.23(any)
encoded-cbor = #6.24(bstr)
uri = #6.32(tstr)
b64url = #6.33(tstr)
b64legacy = #6.34(tstr)
regexp = #6.35(tstr)
mime-message = #6.36(tstr)
cbor-any = #6.55799(any)

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil
undefined = #7.23

]]></artwork></figure>

<t>Note that the prelude is deemed to be fixed.  This means, for instance,
that additional tags beyond <xref target="RFC7049"/>, as registered, need to be
defined in each CDDL file that is using them.</t>

<t>A common stumbling point is that the prelude does not define a type
<spanx style="verb">string</spanx>.  CBOR has byte strings (<spanx style="verb">bytes</spanx> in the prelude) and text
strings (<spanx style="verb">text</spanx>), so a type that is simply called <spanx style="verb">string</spanx> would be
ambiguous.</t>

<!-- The prelude as included here does not yet have a .regexp -->
<!--         control on tdate, but we probably do want to have one. -->

</section>
<section anchor="sec-json" title="Use with JSON">

<t>This appendix is normative.</t>

<t>The JSON generic data model (implicit in <xref target="RFC8259"/>) is a subset of the
generic data model of CBOR.  So one can use CDDL with JSON by limiting
oneself to what can be represented in JSON.  Roughly speaking, this
means leaving out byte strings, tags, and simple values other than
<spanx style="verb">false</spanx>, <spanx style="verb">true</spanx>, and <spanx style="verb">null</spanx>, leading to the following limited prelude:</t>

<figure title="JSON compatible subset of CDDL Prelude" anchor="fig-json-prelude"><artwork type="CDDL" align="center"><![CDATA[
any = #

uint = #0
nint = #1
int = uint / nint

tstr = #3
text = tstr

number = int / float

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil

]]></artwork></figure>

<t>(The major types given here do not have a direct meaning in JSON, but
they can be interpreted as CBOR major types translated through Section
4 of <xref target="RFC7049"/>.)</t>

<t>There are a few fine points in using CDDL with JSON.  First, JSON does
not distinguish between integers and floating point numbers; there is
only one kind of number (which may happen to be integral).  In this
context, specifying a type as <spanx style="verb">uint</spanx>, <spanx style="verb">nint</spanx> or <spanx style="verb">int</spanx> then becomes a
predicate that the number be integral.  As an example, this means that
the following JSON numbers are all matching <spanx style="verb">uint</spanx>:</t>

<figure><artwork><![CDATA[
10 10.0 1e1 1.0e1 100e-1
]]></artwork></figure>

<t>(The fact that these are all integers may be surprising to users
accustomed to the long tradition in programming languages of using
decimal points or exponents in a number to indicate a floating point
literal.)</t>

<t>CDDL distinguishes the various CBOR number types, but there is only
one number type in JSON.  The effect of specifying a floating point
precision (float16/float32/float64) is only to restrict the set of
permissible values to those expressible with
binary16/binary32/binary64; this is unlikely to be very useful when
using CDDL for specifying JSON data structures.</t>

<t>Fundamentally, the number system of JSON itself is based on decimal
numbers and decimal fractions and does not have limits to its
precision or range.  In practice, JSON numbers are often parsed into a
number type that is called float64 here, creating a number of
limitations to the generic data model <xref target="RFC7493"/>.  In particular,
this means that integers can only be expressed with interoperable
exactness when they lie in the range [-(2**53)+1, (2**53)-1] — a
smaller range than that covered by CDDL <spanx style="verb">int</spanx>.</t>

<t>JSON applications that want to stay compatible with I-JSON (<xref target="RFC7493"/>,
“Internet JSON”) therefore
may want to define integer types with more limited ranges, such as in
<xref target="fig-json-types"/>.  Note that the types given here are not part of
the prelude; they need to be copied into the CDDL specification if
needed.</t>

<figure title="I-JSON types for CDDL (not part of prelude)" anchor="fig-json-types"><artwork type="CDDL" align="center"><![CDATA[
ij-uint = 0..9007199254740991
ij-nint = -9007199254740991..-1
ij-int = -9007199254740991..9007199254740991
]]></artwork></figure>

<t>JSON applications that do not need to stay compatible with I-JSON and
that actually may need to go beyond the 64-bit unsigned and negative
integers supported by <spanx style="verb">int</spanx> (= <spanx style="verb">uint</spanx>/<spanx style="verb">nint</spanx>) may want to use the
following additional types from the standard prelude, which are
expressed in terms of tags but can straightforwardly be mapped into
JSON (but not I-JSON) numbers:</t>

<figure><artwork type="CDDL"><![CDATA[
biguint = #6.2(bstr)
bignint = #6.3(bstr)
bigint = biguint / bignint
integer = int / bigint
unsigned = uint / biguint
]]></artwork></figure>

<t>CDDL at this point does not have a way to express the unlimited
floating point precision that is theoretically possible with JSON;
at the time of writing, this is rarely used in protocols in practice.</t>

<t>Note that a data model described in CDDL is always restricted by what
can be expressed in the serialization; e.g., floating point values
such as NaN (not a number) and the infinities cannot be represented in
JSON even if they are allowed in the CDDL generic data model.</t>

</section>
<section anchor="tool" title="A CDDL tool">

<t>This appendix is for information only.</t>

<t>A rough CDDL tool is available.  For CDDL specifications, it can check
the syntax, generate one or more instances
(expressed in CBOR diagnostic notation or in pretty-printed JSON), and
validate an existing instance against the specification:</t>

<figure title="CDDL tool usage" anchor="tool-usage"><artwork align="center"><![CDATA[
Usage:
cddl spec.cddl generate [n]
cddl spec.cddl json-generate [n]
cddl spec.cddl validate instance.cbor
cddl spec.cddl validate instance.json
]]></artwork></figure>

<t>Install on a system with a modern Ruby via:</t>

<figure title="CDDL tool installation" anchor="tool-install"><artwork type="shell" align="center"><![CDATA[
gem install cddl
]]></artwork></figure>

<t>The accompanying CBOR diagnostic tools (which are automatically
installed by the above) are described in
<eref target="https://github.com/cabo/cbor-diag">https://github.com/cabo/cbor-diag</eref>; they can be used to convert between
binary CBOR, a pretty-printed form of that, CBOR diagnostic notation,
JSON, and YAML.</t>

</section>
<section anchor="extended-diagnostic-notation" title="Extended Diagnostic Notation">

<t>This appendix is normative.</t>

<t>Section 6 of <xref target="RFC7049"/> defines a “diagnostic notation” in order to
be able to converse about CBOR data items without having to resort to
binary data.  Diagnostic notation is based on JSON, with extensions
for representing CBOR constructs such as binary data and tags.</t>

<t>(Standardizing this together with the actual interchange format does
not serve to create another interchange format, but enables the use of
a shared diagnostic notation in tools for and documents about CBOR.)</t>

<t>This section discusses a few extensions to the diagnostic notation
that have turned out to be useful since RFC 7049 was written.
We refer to the result as extended diagnostic notation (EDN).</t>

<section anchor="white-space-in-byte-string-notation" title="White space in byte string notation">

<t>Examples often benefit from some white space (spaces, line breaks) in
byte strings.  In extended diagnostic notation, white space is
ignored in prefixed byte strings; for instance, the following are
equivalent:</t>

<figure><artwork><![CDATA[
  h'48656c6c6f20776f726c64'
  h'48 65 6c 6c 6f 20 77 6f 72 6c 64'
  h'4 86 56c 6c6f
    20776 f726c64'
]]></artwork></figure>

</section>
<section anchor="textbin" title="Text in byte string notation">

<t>Diagnostic notation notates Byte strings in one of the <xref target="RFC4648"/>
base encodings,, enclosed in single quotes, prefixed by &gt;h&lt; for
base16, &gt;b32&lt; for base32, &gt;h32&lt; for base32hex, &gt;b64&lt; for base64 or
base64url.  Quite often, byte strings carry bytes that are
meaningfully interpreted as UTF-8 text.  Extended Diagnostic Notation
allows the use of single quotes without a prefix to express byte
strings with UTF-8 text; for instance, the following are equivalent:</t>

<figure><artwork><![CDATA[
'hello world'
h'68656c6c6f20776f726c64'
]]></artwork></figure>

<t>The escaping rules of JSON strings are applied equivalently for
text-based byte strings, e.g., \ stands for a single backslash and
' stands for a single quote.  White space is included literally,
i.e., the previous section does not apply to text-based byte strings.</t>

</section>
<section anchor="embedded-cbor-and-cbor-sequences-in-byte-strings" title="Embedded CBOR and CBOR sequences in byte strings">

<t>Where a byte string is to carry an embedded CBOR-encoded item, or more
generally a sequence of zero or more such items, the diagnostic
notation for these zero or more CBOR data items, separated by commata,
can be enclosed in « and » to notate the byte string resulting from
encoding the data items and concatenating the result.  For
instance, each pair of columns in the following are equivalent:</t>

<figure><artwork><![CDATA[
<<1>>              h'01'
<<1, 2>>           h'0102'
<<"foo", null>>    h'63666F6FF6'
<<>>               h''
]]></artwork></figure>

</section>
<section anchor="concatenated-strings" title="Concatenated Strings">

<t>While the ability to include white space enables line-breaking of
encoded byte strings, a mechanism is needed to be able to include
text strings as well as byte strings in direct UTF-8 representation
into line-based documents (such as RFCs and source code).</t>

<t>We extend the diagnostic notation by allowing multiple text strings or
multiple byte strings to be notated separated by white space, these
are then concatenated into a single text or byte string, respectively.
Text strings and byte strings do not mix within such a
concatenation, except that byte string notation can be used inside a
sequence of concatenated text string notation to encode characters
that may be better represented in an encoded way.  The following four
values are equivalent:</t>

<figure><artwork><![CDATA[
"Hello world"
"Hello " "world"
"Hello" h'20' "world"
"" h'48656c6c6f20776f726c64' ""
]]></artwork></figure>

<t>Similarly, the following byte string values are equivalent</t>

<figure><artwork><![CDATA[
'Hello world'
'Hello ' 'world'
'Hello ' h'776f726c64'
'Hello' h'20' 'world'
'' h'48656c6c6f20776f726c64' '' b64''
h'4 86 56c 6c6f' h' 20776 f726c64'
]]></artwork></figure>

<t>(Note that the approach of separating by whitespace, while familiar
from the C language, requires some attention – a single comma makes a
big difference here.)</t>

</section>
<section anchor="hexadecimal-octal-and-binary-numbers" title="Hexadecimal, octal, and binary numbers">

<t>In addition to JSON’s decimal numbers, EDN provides hexadecimal, octal
and binary numbers in the usual C-language notation (octal with 0o
prefix present only).</t>

<t>The following are equivalent:</t>

<figure><artwork><![CDATA[
4711
0x1267
0o11147
0b1001001100111
]]></artwork></figure>

<t>As are:</t>

<figure><artwork><![CDATA[
1.5
0x1.8p0
0x18p-4
]]></artwork></figure>

</section>
<section anchor="comments" title="Comments">

<t>Longer pieces of diagnostic notation may benefit from comments.
JSON famously does not provide for comments, and basic RFC 7049
diagnostic notation inherits this property.</t>

<t>In extended diagnostic notation, comments can be included, delimited
by slashes (“/”).  Any text within and including a pair of slashes is
considered a comment.</t>

<t>Comments are considered white space.  Hence, they are allowed in
prefixed byte strings; for instance, the following are equivalent:</t>

<figure><artwork><![CDATA[
h'68656c6c6f20776f726c64'
h'68 65 6c /doubled l!/ 6c 6f /hello/
  20 /space/
  77 6f 72 6c 64' /world/
]]></artwork></figure>

<t>This can be used to annotate a CBOR structure as in:</t>

<figure><artwork type="CBORdiag"><![CDATA[
/grasp-message/ [/M_DISCOVERY/ 1, /session-id/ 10584416,
                 /objective/ [/objective-name/ "opsonize",
                              /D, N, S/ 7, /loop-count/ 105]]
]]></artwork></figure>

<t>(There are currently no end-of-line comments.  If we want to add them,
“//” sounds like a reasonable delimiter given that we already use
slashes for comments, but we also could go e.g. for “#”.)</t>

<!--  LocalWords:  notational CBOR CDDL JSON valuetype datatype ABNF IP
 -->
<!--  LocalWords:  valuetypes datatypes processable tstr uint nint LF
 -->
<!--  LocalWords:  bstr keytype Struct ASN positionally struct Structs
 -->
<!--  LocalWords:  optionality extensibility structs predefines CRLF
 -->
<!--  LocalWords:  bareword barewords UTF bool IEEE reputon analysis
 -->
<!--  LocalWords:  wildcard validator IANA implementers prepended JCR
 -->

<!-- Examples  -->

</section>
</section>
<section anchor="examples" title="Examples">

<t>This appendix is for information only.</t>

<t>This section contains a few examples of structures defined using
CDDL.</t>

<t>The theme for the first example is taken from <xref target="RFC7071"/>, which
defines certain JSON structures in English.  For a similar example, it
may also be of interest to examine Appendix A of <xref target="RFC8007"/>, which
contains a CDDL definition for a JSON structure defined in the
main body of the RFC.</t>

<t>The second subsection in this appendix translates examples from
<xref target="I-D.newton-json-content-rules"/> into CDDL.</t>

<t>These examples all happen to describe data that is interchanged in
JSON.  Examples for CDDL definitions of data that is interchanged in
CBOR can be found in <xref target="RFC8152"/>, <xref target="I-D.ietf-anima-grasp"/>, or <xref target="RFC8428"/>.</t>

<section anchor="example-7071" title="RFC 7071">

<t><xref target="RFC7071"/> defines the Reputon structure for JSON using somewhat
formalized English text. Here is a (somewhat verbose) equivalent
definition using the same terms, but notated in CDDL:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
reputation-object = {
  reputation-context,
  reputon-list
}

reputation-context = (
  application: text
)

reputon-list = (
  reputons: reputon-array
)

reputon-array = [* reputon]

reputon = {
  rater-value,
  assertion-value,
  rated-value,
  rating-value,
  ? conf-value,
  ? normal-value,
  ? sample-value,
  ? gen-value,
  ? expire-value,
  * ext-value,
}

rater-value = ( rater: text )
assertion-value = ( assertion: text )
rated-value = ( rated: text )
rating-value = ( rating: float16 )
conf-value = ( confidence: float16 )
normal-value = ( normal-rating: float16 )
sample-value = ( sample-size: uint )
gen-value = ( generated: uint )
expire-value = ( expires: uint )
ext-value = ( text => any )
]]></artwork></figure>

<t>An equivalent, more compact form of this example would be:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
reputation-object = {
  application: text
  reputons: [* reputon]
}

reputon = {
  rater: text
  assertion: text
  rated: text
  rating: float16
  ? confidence: float16
  ? normal-rating: float16
  ? sample-size: uint
  ? generated: uint
  ? expires: uint
  * text => any
}
]]></artwork></figure>

<t>Note how this rather clearly delineates the structure somewhat
shrouded by so many words in section 6.2.2. of <xref target="RFC7071"/>.
Also, this definition makes it clear that several ext-values are
allowed (by definition with different member names); RFC 7071 could be
read to forbid the repetition of ext-value (“A specific
reputon-element MUST NOT appear more than once” is ambiguous.)</t>

<t>The CDDL tool reported on in <xref target="tool"/> generates as one example:</t>

<figure><artwork type="JSON" align="center"><![CDATA[
{
  "application": "conchometry",
  "reputons": [
    {
      "rater": "Ephthianura",
      "assertion": "codding",
      "rated": "sphaerolitic",
      "rating": 0.34133473256800795,
      "confidence": 0.9481983064298332,
      "expires": 1568,
      "unplaster": "grassy"
    },
    {
      "rater": "nonchargeable",
      "assertion": "raglan",
      "rated": "alienage",
      "rating": 0.5724646875815566,
      "sample-size": 3514,
      "Aldebaran": "unchurched",
      "puruloid": "impersonable",
      "uninfracted": "pericarpoidal",
      "schorl": "Caro"
    },
    {
      "rater": "precollectable",
      "assertion": "Merat",
      "rated": "thermonatrite",
      "rating": 0.19164006323936977,
      "confidence": 0.6065252103391268,
      "normal-rating": 0.5187773690879303,
      "generated": 899,
      "speedy": "solidungular",
      "noviceship": "medicine",
      "checkrow": "epidictic"
    }
  ]
}
]]></artwork></figure>

</section>
<section anchor="examples-from-json-content-rules" title="Examples from JSON Content Rules">

<t>Although <xref target="I-D.newton-json-content-rules">JSON Content Rules</xref> seems to
address a more general problem than CDDL, it is still a worthwhile
resource to explore for examples (beyond all the inspiration the
format itself has had for CDDL).</t>

<t>Figure 2 of the JCR I-D looks very similar, if slightly less noisy, in CDDL:</t>

<figure title="JCR, Figure 2, in CDDL" anchor="jcrfig2"><artwork type="CDDL" align="center"><![CDATA[
root = [2*2 {
  precision: text,
  Latitude: float,
  Longitude: float,
  Address: text,
  City: text,
  State: text,
  Zip: text,
  Country: text
}]
]]></artwork></figure>

<t>Apart from the lack of a need to quote the member names, text strings
are called <spanx style="verb">text</spanx> or <spanx style="verb">tstr</spanx> in CDDL (<spanx style="verb">string</spanx> would be ambiguous as
CBOR also provides byte strings).</t>

<t>The CDDL tool reported on in <xref target="tool"/> creates the below example instance for this:</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
[{"precision": "pyrosphere", "Latitude": 0.5399712314350172,
  "Longitude": 0.5157523963028087, "Address": "resow",
  "City": "problemwise", "State": "martyrlike", "Zip": "preprove",
  "Country": "Pace"},
 {"precision": "unrigging", "Latitude": 0.10422704368372193,
  "Longitude": 0.6279808663725834, "Address": "picturedom",
  "City": "decipherability", "State": "autometry", "Zip": "pout",
  "Country": "wimple"}]
]]></artwork></figure>

<t>Figure 4 of the JCR I-D in CDDL:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
root = { image }

image = (
  Image: {
    size,
    Title: text,
    thumbnail,
    IDs: [* int]
  }
)

size = (
  Width: 0..1280
  Height: 0..1024
)

thumbnail = (
  Thumbnail: {
    size,
    Url: ~uri
  }
)
]]></artwork></figure>

<t>This shows how the group concept can be used to keep related elements
(here: width, height) together, and to emulate the JCR style of
specification.  (It also shows referencing a type by unwrapping a tag
from the prelude, <spanx style="verb">uri</spanx> – this could be done differently.)  The more
compact form of Figure 5 of the JCR I-D could be emulated like this:</t>

<figure><artwork type="CDDL" align="center"><![CDATA[
root = {
  Image: {
    size, Title: text,
    Thumbnail: { size, Url: ~uri },
    IDs: [* int]
  }
}

size = (
  Width: 0..1280,
  Height: 0..1024,
)
]]></artwork></figure>

<t>The CDDL tool reported on in <xref target="tool"/> creates the below example instance for this:</t>

<figure><artwork type="CBORdiag" align="center"><![CDATA[
{"Image": {"Width": 566, "Height": 516, "Title": "leisterer",
  "Thumbnail": {"Width": 1111, "Height": 176, "Url": 32("scrog")},
  "IDs": []}}
]]></artwork></figure>

</section>
</section>
<section numbered="no" anchor="contributors" title="Contributors">

<t>CDDL was originally conceived by Bert Greevenbosch, who also wrote the
original five versions of this document.</t>

</section>
<section numbered="no" anchor="acknowledgements" title="Acknowledgements">

<t>Inspiration was taken from the C and Pascal languages, MPEG’s
conventions for describing structures in the ISO base media file
format, Relax-NG and its compact syntax <xref target="RELAXNG"/>, and in particular
from Andrew Lee Newton’s <xref target="I-D.newton-json-content-rules">“JSON Content Rules”</xref>.</t>

<t>Lots of highly useful feedback came from members of the IETF CBOR WG,
in particular
Ari Keränen,
Brian Carpenter,
Burt Harris,
Jeffrey Yasskin,
Jim Hague,
Jim Schaad,
Joe Hildebrand,
Max Pritikin,
Michael Richardson,
Pete Cordell,
Sean Leonard,
and
Yaron Sheffer.
Also, Francesca Palombini and Joe volunteered to chair the WG when it
was created, providing the framework for generating and processing this
feedback; with Barry Leiba having taken over from Joe since.
Chris Lonvick and Ines Robles provided additional reviews during IESG
processing, and Alexey Melnikov steered the process as the responsible
area director.</t>

<t>The CDDL tool reported on in <xref target="tool"/> was written by Carsten Bormann,
building on previous work by Troy Heninger and Tom Lord.</t>

<!--  LocalWords:  representable precedences Arities unary Naur CFGs
 -->
<!--  LocalWords:  Chomsky's subdialects unordered
 -->

</section>


  </back>

<!-- ##markdown-source:
H4sIAAQNZFwAA9y96ZbbRpYu+j+eAk3VqSRlkjkolbJSJbtSk62+tuQryT3J
ahEkkUmUSIAFgEqlVap1HuI8QP+4T9L3Tc6T3P3tISIAMlVyD+uudbRsiQSB
QAw7duzx26PRyNVNWszfpsuyyE6TptpkLl9X/Klujg4O7h4cuXk5K9IV/Tyv
0vNmlGfN+Wg2LavRbD5fjpZpk9WNm6XNaVI3c7fOT12SNOXsNNm7yuo9+lJf
rarsvA4XZuVqnc6a1oVVVjT+liZvlvTCb+inh2Uxy+ssmadNmsyz87zIm7ws
kmVaXGzSiyzpP3z06IcBXpomRdmk+DVdUpPFe2oStzZlkn1YV1ldJw8fPH+R
0IiTv3/5/Jm0WdNYZ82GfnbpdFpl708TtOjSKktPk7P1epnPuNHaXV6ccguO
HqTuHR0c3h0dHI0Oj1y6aRZldepGSV7QKL4fJw/y6t2iXP5K/ZLZ+z4r3sVX
y4pae1Klm2JRnmdV8vLpK4xBu7D1Q7ZK8+VpsqBWxlNt5Y913ozP/Z3jeYbZ
bqoso7l9scioL02V1jR7d27zLM+pH3snx0d3b/Os583VafIorVZEBfOG79gU
TUUXv8uqVVpc2XgejpN/yC/SovSjebio8rop14vwAw/o5yJ/n1XUr//3/2mS
B1VGyxqNavevOrSZNTl+z03+cVPkoynfhJGFrjwo0bki9CWt6iYrouvtrqSZ
vSx59S9PwxTRpxGtyHSZl80ie0dXx8mhnxffPZm2R6Ojr2/dvrtrkpJkveD9
89Xx3dHx0eHo6PDr0cmtu0eH0eDSafnH5td8TF1zBTraUO/QhRdPHt66ffuI
dk82I6Kl1Zrp1ZOju6fJpjn/Wr4fnxx/fZpM0zqT77ePbh2f0tQW5/L9zsEx
3Y+dKd+/Pjw6OU3ytEjX5VIvHd2mW/5Ul4U+cnz3Ft0y0iv/eOvh+MXjh6MP
q2U9W1DPR0cjYgLHhwdH9OYP9fyIbnr68vnJAT1GH2lhle7xeSTTTr/z12gP
48/T4lxGTRtyXZUz2o15cZGMRsmLDHuT9qr8WJ4nxWaVVbTrlsn7dLnJalp5
oo60Ip5B+4HWiZ6sE2qPfgit5gX9SrcVFxm/s6Y2shp3nFofXj4/TdB5/i6b
+PDu17edb0aX5PEPZ//07LvTvzWOJpstinJZXlwl//t//q/kUTnbgI0lL3ny
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
ATZx4quxdQEA

-->

</rfc>

