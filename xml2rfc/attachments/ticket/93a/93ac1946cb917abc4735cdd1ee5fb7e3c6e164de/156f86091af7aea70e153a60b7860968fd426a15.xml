<?xml version="1.0" encoding="UTF-8"?>
<!--
    This XML document is the output of clean-for-DTD.xslt; a tool that strips
    extensions to RFC 7749 from documents for processing with xml2rfc.
-->
<!--TARGET-GENERATOR: 201706-->
<!--TARGET-VOCABULARY: 3-->
<?xml-stylesheet type='text/xsl' href='lib/myxml2rfc.xslt'?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>

<!DOCTYPE rfc
  PUBLIC "" "rfc2629.dtd">
<rfc version="3" obsoletes="7230" category="std" ipr="pre5378Trust200902" docName="draft-ietf-httpbis-messaging-latest">
   <front>
      <title>HTTP/1.1 Messaging</title>
      <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
         <organization>Adobe</organization>
         <address>
            <postal>
               <street>345 Park Ave</street>
               <city>San Jose</city>
               <region>CA</region>
               <code>95110</code>
               <country>USA</country>
            </postal>
            <email>fielding@gbiv.com</email>
            <uri>https://roy.gbiv.com/</uri>
         </address>
      </author>
      <author fullname="Mark Nottingham" initials="M." role="editor" surname="Nottingham">
         <organization>Fastly</organization>
         <address>
            <email>mnot@mnot.net</email>
            <uri>https://www.mnot.net/</uri>
         </address>
      </author>
      <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
         <organization abbrev="greenbytes">greenbytes GmbH</organization>
         <address>
            <postal>
               <street>Hafenweg 16</street>
               <city>Muenster</city>
               <region>NW</region>
               <code>48155</code>
               <country>Germany</country>
            </postal>
            <email>julian.reschke@greenbytes.de</email>
            <uri>https://greenbytes.de/tech/webdav/</uri>
         </address>
      </author>
      <date/>
      <area>Applications and Real-Time</area>
      <workgroup>HTTP Working Group</workgroup>
      <keyword>Hypertext Transfer Protocol</keyword>
      <keyword>HTTP</keyword>
      <keyword>HTTP message format</keyword>
      <abstract>
         <t>
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level
   protocol for distributed, collaborative, hypertext information systems.
   This document specifies the HTTP/1.1 message syntax, message parsing,
   connection management, and related security concerns.
</t>
         <t>
   This document obsoletes portions of RFC 7230.
</t>
      </abstract>
      <note title="Editorial Note">
         <t>This note is to be removed before publishing as an RFC.</t>
         <t>
    Discussion of this draft takes place on the HTTP working group
    mailing list (ietf-http-wg@w3.org), which is archived at
    <eref target="https://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
  </t>
         <t>
    Working Group information can be found at <eref target="https://httpwg.org/"/>;
    source code and issues list for this draft can be found at
    <eref target="https://github.com/httpwg/http-core"/>.
  </t>
         <t>
    The changes in this draft are summarized in <xref target="changes.since.05"/>.
  </t>
      </note>
   </front>
   <middle>
      <section anchor="introduction" title="Introduction">
         <t>
   The Hypertext Transfer Protocol (HTTP) is a stateless application-level
   request/response protocol that uses extensible semantics and
   self-descriptive messages for flexible interaction with network-based
   hypertext information systems. HTTP is defined by a series of documents
   that collectively form the HTTP/1.1 specification:
</t>
         <ul>
            <li>"HTTP Semantics" <xref target="Semantics"/>
            </li>
            <li>"HTTP Caching" <xref target="Caching"/>
            </li>
            <li>"HTTP/1.1 Messaging" (this document)</li>
         </ul>
         <t>
   This document defines HTTP/1.1 message syntax and framing requirements
   and their associated connection management.
   Our goal is to define all of the mechanisms necessary for HTTP/1.1 message
   handling that are independent of message semantics, thereby defining the
   complete set of requirements for message parsers and
   message-forwarding intermediaries.
</t>
         <t>
   This document obsoletes the portions of
   RFC 7230 related to HTTP/1.1
   messaging and connection management, with the changes being summarized in
   <xref target="changes.from.rfc.7230"/>. The other parts of
   RFC 7230 are obsoleted by
   "HTTP Semantics" <xref target="Semantics"/>.
</t>
         <section anchor="intro.requirements" title="Requirements Notation">
            <t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
            <t>
   Conformance criteria and considerations regarding error handling
   are defined in Section 3 of <xref target="Semantics"/>.
</t>
         </section>
         <section anchor="notation" title="Syntax Notation">
            <iref primary="true" item="Grammar" subitem="ALPHA"/>
            <iref primary="true" item="Grammar" subitem="CR"/>
            <iref primary="true" item="Grammar" subitem="CRLF"/>
            <iref primary="true" item="Grammar" subitem="CTL"/>
            <iref primary="true" item="Grammar" subitem="DIGIT"/>
            <iref primary="true" item="Grammar" subitem="DQUOTE"/>
            <iref primary="true" item="Grammar" subitem="HEXDIG"/>
            <iref primary="true" item="Grammar" subitem="HTAB"/>
            <iref primary="true" item="Grammar" subitem="LF"/>
            <iref primary="true" item="Grammar" subitem="OCTET"/>
            <iref primary="true" item="Grammar" subitem="SP"/>
            <iref primary="true" item="Grammar" subitem="VCHAR"/>
            <t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation of
   <xref target="RFC5234"/>, extended with the notation for case-sensitivity
   in strings defined in <xref target="RFC7405"/>.
</t>
            <t>   
   It also uses a list extension, defined in Section 11 of <xref target="Semantics"/>,
   that allows for compact definition of comma-separated lists using a '#'
   operator (similar to how the '*' operator indicates repetition). <xref target="collected.abnf"/> shows the collected grammar with all list
   operators expanded to standard ABNF notation.
</t>
            <t>
   As a convention, ABNF rule names prefixed with "obs-" denote
   "obsolete" grammar rules that appear for historical reasons.
</t>
            <t anchor="core.rules">
  
  
  
  
  
  
  
  
  
  
  
  
   The following core rules are included by
   reference, as defined in <xref target="RFC5234"/>, Appendix B.1:
   ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
   DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed),
   OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible <xref target="USASCII"/> character).
</t>
            <t anchor="imported.rules">
  
  
  
  
  
  
  
  
  
  
  The rules below are defined in <xref target="Semantics"/>:
</t>
            <sourcecode type="abnf7230"><![CDATA[  BWS           = <BWS, see [Semantics], Section 4.3>
  OWS           = <OWS, see [Semantics], Section 4.3>
  RWS           = <RWS, see [Semantics], Section 4.3>
  absolute-URI  = <absolute-URI, see [RFC3986], Section 4.3>
  absolute-path = <absolute-path, see [Semantics], Section 2.4>
  authority     = <authority, see [RFC3986], Section 3.2>
  comment       = <comment, see [Semantics], Section 4.2.3>
  field-name    = <field-name, see [Semantics], Section 4.2>
  field-value   = <field-value, see [Semantics], Section 4.2>
  obs-text      = <obs-text, see [Semantics], Section 4.2.3>
  port          = <port, see [RFC3986], Section 3.2.3>
  query         = <query, see [RFC3986], Section 3.4>
  quoted-string = <quoted-string, see [Semantics], Section 4.2.3>
  token         = <token, see [Semantics], Section 4.2.3>
  uri-host      = <host, see [RFC3986], Section 3.2.2>
]]></sourcecode>
         </section>
      </section>
      <section anchor="http.message" title="Message">
         <section anchor="message.format" title="Message Format">
            <iref item="header section"/>
            <iref item="headers"/>
            <iref item="header field"/>
            <t>
   All HTTP/1.1 messages consist of a start-line followed by a CRLF and a
   sequence of
   octets in a format similar to the Internet Message Format
   <xref target="RFC5322"/>: zero or more header fields (collectively
   referred to as the "headers" or the "header section"), an empty line
   indicating the end of the header section, and an optional message body.
</t>
            <iref primary="true" item="Grammar" subitem="HTTP-message"><!--terminal production--></iref>
            <sourcecode type="abnf7230"><![CDATA[  HTTP-message   = start-line CRLF
                   *( header-field CRLF )
                   CRLF
                   [ message-body ]
]]></sourcecode>
            <t>
   An HTTP message can be either a request from client to server or a
   response from server to client.  Syntactically, the two types of message
   differ only in the start-line, which is either a request-line (for requests)
   or a status-line (for responses), and in the algorithm for determining
   the length of the message body (<xref target="message.body"/>).
</t>
            <iref primary="true" item="Grammar" subitem="start-line"/>
            <sourcecode type="abnf7230"><![CDATA[  start-line     = request-line / status-line
]]></sourcecode>
            <t>
   In theory, a client could receive requests and a server could receive
   responses, distinguishing them by their different start-line formats.
   In practice, servers are implemented to only expect a request
   (a response is interpreted as an unknown or invalid request method)
   and clients are implemented to only expect a response.
</t>
            <t>
   Although HTTP makes use of some protocol elements similar to
   the Multipurpose Internet Mail Extensions (MIME) <xref target="RFC2045"/>, 
   see <xref target="differences.between.http.and.mime"/> for the differences
   between HTTP and MIME messages.
</t>
         </section>
         <section anchor="http.version" title="HTTP Version">
            <t>
   HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate
   versions of the protocol. This specification defines version "1.1".
   Section 3.5 of <xref target="Semantics"/> specifies the semantics of HTTP version
   numbers.
</t>
            <t>
   The version of an HTTP/1.x message is indicated by an HTTP-version field
   in the <xref target="message.format" format="none">start-line</xref>. HTTP-version is case-sensitive.
</t>
            <iref primary="true" item="Grammar" subitem="HTTP-version"/>
            <iref primary="true" item="Grammar" subitem="HTTP-name"/>
            <sourcecode type="abnf7230"><![CDATA[  HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
  HTTP-name     = %s"HTTP"
]]></sourcecode>
            <t>
   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient
   <xref target="RFC1945"/> or a recipient whose version is unknown,
   the HTTP/1.1 message is constructed such that it can be interpreted
   as a valid HTTP/1.0 message if all of the newer features are ignored.
   This specification places recipient-version requirements on some
   new features so that a conformant sender will only use compatible
   features until it has determined, through configuration or the
   receipt of a message, that the recipient supports HTTP/1.1.
</t>
            <t>
   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) <bcp14>MUST</bcp14> send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to blindly
   forward the <xref target="message.format" format="none">start-line</xref> without ensuring that the
   protocol version in that message matches a version to which that
   intermediary is conformant for both the receiving and
   sending of messages.  Forwarding an HTTP message without rewriting
   the HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what features
   are safe to use for later communication with that sender.
</t>
            <t>
   A server <bcp14>MAY</bcp14> send an HTTP/1.0 response to an HTTP/1.1 request
   if it is known or suspected that the client incorrectly implements the
   HTTP specification and is incapable of correctly processing later
   version responses, such as when a client fails to parse the version
   number correctly or when an intermediary is known to blindly forward
   the HTTP-version even when it doesn't conform to the given minor
   version of the protocol. Such protocol downgrades <bcp14>SHOULD NOT</bcp14> be
   performed unless triggered by specific client attributes, such as when
   one or more of the request header fields (e.g., User-Agent)
   uniquely match the values sent by a client known to be in error.
</t>
         </section>
         <section anchor="message.parsing" title="Message Parsing">
            <t>
   The normal procedure for parsing an HTTP message is to read the
   start-line into a structure, read each header field into a hash
   table by field name until the empty line, and then use the parsed
   data to determine if a message body is expected.  If a message body
   has been indicated, then it is read as a stream until an amount
   of octets equal to the message body length is read or the connection
   is closed.
</t>
            <t>
   A recipient <bcp14>MUST</bcp14> parse an HTTP message as a sequence of octets in an
   encoding that is a superset of US-ASCII <xref target="USASCII"/>.
   Parsing an HTTP message as a stream of Unicode characters, without regard
   for the specific encoding, creates security vulnerabilities due to the
   varying ways that string processing libraries handle invalid multibyte
   character sequences that contain the octet LF (%x0A).  String-based
   parsers can only be safely used within protocol elements after the element
   has been extracted from the message, such as within a header field-value
   after message parsing has delineated the individual fields.
</t>
            <t>
   Although the line terminator for the start-line and header
   fields is the sequence CRLF, a recipient <bcp14>MAY</bcp14> recognize a
   single LF as a line terminator and ignore any preceding CR.
</t>
            <t>
   Older HTTP/1.0 user agent implementations might send an extra CRLF
   after a POST request as a workaround for some early server
   applications that failed to read message body content that was
   not terminated by a line-ending. An HTTP/1.1 user agent <bcp14>MUST NOT</bcp14>
   preface or follow a request with an extra CRLF.  If terminating
   the request message body with a line-ending is desired, then the
   user agent <bcp14>MUST</bcp14> count the terminating CRLF octets as part of the
   message body length.
</t>
            <t>
   In the interest of robustness, a server that is expecting to receive and
   parse a request-line <bcp14>SHOULD</bcp14> ignore at least one empty line (CRLF)
   received prior to the request-line.
</t>
            <t>
   A sender <bcp14>MUST NOT</bcp14> send whitespace between the start-line and
   the first header field.
   A recipient that receives whitespace between the start-line and
   the first header field <bcp14>MUST</bcp14> either reject the message as invalid or
   consume each whitespace-preceded line without further processing of it
   (i.e., ignore the entire line, along with any subsequent lines preceded
   by whitespace, until a properly formed header field is received or the
   header section is terminated).
</t>
            <t>
   The presence of such whitespace in a request
   might be an attempt to trick a server into ignoring that field or
   processing the line after it as a new request, either of which might
   result in a security vulnerability if other implementations within
   the request chain interpret the same message differently.
   Likewise, the presence of such whitespace in a response might be
   ignored by some clients or cause others to cease parsing.
</t>
            <t>
   When a server listening only for HTTP request messages, or processing
   what appears from the start-line to be an HTTP request message,
   receives a sequence of octets that does not match the HTTP-message
   grammar aside from the robustness exceptions listed above, the
   server <bcp14>SHOULD</bcp14> respond with a 400 (Bad Request) response.
</t>
         </section>
      </section>
      <section anchor="request.line" title="Request Line">
         <t>
   A request-line begins with a method token, followed by a single
   space (SP), the request-target, another single space (SP), and ends
   with the protocol version.
</t>
         <iref primary="true" item="Grammar" subitem="request-line"/>
         <sourcecode type="abnf7230"><![CDATA[  request-line   = method SP request-target SP HTTP-version
]]></sourcecode>
         <t>
   Although the request-line grammar rule requires that each of the component
   elements be separated by a single SP octet, recipients <bcp14>MAY</bcp14> instead parse
   on whitespace-delimited word boundaries and, aside from the CRLF
   terminator, treat any form of whitespace as the SP separator while
   ignoring preceding or trailing whitespace; such whitespace includes one or
   more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.
   However, lenient parsing can result in request smuggling security
   vulnerabilities if there are multiple recipients of the message and each
   has its own unique interpretation of robustness
   (see <xref target="request.smuggling"/>).
</t>
         <t>
   HTTP does not place a predefined limit on the length of a request-line,
   as described in Section 3 of <xref target="Semantics"/>.
   A server that receives a method longer than any that it implements
   <bcp14>SHOULD</bcp14> respond with a 501 (Not Implemented) status code.
   A server that receives a request-target longer than any URI it wishes to
   parse <bcp14>MUST</bcp14> respond with a
   414 (URI Too Long) status code (see Section 9.5.15 of <xref target="Semantics"/>).
</t>
         <t>
   Various ad hoc limitations on request-line length are found in practice.
   It is <bcp14>RECOMMENDED</bcp14> that all HTTP senders and recipients support, at a
   minimum, request-line lengths of 8000 octets.
</t>
         <section anchor="request.method" title="Method">
            <iref primary="true" item="method"/>
            <t>
   The method token indicates the request method to be performed on the
   target resource. The request method is case-sensitive.
</t>
            <iref primary="true" item="Grammar" subitem="method"/>
            <sourcecode type="abnf7230"><![CDATA[  method         = token
]]></sourcecode>
            <t>
   The request methods defined by this specification can be found in
   Section 7 of <xref target="Semantics"/>, along with information regarding the HTTP method
   registry and considerations for defining new methods.
</t>
         </section>
         <section anchor="request.target" title="Request Target">
            <iref primary="true" item="request-target"/>
            <t>
   The request-target identifies the target resource upon which to apply the
   request. The client derives a request-target from its desired target URI.
   There are four distinct formats for the request-target, depending on both
   the method being requested and whether the request is to a proxy.
</t>
            <iref primary="true" item="Grammar" subitem="request-target"/>
            <iref primary="false" item="Grammar" subitem="origin-form"/>
            <iref primary="false" item="Grammar" subitem="absolute-form"/>
            <iref primary="false" item="Grammar" subitem="authority-form"/>
            <iref primary="false" item="Grammar" subitem="asterisk-form"/>
            <sourcecode type="abnf7230"><![CDATA[  request-target = origin-form
                 / absolute-form
                 / authority-form
                 / asterisk-form
]]></sourcecode>
            <t>
   No whitespace is allowed in the request-target.
   Unfortunately, some user agents fail to properly encode or exclude
   whitespace found in hypertext references, resulting in those disallowed
   characters being sent as the request-target in a malformed request-line.
</t>
            <t>
   Recipients of an invalid request-line <bcp14>SHOULD</bcp14> respond with either a
   400 (Bad Request) error or a 301 (Moved Permanently)
   redirect with the request-target properly encoded.  A recipient <bcp14>SHOULD NOT</bcp14>
   attempt to autocorrect and then process the request without a redirect,
   since the invalid request-line might be deliberately crafted to bypass
   security filters along the request chain.
</t>
            <section anchor="origin-form" title="origin-form">
               <iref item="origin-form (of request-target)"/>
               <t>
   The most common form of request-target is the origin-form.
</t>
               <iref primary="true" item="Grammar" subitem="origin-form"/>
               <sourcecode type="abnf7230"><![CDATA[  origin-form    = absolute-path [ "?" query ]
]]></sourcecode>
               <t>
   When making a request directly to an origin server, other than a CONNECT
   or server-wide OPTIONS request (as detailed below),
   a client <bcp14>MUST</bcp14> send only the absolute path and query components of
   the target URI as the request-target.
   If the target URI's path component is empty, the client <bcp14>MUST</bcp14> send
   "/" as the path within the origin-form of request-target.
   A Host header field is also sent, as defined in
   Section 5.4 of <xref target="Semantics"/>.
</t>
               <t>
   For example, a client wishing to retrieve a representation of the resource
   identified as
</t>
               <artwork type="example"><![CDATA[
  http://www.example.org/where?q=now
  ]]></artwork>
               <t>
   directly from the origin server would open (or reuse) a TCP connection
   to port 80 of the host "www.example.org" and send the lines:
</t>
               <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
  GET /where?q=now HTTP/1.1
  Host: www.example.org
  ]]></artwork>
               <t>
   followed by the remainder of the request message.
</t>
            </section>
            <section anchor="absolute-form" title="absolute-form">
               <iref item="absolute-form (of request-target)"/>
               <t>
   When making a request to a proxy, other than a CONNECT or server-wide
   OPTIONS request (as detailed below), a client <bcp14>MUST</bcp14> send the target URI
   in absolute-form as the request-target.
</t>
               <iref primary="true" item="Grammar" subitem="absolute-form"/>
               <sourcecode type="abnf7230"><![CDATA[  absolute-form  = absolute-URI
]]></sourcecode>
               <t>
   The proxy is requested to either service that request from a valid cache,
   if possible, or make the same request on the client's behalf to either
   the next inbound proxy server or directly to the origin server indicated
   by the request-target.  Requirements on such "forwarding" of messages are
   defined in Section 5.5 of <xref target="Semantics"/>.
</t>
               <t>
   An example absolute-form of request-line would be:
</t>
               <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
  GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
  ]]></artwork>
               <t>
   To allow for transition to the absolute-form for all requests in some
   future version of HTTP, a server <bcp14>MUST</bcp14> accept the absolute-form
   in requests, even though HTTP/1.1 clients will only send them in requests
   to proxies.
</t>
            </section>
            <section anchor="authority-form" title="authority-form">
               <iref item="authority-form (of request-target)"/>
               <t>
   The authority-form of request-target is only used for
   CONNECT requests (Section 7.3.6 of <xref target="Semantics"/>).
</t>
               <iref primary="true" item="Grammar" subitem="authority-form"/>
               <sourcecode type="abnf7230"><![CDATA[  authority-form = authority
]]></sourcecode>
               <t>
   When making a CONNECT request to establish a
   tunnel through one or more proxies, a client <bcp14>MUST</bcp14> send only the target
   URI's authority component (excluding any userinfo and its "@" delimiter) as
   the request-target. For example,
</t>
               <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
  CONNECT www.example.com:80 HTTP/1.1
  ]]></artwork>
            </section>
            <section anchor="asterisk-form" title="asterisk-form">
               <iref item="asterisk-form (of request-target)"/>
               <t>
   The asterisk-form of request-target is only used for a server-wide
   OPTIONS request (Section 7.3.7 of <xref target="Semantics"/>).
</t>
               <iref primary="true" item="Grammar" subitem="asterisk-form"/>
               <sourcecode type="abnf7230"><![CDATA[  asterisk-form  = "*"
]]></sourcecode>
               <t>
   When a client wishes to request OPTIONS
   for the server as a whole, as opposed to a specific named resource of
   that server, the client <bcp14>MUST</bcp14> send only "*" (%x2A) as the request-target.
   For example,
</t>
               <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
  OPTIONS * HTTP/1.1
  ]]></artwork>
               <t>
   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query component,
   then the last proxy on the request chain <bcp14>MUST</bcp14> send a request-target
   of "*" when it forwards the request to the indicated origin server.
</t>
               <t>
   For example, the request
</t>
               <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
  OPTIONS http://www.example.org:8001 HTTP/1.1
  ]]></artwork>
               <t>
  would be forwarded by the final proxy as
</t>
               <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
  OPTIONS * HTTP/1.1
  Host: www.example.org:8001
  ]]></artwork>
               <t>
   after connecting to port 8001 of host "www.example.org".
</t>
            </section>
         </section>
         <section anchor="h1.effective.request.uri" title="Effective Request URI">
            <iref primary="false" item="effective request URI"/>
            <t>
   Since the request-target often contains only part of the user agent's
   target URI, a server reconstructs the intended target as an
   effective request URI to properly service the request
   (Section 5.3 of <xref target="Semantics"/>).
</t>
            <t>
   If the <xref target="request.target" format="none">request-target</xref> is in <xref target="absolute-form" format="none">absolute-form</xref>,
   the effective request URI is the same as the request-target. Otherwise, the
   effective request URI is constructed as follows:
</t>
            <ul empty="true">
               <li>
   If the server's configuration (or outbound gateway) provides a fixed URI
   scheme, that scheme is used for the effective request URI.
   Otherwise, if the request is received over a TLS-secured TCP connection,
   the effective request URI's scheme is "https"; if not, the scheme is "http".
</li>
               <li>
   If the server's configuration (or outbound gateway) provides a fixed URI
   <xref target="imported.rules" format="none">authority</xref> component, that authority is used for the
   effective request URI. If not, then if the request-target is in
   <xref target="authority-form" format="none">authority-form</xref>, the effective request URI's authority
   component is the same as the request-target.
   If not, then if a Host header field is supplied with a
   non-empty field-value, the authority component is the same as the
   Host field-value. Otherwise, the authority component is assigned
   the default name configured for the server and, if the connection's
   incoming TCP port number differs from the default port for the effective
   request URI's scheme, then a colon (":") and the incoming port number (in
   decimal form) are appended to the authority component.
</li>
               <li>
   If the request-target is in <xref target="authority-form" format="none">authority-form</xref> or
   <xref target="asterisk-form" format="none">asterisk-form</xref>, the effective request URI's combined
   path and <xref target="imported.rules" format="none">query</xref> component is empty. Otherwise,
   the combined path and <xref target="imported.rules" format="none">query</xref> component is the
   same as the request-target.
</li>
               <li>
   The components of the effective request URI, once determined as above, can
   be combined into <xref target="imported.rules" format="none">absolute-URI</xref> form by concatenating the
   scheme, "://", authority, and combined path and query component.
</li>
            </ul>
            <t>
   Example 1: the following message received over an insecure TCP connection
</t>
            <artwork type="example"><![CDATA[
  GET /pub/WWW/TheProject.html HTTP/1.1
  Host: www.example.org:8080
  ]]></artwork>
            <t>
  has an effective request URI of
</t>
            <artwork type="example"><![CDATA[
  http://www.example.org:8080/pub/WWW/TheProject.html
  ]]></artwork>
            <t>
   Example 2: the following message received over a TLS-secured TCP connection
</t>
            <artwork type="example"><![CDATA[
  OPTIONS * HTTP/1.1
  Host: www.example.org
  ]]></artwork>
            <t>
  has an effective request URI of
</t>
            <artwork type="example"><![CDATA[
  https://www.example.org
  ]]></artwork>
            <t>
   Recipients of an HTTP/1.0 request that lacks a Host header
   field might need to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to guess the
   effective request URI's authority component.
</t>
         </section>
      </section>
      <section anchor="status.line" title="Status Line">
         <t>
   The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another space,
   and ending with an <bcp14>OPTIONAL</bcp14> textual phrase describing the status code.
</t>
         <iref primary="true" item="Grammar" subitem="status-line"/>
         <sourcecode type="abnf7230"><![CDATA[  status-line = HTTP-version SP status-code SP [reason-phrase]
]]></sourcecode>
         <t>
   Although the status-line grammar rule requires that each of the component
   elements be separated by a single SP octet, recipients <bcp14>MAY</bcp14> instead parse
   on whitespace-delimited word boundaries and, aside from the line
   terminator, treat any form of whitespace as the SP separator while
   ignoring preceding or trailing whitespace; such whitespace includes one or
   more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR.
   However, lenient parsing can result in response splitting security
   vulnerabilities if there are multiple recipients of the message and each
   has its own unique interpretation of robustness
   (see <xref target="response.splitting"/>).
</t>
         <t>
   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request. The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See Section 9 of <xref target="Semantics"/> for information about the semantics of status codes,
   including the classes of status code (indicated by the first digit),
   the status codes defined by this specification, considerations for the
   definition of new status codes, and the IANA registry.
</t>
         <iref primary="true" item="Grammar" subitem="status-code"/>
         <sourcecode type="abnf7230"><![CDATA[  status-code    = 3DIGIT
]]></sourcecode>
         <t>
   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly out of
   deference to earlier Internet application protocols that were more
   frequently used with interactive text clients.
</t>
         <iref primary="true" item="Grammar" subitem="reason-phrase"/>
         <sourcecode type="abnf7230"><![CDATA[  reason-phrase  = 1*( HTAB / SP / VCHAR / obs-text )
]]></sourcecode>
         <t>
   A client <bcp14>SHOULD</bcp14> ignore the reason-phrase content because it is not a
   reliable channel for information (it might be translated for a given locale,
   overwritten by intermediaries, or discarded when the message is forwarded
   via other versions of HTTP).
   A server <bcp14>MUST</bcp14> send the space that separates status-code from the
   reason-phrase even when the reason-phrase is absent (i.e., the status-line
   would end with the three octets SP CR LF).
</t>
      </section>
      <section anchor="header.fields" title="Header Fields">
         <t>
   Each header field consists of a case-insensitive field name
   followed by a colon (":"), optional leading whitespace, the field value,
   and optional trailing whitespace.
</t>
         <iref primary="true" item="Grammar" subitem="header-field"/>
         <iref primary="false" item="Grammar" subitem="field-name"/>
         <iref primary="false" item="Grammar" subitem="field-value"/>
         <sourcecode type="abnf7230"><![CDATA[  header-field   = field-name ":" OWS field-value OWS
]]></sourcecode>
         <t>
   Most HTTP field names and the rules for parsing within field values are
   defined in Section 4 of <xref target="Semantics"/>. This section covers the
   generic syntax for header field inclusion within, and extraction from,
   HTTP/1.1 messages. In addition, the following header fields are defined by
   this document because they are specific to HTTP/1.1 message processing:
</t><!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
         <table align="left" anchor="iana.header.registration.table">
            <thead>
               <tr>
                  <th>Header Field Name</th>
                  <th>Status</th>
                  <th>Reference</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td>Connection</td>
                  <td>standard</td>
                  <td>
            
                     <xref target="header.connection"/>
         
                  </td>
               </tr>
               <tr>
                  <td>MIME-Version</td>
                  <td>standard</td>
                  <td>
            
                     <xref target="mime-version"/>
         
                  </td>
               </tr>
               <tr>
                  <td>TE</td>
                  <td>standard</td>
                  <td>
            
                     <xref target="header.te"/>
         
                  </td>
               </tr>
               <tr>
                  <td>Transfer-Encoding</td>
                  <td>standard</td>
                  <td>
            
                     <xref target="header.transfer-encoding"/>
         
                  </td>
               </tr>
               <tr>
                  <td>Upgrade</td>
                  <td>standard</td>
                  <td>
            
                     <xref target="header.upgrade"/>
         
                  </td>
               </tr>
            </tbody>
         </table><!--(END)-->
         <t>
   Furthermore, the field name "Close" is reserved, since using that name as
   an HTTP header field might conflict with the "close" connection option of
   the <xref target="header.connection" format="none">Connection</xref> header field
   (<xref target="header.connection"/>).
</t>
         <table align="left">
            <thead>
               <tr>
                  <th>Header Field Name</th>
                  <th>Protocol</th>
                  <th>Status</th>
                  <th>Reference</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td>Close</td>
                  <td>http</td>
                  <td>reserved</td>
                  <td>
        
                     <xref target="header.fields"/>
      
                  </td>
               </tr>
            </tbody>
         </table>
         <section anchor="field.parsing" title="Header Field Parsing">
            <t>
   Messages are parsed using a generic algorithm, independent of the
   individual header field names. The contents within a given field value are
   not parsed until a later stage of message interpretation (usually after the
   message's entire header section has been processed).
</t>
            <t>
   No whitespace is allowed between the header field-name and colon.
   In the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.
   A server <bcp14>MUST</bcp14> reject any received request message that contains
   whitespace between a header field-name and colon with a response status code of
   400 (Bad Request). A proxy <bcp14>MUST</bcp14> remove any such whitespace
   from a response message before forwarding the message downstream.
</t>
            <t>
   A field value might be preceded and/or followed by optional whitespace
   (OWS); a single SP preceding the field-value is preferred for consistent
   readability by humans.
   The field value does not include any leading or trailing whitespace: OWS
   occurring before the first non-whitespace octet of the field value or after
   the last non-whitespace octet of the field value ought to be excluded by
   parsers when extracting the field value from a header field.
</t>
         </section>
         <section anchor="line.folding" title="Obsolete Line Folding">
            <t>
   Historically, HTTP header field values could be extended over multiple
   lines by preceding each extra line with at least one space or horizontal
   tab (obs-fold). This specification deprecates such line folding except
   within the message/http media type
   (<xref target="media.type.message.http"/>).
</t>
            <iref primary="true" item="Grammar" subitem="obs-fold"/>
            <sourcecode type="abnf7230"><![CDATA[  obs-fold     = OWS CRLF RWS
               ; obsolete line folding
]]></sourcecode>
            <t>
   A sender <bcp14>MUST NOT</bcp14> generate a message that includes line folding
   (i.e., that has any field-value that contains a match to the
   <xref target="line.folding" format="none">obs-fold</xref> rule) unless the message is intended for packaging
   within the message/http media type.
</t>
            <t>
   A server that receives an <xref target="line.folding" format="none">obs-fold</xref> in a request message that
   is not within a message/http container <bcp14>MUST</bcp14> either reject the message by
   sending a 400 (Bad Request), preferably with a
   representation explaining that obsolete line folding is unacceptable, or
   replace each received <xref target="line.folding" format="none">obs-fold</xref> with one or more
   <xref target="core.rules" format="none">SP</xref> octets prior to interpreting the field value or
   forwarding the message downstream.
</t>
            <t>
   A proxy or gateway that receives an <xref target="line.folding" format="none">obs-fold</xref> in a response
   message that is not within a message/http container <bcp14>MUST</bcp14> either discard
   the message and replace it with a 502 (Bad Gateway)
   response, preferably with a representation explaining that unacceptable
   line folding was received, or replace each received <xref target="line.folding" format="none">obs-fold</xref>
   with one or more <xref target="core.rules" format="none">SP</xref> octets prior to interpreting the field
   value or forwarding the message downstream.
</t>
            <t>
   A user agent that receives an <xref target="line.folding" format="none">obs-fold</xref> in a response message
   that is not within a message/http container <bcp14>MUST</bcp14> replace each received
   <xref target="line.folding" format="none">obs-fold</xref> with one or more <xref target="core.rules" format="none">SP</xref> octets prior to
   interpreting the field value.
</t>
         </section>
      </section>
      <section anchor="message.body" title="Message Body">
         <t>
   The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in <xref target="header.transfer-encoding"/>.
</t>
         <iref primary="true" item="Grammar" subitem="message-body"/>
         <sourcecode type="abnf7230"><![CDATA[  message-body = *OCTET
]]></sourcecode>
         <t>
   The rules for when a message body is allowed in a message differ for
   requests and responses.
</t>
         <t>
   The presence of a message body in a request is signaled by a
   <xref target="body.content-length" format="none">Content-Length</xref> or <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> header
   field. Request message framing is independent of method semantics,
   even if the method does not define any use for a message body.
</t>
         <t>
   The presence of a message body in a response depends on both
   the request method to which it is responding and the response
   status code (<xref target="status.line"/>).
   Responses to the HEAD request method (Section 7.3.2 of <xref target="Semantics"/>) never include a message body
   because the associated response header fields (e.g.,
   <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref>, <xref target="body.content-length" format="none">Content-Length</xref>, etc.),
   if present, indicate only what their values would have been if the request
   method had been GET (Section 7.3.1 of <xref target="Semantics"/>).
   2xx (Successful) responses to a CONNECT request method
   (Section 7.3.6 of <xref target="Semantics"/>) switch to tunnel mode instead of having a message body.
   All 1xx (Informational), 204 (No Content), and
   304 (Not Modified) responses do not include a message body.
   All other responses do include a message body, although the body
   might be of zero length.
</t>
         <section anchor="header.transfer-encoding" title="Transfer-Encoding">
            <iref primary="true" item="Transfer-Encoding header field"/>
            <iref item="chunked (Coding Format)"/>
            <t>
   The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been
   (or will be) applied to the payload body in order to form the message body.
   Transfer codings are defined in <xref target="transfer.codings"/>.
</t>
            <iref primary="true" item="Grammar" subitem="Transfer-Encoding"/>
            <sourcecode type="abnf7230"><![CDATA[  Transfer-Encoding = 1#transfer-coding
]]></sourcecode>
            <t>
   Transfer-Encoding is analogous to the Content-Transfer-Encoding field of
   MIME, which was designed to enable safe transport of binary data over a
   7-bit transport service (<xref target="RFC2045"/>, Section 6).
   However, safe transport has a different focus for an 8bit-clean transfer
   protocol. In HTTP's case, Transfer-Encoding is primarily intended to
   accurately delimit a dynamically generated payload and to distinguish
   payload encodings that are only applied for transport efficiency or
   security from those that are characteristics of the selected resource.
</t>
            <t>
   A recipient <bcp14>MUST</bcp14> be able to parse the chunked transfer coding
   (<xref target="chunked.encoding"/>) because it plays a crucial role in
   framing messages when the payload body size is not known in advance.
   A sender <bcp14>MUST NOT</bcp14> apply chunked more than once to a message body
   (i.e., chunking an already chunked message is not allowed).
   If any transfer coding other than chunked is applied to a request payload
   body, the sender <bcp14>MUST</bcp14> apply chunked as the final transfer coding to
   ensure that the message is properly framed.
   If any transfer coding other than chunked is applied to a response payload
   body, the sender <bcp14>MUST</bcp14> either apply chunked as the final transfer coding
   or terminate the message by closing the connection.
</t>
            <t>
   For example,
</t>
            <artwork type="example"><![CDATA[
  Transfer-Encoding: gzip, chunked
]]></artwork>
            <t>
   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.
</t>
            <t>
   Unlike Content-Encoding (Section 6.1.2 of <xref target="Semantics"/>),
   Transfer-Encoding is a property of the message, not of the representation, and
   any recipient along the request/response chain <bcp14>MAY</bcp14> decode the received
   transfer coding(s) or apply additional transfer coding(s) to the message
   body, assuming that corresponding changes are made to the Transfer-Encoding
   field-value. Additional information about the encoding parameters can be
   provided by other header fields not defined by this specification.
</t>
            <t>
   Transfer-Encoding <bcp14>MAY</bcp14> be sent in a response to a HEAD request or in a
   304 (Not Modified) response (Section 9.4.5 of <xref target="Semantics"/>) to a GET request,
   neither of which includes a message body,
   to indicate that the origin server would have applied a transfer coding
   to the message body if the request had been an unconditional GET.
   This indication is not required, however, because any recipient on
   the response chain (including the origin server) can remove transfer
   codings when they are not needed.
</t>
            <t>
   A server <bcp14>MUST NOT</bcp14> send a Transfer-Encoding header field in any response
   with a status code of
   1xx (Informational) or 204 (No Content).
   A server <bcp14>MUST NOT</bcp14> send a Transfer-Encoding header field in any
   2xx (Successful) response to a CONNECT request (Section 7.3.6 of <xref target="Semantics"/>).
</t>
            <t>
   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed that
   implementations advertising only HTTP/1.0 support will not understand
   how to process a transfer-encoded payload.
   A client <bcp14>MUST NOT</bcp14> send a request containing Transfer-Encoding unless it
   knows the server will handle HTTP/1.1 (or later) requests; such knowledge
   might be in the form of specific user configuration or by remembering the
   version of a prior received response.
   A server <bcp14>MUST NOT</bcp14> send a response containing Transfer-Encoding unless
   the corresponding request indicates HTTP/1.1 (or later).
</t>
            <t>
   A server that receives a request message with a transfer coding it does
   not understand <bcp14>SHOULD</bcp14> respond with 501 (Not Implemented).
</t>
         </section>
         <section anchor="body.content-length" title="Content-Length">
            <iref primary="false" item="Content-Length header field"/>
            <t>
   When a message does not have a <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> header
   field, a Content-Length header field can provide the anticipated size,
   as a decimal number of octets, for a potential payload body.
   For messages that do include a payload body, the Content-Length field-value
   provides the framing information necessary for determining where the body
   (and message) ends.  For messages that do not include a payload body, the
   Content-Length indicates the size of the selected representation
   (Section 6.2.4 of <xref target="Semantics"/>).
</t>
            <aside>
               <t>
   
                  <strong>Note:</strong> HTTP's use of Content-Length for message framing differs
   significantly from the same field's use in MIME, where it is an optional
   field used only within the "message/external-body" media-type.
  </t>
            </aside>
         </section>
         <section anchor="message.body.length" title="Message Body Length">
            <iref item="chunked (Coding Format)"/>
            <t>
   The length of a message body is determined by one of the following
   (in order of precedence):
</t>
            <ol>
               <li>
                  <t>
   Any response to a HEAD request and any response with a
   1xx (Informational), 204 (No Content), or
   304 (Not Modified) status code is always
   terminated by the first empty line after the header fields, regardless of
   the header fields present in the message, and thus cannot contain a
   message body.
  </t>
               </li>
               <li>
                  <t>
   Any 2xx (Successful) response to a CONNECT request implies that the
   connection will become a tunnel immediately after the empty line that
   concludes the header fields.  A client <bcp14>MUST</bcp14> ignore any
   <xref target="body.content-length" format="none">Content-Length</xref> or <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> header
   fields received in such a message.
  </t>
               </li>
               <li>
                  <t>
   If a <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> header field is present
   and the chunked transfer coding (<xref target="chunked.encoding"/>)
   is the final encoding, the message body length is determined by reading
   and decoding the chunked data until the transfer coding indicates the
   data is complete.
  </t>
  
                  <t>
   If a <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> header field is present in a
   response and the chunked transfer coding is not the final encoding, the
   message body length is determined by reading the connection until it is
   closed by the server.
   If a <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> header field is present in a request and the
   chunked transfer coding is not the final encoding, the message body
   length cannot be determined reliably; the server <bcp14>MUST</bcp14> respond with
   the 400 (Bad Request) status code and then close the connection.
  </t>
  
                  <t>
   If a message is received with both a <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref>
   and a <xref target="body.content-length" format="none">Content-Length</xref> header field, the Transfer-Encoding
   overrides the Content-Length. Such a message might indicate an attempt to
   perform request smuggling (<xref target="request.smuggling"/>) or
   response splitting (<xref target="response.splitting"/>) and ought to be
   handled as an error. A sender <bcp14>MUST</bcp14> remove the received Content-Length
   field prior to forwarding such a message downstream.
  </t>
               </li>
               <li>
                  <t>
   If a message is received without <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> and with
   either multiple <xref target="body.content-length" format="none">Content-Length</xref> header fields having
   differing field-values or a single Content-Length header field having an
   invalid value, then the message framing is invalid and
   the recipient <bcp14>MUST</bcp14> treat it as an unrecoverable error.
   If this is a request message, the server <bcp14>MUST</bcp14> respond with
   a 400 (Bad Request) status code and then close the connection.
   If this is a response message received by a proxy,
   the proxy <bcp14>MUST</bcp14> close the connection to the server, discard the received
   response, and send a 502 (Bad Gateway) response to the
   client.
   If this is a response message received by a user agent,
   the user agent <bcp14>MUST</bcp14> close the connection to the server and discard the
   received response.
  </t>
               </li>
               <li>
                  <t>
   If a valid <xref target="body.content-length" format="none">Content-Length</xref> header field is present without
   <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref>, its decimal value defines the
   expected message body length in octets.
   If the sender closes the connection or the recipient times out before the
   indicated number of octets are received, the recipient <bcp14>MUST</bcp14> consider
   the message to be incomplete and close the connection.
  </t>
               </li>
               <li>
                  <t>
   If this is a request message and none of the above are true, then the
   message body length is zero (no message body is present).
  </t>
               </li>
               <li>
                  <t>
   Otherwise, this is a response message without a declared message body
   length, so the message body length is determined by the number of octets
   received prior to the server closing the connection.
  </t>
               </li>
            </ol>
            <t>
   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially received message interrupted
   by network failure, a server <bcp14>SHOULD</bcp14> generate encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.
</t>
            <t>
   A server <bcp14>MAY</bcp14> reject a request that contains a message body but
   not a <xref target="body.content-length" format="none">Content-Length</xref> by responding with
   411 (Length Required).
</t>
            <t>
   Unless a transfer coding other than chunked has been applied,
   a client that sends a request containing a message body <bcp14>SHOULD</bcp14>
   use a valid <xref target="body.content-length" format="none">Content-Length</xref> header field if the message body
   length is known in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a 411 (Length Required)
   status code even though they understand the chunked transfer coding.  This
   is typically because such services are implemented via a gateway that
   requires a content-length in advance of being called and the server
   is unable or unwilling to buffer the entire request before processing.
</t>
            <t>
   A user agent that sends a request containing a message body <bcp14>MUST</bcp14> send a
   valid <xref target="body.content-length" format="none">Content-Length</xref> header field if it does not know the
   server will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version of a
   prior received response.
</t>
            <t>
   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user agent
   <bcp14>MAY</bcp14> discard the remaining data or attempt to determine if that data
   belongs as part of the prior response body, which might be the case if the
   prior message's Content-Length value is incorrect. A client <bcp14>MUST NOT</bcp14>
   process, cache, or forward such extra data as a separate response, since
   such behavior would be vulnerable to cache poisoning.
</t>
         </section>
      </section>
      <section anchor="transfer.codings" title="Transfer Codings">
         <t>
   Transfer coding names are used to indicate an encoding
   transformation that has been, can be, or might need to be applied to a
   payload body in order to ensure "safe transport" through the network.
   This differs from a content coding in that the transfer coding is a
   property of the message rather than a property of the representation
   that is being transferred.
</t>
         <iref primary="true" item="Grammar" subitem="transfer-coding"/>
         <sourcecode type="abnf7230"><![CDATA[  transfer-coding = token *( OWS ";" OWS transfer-parameter )
]]></sourcecode>
         <t anchor="rule.parameter">
  
   Parameters are in the form of a name=value pair.
</t>
         <iref primary="true" item="Grammar" subitem="transfer-parameter"/>
         <sourcecode type="abnf7230"><![CDATA[  transfer-parameter = token BWS "=" BWS ( token / quoted-string )
]]></sourcecode>
         <t>
   All transfer-coding names are case-insensitive and ought to be registered
   within the HTTP Transfer Coding registry, as defined in
   <xref target="transfer.coding.registry"/>.
   They are used in the <xref target="header.te" format="none">TE</xref> (<xref target="header.te"/>) and
   <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> (<xref target="header.transfer-encoding"/>)
   header fields.
</t>
         <table align="left" anchor="iana.transfer.coding.registration.table">
            <thead>
               <tr>
                  <th>Name</th>
                  <th>Description</th>
                  <th>Reference</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td>chunked</td>
                  <td>Transfer in a series of chunks</td>
                  <td>
                     <xref target="chunked.encoding"/>
                  </td>
               </tr>
               <tr>
                  <td>compress</td>
                  <td>UNIX "compress" data format <xref target="Welch"/>
                  </td>
                  <td>
                     <xref target="compression.codings"/>
                  </td>
               </tr>
               <tr>
                  <td>deflate</td>
                  <td>"deflate" compressed data (<xref target="RFC1951"/>) inside
      the "zlib" data format (<xref target="RFC1950"/>)</td>
                  <td>
                     <xref target="compression.codings"/>
                  </td>
               </tr>
               <tr>
                  <td>gzip</td>
                  <td>GZIP file format <xref target="RFC1952"/>
                  </td>
                  <td>
                     <xref target="compression.codings"/>
                  </td>
               </tr>
               <tr>
                  <td>trailers</td>
                  <td>(reserved)</td>
                  <td>
                     <xref target="transfer.codings"/>
                  </td>
               </tr>
               <tr>
                  <td>x-compress</td>
                  <td>Deprecated (alias for compress)</td>
                  <td>
                     <xref target="compression.codings"/>
                  </td>
               </tr>
               <tr>
                  <td>x-gzip</td>
                  <td>Deprecated (alias for gzip)</td>
                  <td>
                     <xref target="compression.codings"/>
                  </td>
               </tr>
            </tbody>
         </table>
         <aside>
            <t>
    
               <strong>Note:</strong> the coding name "trailers" is reserved because it would clash
    with the use of the keyword "trailers" in the <xref target="header.te" format="none">TE</xref>
    header field (<xref target="header.te"/>).
  </t>
         </aside>
         <section anchor="chunked.encoding" title="Chunked Transfer Coding">
            <iref primary="true" item="chunked (transfer coding)"/>
            <t>
   The chunked transfer coding wraps the payload body in order to transfer it
   as a series of chunks, each with its own size indicator, followed by an
   <bcp14>OPTIONAL</bcp14> trailer containing header fields. Chunked enables content
   streams of unknown size to be transferred as a sequence of length-delimited
   buffers, which enables the sender to retain connection persistence and the
   recipient to know when it has received the entire message.
</t>
            <iref primary="true" item="Grammar" subitem="chunked-body"><!--terminal production--></iref>
            <iref primary="true" item="Grammar" subitem="chunk"/>
            <iref primary="true" item="Grammar" subitem="chunk-size"/>
            <iref primary="true" item="Grammar" subitem="last-chunk"/>
            <iref primary="false" item="Grammar" subitem="trailer-part"/>
            <iref primary="false" item="Grammar" subitem="chunk-ext"/>
            <iref primary="true" item="Grammar" subitem="chunk-data"/>
            <sourcecode type="abnf7230"><![CDATA[  chunked-body   = *chunk
                   last-chunk
                   trailer-part
                   CRLF

  chunk          = chunk-size [ chunk-ext ] CRLF
                   chunk-data CRLF
  chunk-size     = 1*HEXDIG
  last-chunk     = 1*("0") [ chunk-ext ] CRLF

  chunk-data     = 1*OCTET ; a sequence of chunk-size octets
]]></sourcecode>
            <t>
   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets. The chunked transfer coding is complete when a
   chunk with a chunk-size of zero is received, possibly followed by a
   trailer, and finally terminated by an empty line.
</t>
            <t>
   A recipient <bcp14>MUST</bcp14> be able to parse and decode the chunked transfer coding.
</t>
            <t>
   The chunked encoding does not define any parameters. Their presence
   <bcp14>SHOULD</bcp14> be treated as an error.
</t>
            <section anchor="chunked.extension" title="Chunk Extensions">
               <t>
   The chunked encoding allows each chunk to include zero or more chunk
   extensions, immediately following the <xref target="chunked.encoding" format="none">chunk-size</xref>, for the
   sake of supplying per-chunk metadata (such as a signature or hash),
   mid-message control information, or randomization of message body size.
</t>
               <iref primary="true" item="Grammar" subitem="chunk-ext"/>
               <iref primary="true" item="Grammar" subitem="chunk-ext-name"/>
               <iref primary="true" item="Grammar" subitem="chunk-ext-val"/>
               <sourcecode type="abnf7230"><![CDATA[  chunk-ext      = *( BWS ";" BWS chunk-ext-name
                      [ BWS "=" BWS chunk-ext-val ] )

  chunk-ext-name = token
  chunk-ext-val  = token / quoted-string
]]></sourcecode>
               <t>
   The chunked encoding is specific to each connection and is likely to be
   removed or recoded by each recipient (including intermediaries) before any
   higher-level application would have a chance to inspect the extensions.
   Hence, use of chunk extensions is generally limited to specialized HTTP
   services such as "long polling" (where client and server can have shared
   expectations regarding the use of chunk extensions) or for padding within
   an end-to-end secured connection.
</t>
               <t>
   A recipient <bcp14>MUST</bcp14> ignore unrecognized chunk extensions.
   A server ought to limit the total length of chunk extensions received in a
   request to an amount reasonable for the services provided, in the same way
   that it applies length limitations and timeouts for other parts of a
   message, and generate an appropriate 4xx (Client Error)
   response if that amount is exceeded.
</t>
            </section>
            <section anchor="chunked.trailer.part" title="Chunked Trailer Part">
               <t>
   A trailer allows the sender to include additional fields at the end of a
   chunked message in order to supply metadata that might be dynamically
   generated while the message body is sent, such as a message integrity
   check, digital signature, or post-processing status. The trailer fields are
   identical to header fields, except they are sent in a chunked trailer
   instead of the message's header section.
</t>
               <iref primary="true" item="Grammar" subitem="trailer-part"/>
               <iref primary="false" item="Grammar" subitem="header-field"/>
               <sourcecode type="abnf7230"><![CDATA[  trailer-part   = *( header-field CRLF )
]]></sourcecode>
               <t>
   A sender <bcp14>MUST NOT</bcp14> generate a trailer that contains a field necessary for
   message framing (e.g., <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> and
   <xref target="body.content-length" format="none">Content-Length</xref>), routing (e.g., Host),
   request modifiers (e.g., controls and conditionals in
   Section 8 of <xref target="Semantics"/>), authentication (e.g., see Section 8.5 of <xref target="Semantics"/>
   and <xref target="RFC6265"/>), response control data (e.g., see
   Section 10.1 of <xref target="Semantics"/>), or determining how to process the payload
   (e.g., Content-Encoding, Content-Type,
   Content-Range, and Trailer).
</t>
               <t>
   When a chunked message containing a non-empty trailer is received, the
   recipient <bcp14>MAY</bcp14> process the fields (aside from those forbidden above)
   as if they were appended to the message's header section.
   A recipient <bcp14>MUST</bcp14> ignore (or consider as an error) any fields that are
   forbidden to be sent in a trailer, since processing them as if they were
   present in the header section might bypass external security filters.
</t>
               <t>
   Unless the request includes a <xref target="header.te" format="none">TE</xref> header field indicating
   "trailers" is acceptable, as described in <xref target="header.te"/>, a
   server <bcp14>SHOULD NOT</bcp14> generate trailer fields that it believes are necessary
   for the user agent to receive. Without a TE containing "trailers", the
   server ought to assume that the trailer fields might be silently discarded
   along the path to the user agent. This requirement allows intermediaries to
   forward a de-chunked message to an HTTP/1.0 recipient without buffering the
   entire response.
</t>
               <t>
   When a message includes a message body encoded with the chunked
   transfer coding and the sender desires to send metadata in the form of
   trailer fields at the end of the message, the sender <bcp14>SHOULD</bcp14> generate a
   Trailer header field before the message body to indicate
   which fields will be present in the trailers. This allows the
   recipient to prepare for receipt of that metadata before it starts
   processing the body, which is useful if the message is being streamed
   and the recipient wishes to confirm an integrity check on the fly.
</t>
            </section>
            <section anchor="decoding.chunked" title="Decoding Chunked">
               <t>
   A process for decoding the chunked transfer coding
   can be represented in pseudo-code as:
</t>
               <artwork type="code"><![CDATA[
  length := 0
  read chunk-size, chunk-ext (if any), and CRLF
  while (chunk-size > 0) {
     read chunk-data and CRLF
     append chunk-data to decoded-body
     length := length + chunk-size
     read chunk-size, chunk-ext (if any), and CRLF
  }
  read trailer field
  while (trailer field is not empty) {
     if (trailer field is allowed to be sent in a trailer) {
         append trailer field to existing header fields
     }
     read trailer-field
  }
  Content-Length := length
  Remove "chunked" from Transfer-Encoding
  Remove Trailer from existing header fields
]]></artwork>
            </section>
         </section>
         <section anchor="compression.codings" title="Transfer Codings for Compression">
            <iref primary="true" item="compress (transfer coding)"/>
            <iref primary="true" item="x-compress (transfer coding)"/>
            <iref primary="true" item="deflate (transfer coding)"/>
            <iref primary="true" item="gzip (transfer coding)"/>
            <iref primary="true" item="x-gzip (transfer coding)"/>
            <t>
   The following transfer coding names for compression are defined by
   the same algorithm as their corresponding content coding:
</t>
            <dl newline="true">
               <dt>compress (and x-compress)</dt>
               <dd>See Section 6.1.2.1 of <xref target="Semantics"/>.</dd>
               <dt>deflate</dt>
               <dd>See Section 6.1.2.2 of <xref target="Semantics"/>.</dd>
               <dt>gzip (and x-gzip)</dt>
               <dd>See Section 6.1.2.3 of <xref target="Semantics"/>.</dd>
            </dl>
            <t>
   The compression codings do not define any parameters. Their presence
   <bcp14>SHOULD</bcp14> be treated as an error.
</t>
         </section>
         <section anchor="transfer.coding.registry" title="Transfer Coding Registry">
            <t>
   The "HTTP Transfer Coding Registry" defines the namespace for transfer
   coding names. It is maintained at <eref target="https://www.iana.org/assignments/http-parameters"/>.
</t>
            <t>
   Registrations <bcp14>MUST</bcp14> include the following fields:
</t>
            <ul>
               <li>Name</li>
               <li>Description</li>
               <li>Pointer to specification text</li>
            </ul>
            <t>
   Names of transfer codings <bcp14>MUST NOT</bcp14> overlap with names of content codings
   (Section 6.1.2 of <xref target="Semantics"/>) unless the encoding transformation is identical, as
   is the case for the compression codings defined in
   <xref target="compression.codings"/>.
</t>
            <t>
   The <xref target="header.te" format="none">TE</xref> header field (<xref target="header.te"/>) uses a
   pseudo parameter named "q" as rank value when multiple transfer codings
   are acceptable. Future registrations of transfer codings <bcp14>SHOULD NOT</bcp14>
   define parameters called "q" (case-insensitively) in order to avoid
   ambiguities.
</t>
            <t>
   Values to be added to this namespace require IETF Review (see
   Section 4.8 of <xref target="RFC8126"/>), and <bcp14>MUST</bcp14>
   conform to the purpose of transfer coding defined in this specification.
</t>
            <t>
   Use of program names for the identification of encoding formats
   is not desirable and is discouraged for future encodings.
</t>
         </section>
         <section anchor="header.te" title="TE">
            <iref primary="true" item="TE header field"/>
            <t>
   The "TE" header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.
</t>
            <t>
   The TE field-value consists of a comma-separated list of transfer coding
   names, each allowing for optional parameters (as described in
   <xref target="transfer.codings"/>), and/or the keyword "trailers".
   A client <bcp14>MUST NOT</bcp14> send the chunked transfer coding name in TE;
   chunked is always acceptable for HTTP/1.1 recipients.
</t>
            <iref primary="true" item="Grammar" subitem="TE"/>
            <iref primary="true" item="Grammar" subitem="t-codings"/>
            <iref primary="true" item="Grammar" subitem="t-ranking"/>
            <iref primary="true" item="Grammar" subitem="rank"/>
            <sourcecode type="abnf7230"><![CDATA[  TE        = #t-codings
  t-codings = "trailers" / ( transfer-coding [ t-ranking ] )
  t-ranking = OWS ";" OWS "q=" rank
  rank      = ( "0" [ "." 0*3DIGIT ] )
             / ( "1" [ "." 0*3("0") ] )
]]></sourcecode>
            <t>
   Three examples of TE use are below.
</t>
            <artwork type="example"><![CDATA[
  TE: deflate
  TE:
  TE: trailers, deflate;q=0.5
]]></artwork>
            <t>
   The presence of the keyword "trailers" indicates that the client is willing
   to accept trailer fields in a chunked transfer coding, as defined in
   <xref target="chunked.trailer.part"/>, on behalf of itself and any downstream
   clients. For requests from an intermediary, this implies that either:
   (a) all downstream clients are willing to accept trailer fields in the
   forwarded response; or,
   (b) the intermediary will attempt to buffer the response on behalf of
   downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of buffering the
   entire response.
</t>
            <t>
   When multiple transfer codings are acceptable, the client <bcp14>MAY</bcp14> rank the
   codings by preference using a case-insensitive "q" parameter (similar to
   the qvalues used in content negotiation fields, Section 8.4.1 of <xref target="Semantics"/>). The rank value
   is a real number in the range 0 through 1, where 0.001 is the least
   preferred and 1 is the most preferred; a value of 0 means "not acceptable".
</t>
            <t>
   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked. A message with no transfer coding
   is always acceptable.
</t>
            <t>
   Since the TE header field only applies to the immediate connection,
   a sender of TE <bcp14>MUST</bcp14> also send a "TE" connection option within the
   <xref target="header.connection" format="none">Connection</xref> header field (<xref target="header.connection"/>)
   in order to prevent the TE field from being forwarded by intermediaries
   that do not support its semantics.
</t>
         </section>
      </section>
      <section anchor="incomplete.messages" title="Handling Incomplete Messages">
         <t>
   A server that receives an incomplete request message, usually due to a
   canceled request or a triggered timeout exception, <bcp14>MAY</bcp14> send an error
   response prior to closing the connection.
</t>
         <t>
   A client that receives an incomplete response message, which can occur
   when a connection is closed prematurely or when decoding a supposedly
   chunked transfer coding fails, <bcp14>MUST</bcp14> record the message as incomplete.
   Cache requirements for incomplete responses are defined in
   Section 3 of <xref target="Caching"/>.
</t>
         <t>
   If a response terminates in the middle of the header section (before the
   empty line is received) and the status code might rely on header fields to
   convey the full meaning of the response, then the client cannot assume
   that meaning has been conveyed; the client might need to repeat the
   request in order to determine what action to take next.
</t>
         <t>
   A message body that uses the chunked transfer coding is
   incomplete if the zero-sized chunk that terminates the encoding has not
   been received.  A message that uses a valid <xref target="body.content-length" format="none">Content-Length</xref> is
   incomplete if the size of the message body received (in octets) is less than
   the value given by Content-Length.  A response that has neither chunked
   transfer coding nor Content-Length is terminated by closure of the
   connection and, thus, is considered complete regardless of the number of
   message body octets received, provided that the header section was received
   intact.
</t>
      </section>
      <section anchor="connection.management" title="Connection Management">
         <t>
   HTTP messaging is independent of the underlying transport- or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.
</t>
         <t>
   As described in Section 5.2 of <xref target="Semantics"/>, the specific
   connection protocols to be used for an HTTP interaction are determined by
   client configuration and the target URI.
   For example, the "http" URI scheme
   (Section 2.5.1 of <xref target="Semantics"/>) indicates a default connection of TCP
   over IP, with a default TCP port of 80, but the client might be
   configured to use a proxy via some other connection, port, or protocol.
</t>
         <t>
   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections,
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.
   Most clients maintain multiple connections in parallel, including
   more than one connection per server endpoint.
   Most servers are designed to maintain thousands of concurrent connections,
   while controlling request queues to enable fair use and detect
   denial-of-service attacks.
</t>
         <section anchor="header.connection" title="Connection">
            <iref primary="true" item="Connection header field"/>
            <iref primary="true" item="close"/>
            <t>
   The "Connection" header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid confusing
   downstream recipients, a proxy or gateway <bcp14>MUST</bcp14> remove or replace any
   received connection options before forwarding the message.
</t>
            <t>
   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender <bcp14>MUST</bcp14> list
   the corresponding field-name within the Connection header field.
   A proxy or gateway <bcp14>MUST</bcp14> parse a received Connection
   header field before a message is forwarded and, for each
   connection-option in this field, remove any header field(s) from
   the message with the same name as the connection-option, and then
   remove the Connection header field itself (or replace it with the
   intermediary's own connection options for the forwarded message).
</t>
            <t>
   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the
   immediate recipient ("hop-by-hop") from those fields that are
   intended for all recipients on the chain ("end-to-end"), enabling the
   message to be self-descriptive and allowing future connection-specific
   extensions to be deployed without fear that they will be blindly
   forwarded by older intermediaries.
</t>
            <t>
   The Connection header field's value has the following grammar:
</t>
            <iref primary="true" item="Grammar" subitem="Connection"/>
            <iref primary="true" item="Grammar" subitem="connection-option"/>
            <sourcecode type="abnf7230"><![CDATA[  Connection        = 1#connection-option
  connection-option = token
]]></sourcecode>
            <t>
   Connection options are case-insensitive.
</t>
            <t>
   A sender <bcp14>MUST NOT</bcp14> send a connection option corresponding to a header
   field that is intended for all recipients of the payload.
   For example, Cache-Control is never appropriate as a
   connection option (Section 5.2 of <xref target="Caching"/>).
</t>
            <t>
   The connection options do not always correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with a
   connection option. In contrast, a connection-specific header field that
   is received without a corresponding connection option usually indicates
   that the field has been improperly forwarded by an intermediary and
   ought to be ignored by the recipient.
</t>
            <t>
   When defining new connection options, specification authors ought to survey
   existing header field names and ensure that the new connection option does
   not share the same name as an already deployed header field.
   Defining a new connection option essentially reserves that potential
   field-name for carrying additional information related to the
   connection option, since it would be unwise for senders to use
   that field-name for anything else.
</t>
            <t>
   The "close" connection option is defined for a
   sender to signal that this connection will be closed after completion of
   the response. For example,
</t>
            <artwork type="example"><![CDATA[
  Connection: close
]]></artwork>
            <t>
   in either the request or the response header fields indicates that the
   sender is going to close the connection after the current request/response
   is complete (<xref target="persistent.tear-down"/>).
</t>
            <t>
   A client that does not support <xref target="persistent.connections" format="none">persistent connections</xref> 
               <bcp14>MUST</bcp14>
   send the "close" connection option in every request message.
</t>
            <t>
   A server that does not support <xref target="persistent.connections" format="none">persistent connections</xref> 
               <bcp14>MUST</bcp14>
   send the "close" connection option in every response message that
   does not have a 1xx (Informational) status code.
</t>
         </section>
         <section anchor="persistent.establishment" title="Establishment">
            <t>
   It is beyond the scope of this specification to describe how connections
   are established via various transport- or session-layer protocols.
   Each connection applies to only one transport link.
</t>
         </section>
         <section anchor="associating.response.to.request" title="Associating a Response to a Request">
            <t>
   HTTP/1.1 does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond exactly
   to the order in which requests are made on the same connection.
   More than one response message per request only occurs when one or more
   informational responses (1xx, see Section 9.2 of <xref target="Semantics"/>) precede a
   final response to the same request.
</t>
            <t>
   A client that has more than one outstanding request on a connection <bcp14>MUST</bcp14>
   maintain a list of outstanding requests in the order sent and <bcp14>MUST</bcp14>
   associate each received response message on that connection to the highest
   ordered request that has not yet received a final (non-1xx)
   response.
</t>
            <t>
   If an HTTP/1.1 client receives data on a connection that doesn't have any
   outstanding requests, it <bcp14>MUST NOT</bcp14> consider them to be a response to a
   not-yet-issued request; it <bcp14>SHOULD</bcp14> close the connection, since message
   delimitation is now ambiguous, unless the data consists only of one or
   more CRLF (which can be discarded, as per <xref target="message.parsing"/>).
</t>
         </section>
         <section anchor="persistent.connections" title="Persistence">
            <t>
   HTTP/1.1 defaults to the use of "persistent connections",
   allowing multiple requests and responses to be carried over a single
   connection. The "<xref target="header.connection" format="none">close</xref>" connection option is used to signal
   that a connection will not persist after the current request/response.
   HTTP implementations <bcp14>SHOULD</bcp14> support persistent connections.
</t>
            <t>
   A recipient determines whether a connection is persistent or not based on
   the most recently received message's protocol version and
   <xref target="header.connection" format="none">Connection</xref> header field (if any):
</t>
            <ul>
               <li>If the "<xref target="header.connection" format="none">close</xref>" connection option is present, the
       connection will not persist after the current response; else,</li>
               <li>If the received protocol is HTTP/1.1 (or later), the connection will
       persist after the current response; else,</li>
               <li>If the received protocol is HTTP/1.0, the "keep-alive" connection
       option is present, either the recipient is not a proxy or the 
       message is a response, and the recipient wishes to honor the 
       HTTP/1.0 "keep-alive" mechanism, the connection will persist after
       the current response; otherwise,</li>
               <li>The connection will close after the current response.</li>
            </ul>
            <t>
   A client <bcp14>MAY</bcp14> send additional requests on a persistent connection until it
   sends or receives a "<xref target="header.connection" format="none">close</xref>" connection option or receives an
   HTTP/1.0 response without a "keep-alive" connection option.
</t>
            <t>
   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in <xref target="message.body"/>.
   A server <bcp14>MUST</bcp14> read the entire request message body or close
   the connection after sending its response, since otherwise the
   remaining data on a persistent connection would be misinterpreted
   as the next request.  Likewise,
   a client <bcp14>MUST</bcp14> read the entire response message body if it intends
   to reuse the same connection for a subsequent request.
</t>
            <t>
   A proxy server <bcp14>MUST NOT</bcp14> maintain a persistent connection with an
   HTTP/1.0 client (see Section 19.7.1 of <xref target="RFC2068"/> for
   information and discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).
</t>
            <t>
   See <xref target="compatibility.with.http.1.0.persistent.connections"/>
   for more information on backwards compatibility with HTTP/1.0 clients.
</t>
            <section anchor="persistent.retrying.requests" title="Retrying Requests">
               <t>
   Connections can be closed at any time, with or without intention.
   Implementations ought to anticipate the need to recover
   from asynchronous close events.
</t>
               <t>
   When an inbound connection is closed prematurely, a client <bcp14>MAY</bcp14> open a new
   connection and automatically retransmit an aborted sequence of requests if
   all of those requests have idempotent methods (Section 7.2.2 of <xref target="Semantics"/>).
</t>
            </section>
            <section anchor="pipelining" title="Pipelining">
               <t>
   A client that supports persistent connections <bcp14>MAY</bcp14> "pipeline"
   its requests (i.e., send multiple requests without waiting for each
   response). A server <bcp14>MAY</bcp14> process a sequence of pipelined requests in
   parallel if they all have safe methods (Section 7.2.1 of <xref target="Semantics"/>), but it <bcp14>MUST</bcp14> send
   the corresponding responses in the same order that the requests were
   received.
</t>
               <t>
   A client that pipelines requests <bcp14>SHOULD</bcp14> retry unanswered requests if the
   connection closes before it receives all of the corresponding responses.
   When retrying pipelined requests after a failed connection (a connection
   not explicitly closed by the server in its last complete response), a
   client <bcp14>MUST NOT</bcp14> pipeline immediately after connection establishment,
   since the first remaining request in the prior pipeline might have caused
   an error response that can be lost again if multiple requests are sent on a
   prematurely closed connection (see the TCP reset problem described in
   <xref target="persistent.tear-down"/>).
</t>
               <t>
   Idempotent methods (Section 7.2.2 of <xref target="Semantics"/>) are significant to pipelining
   because they can be automatically retried after a connection failure.
   A user agent <bcp14>SHOULD NOT</bcp14> pipeline requests after a non-idempotent method,
   until the final response status code for that method has been received,
   unless the user agent has a means to detect and recover from partial
   failure conditions involving the pipelined sequence.
</t>
               <t>
   An intermediary that receives pipelined requests <bcp14>MAY</bcp14> pipeline those
   requests when forwarding them inbound, since it can rely on the outbound
   user agent(s) to determine what requests can be safely pipelined. If the
   inbound connection fails before receiving a response, the pipelining
   intermediary <bcp14>MAY</bcp14> attempt to retry a sequence of requests that have yet
   to receive a response if the requests all have idempotent methods;
   otherwise, the pipelining intermediary <bcp14>SHOULD</bcp14> forward any received
   responses and then close the corresponding outbound connection(s) so that
   the outbound user agent(s) can recover accordingly.
</t>
            </section>
         </section>
         <section anchor="persistent.concurrency" title="Concurrency">
            <t>
   A client ought to limit the number of simultaneous open
   connections that it maintains to a given server.
</t>
            <t>
   Previous revisions of HTTP gave a specific number of connections as a
   ceiling, but this was found to be impractical for many applications. As a
   result, this specification does not mandate a particular maximum number of
   connections but, instead, encourages clients to be conservative when opening
   multiple connections.
</t>
            <t>
   Multiple connections are typically used to avoid the "head-of-line
   blocking" problem, wherein a request that takes significant server-side
   processing and/or has a large payload blocks subsequent requests on the
   same connection. However, each connection consumes server resources.
   Furthermore, using multiple connections can cause undesirable side effects
   in congested networks.
</t>
            <t>
   Note that a server might reject traffic that it deems abusive or
   characteristic of a denial-of-service attack, such as an excessive number
   of open connections from a single client.
</t>
         </section>
         <section anchor="persistent.failures" title="Failures and Timeouts">
            <t>
   Servers will usually have some timeout value beyond which they will
   no longer maintain an inactive connection. Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same proxy server. The use of persistent
   connections places no requirements on the length (or existence) of
   this timeout for either the client or the server.
</t>
            <t>
   A client or server that wishes to time out <bcp14>SHOULD</bcp14> issue a graceful close
   on the connection. Implementations <bcp14>SHOULD</bcp14> constantly monitor open
   connections for a received closure signal and respond to it as appropriate,
   since prompt closure of both sides of a connection enables allocated system
   resources to be reclaimed.
</t>
            <t>
   A client, server, or proxy <bcp14>MAY</bcp14> close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the "idle"
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.
</t>
            <t>
   A server <bcp14>SHOULD</bcp14> sustain persistent connections, when possible, and allow
   the underlying transport's flow-control mechanisms to resolve temporary overloads, rather
   than terminate connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.
</t>
            <t>
   A client sending a message body <bcp14>SHOULD</bcp14> monitor
   the network connection for an error response while it is transmitting
   the request. If the client sees a response that indicates the server does
   not wish to receive the message body and is closing the connection, the
   client <bcp14>SHOULD</bcp14> immediately cease transmitting the body and close its side
   of the connection.
</t>
         </section>
         <section anchor="persistent.tear-down" title="Tear-down">
            <iref primary="false" item="Connection header field"/>
            <iref primary="false" item="close"/>
            <t>
   The <xref target="header.connection" format="none">Connection</xref> header field
   (<xref target="header.connection"/>) provides a "<xref target="header.connection" format="none">close</xref>"
   connection option that a sender <bcp14>SHOULD</bcp14> send when it wishes to close
   the connection after the current request/response pair.
</t>
            <t>
   A client that sends a "<xref target="header.connection" format="none">close</xref>" connection option <bcp14>MUST NOT</bcp14>
   send further requests on that connection (after the one containing
   "close") and <bcp14>MUST</bcp14> close the connection after reading the
   final response message corresponding to this request.
</t>
            <t>
   A server that receives a "<xref target="header.connection" format="none">close</xref>" connection option <bcp14>MUST</bcp14>
   initiate a close of the connection (see below) after it sends the
   final response to the request that contained "close".
   The server <bcp14>SHOULD</bcp14> send a "close" connection option
   in its final response on that connection. The server <bcp14>MUST NOT</bcp14> process
   any further requests received on that connection.
</t>
            <t>
   A server that sends a "<xref target="header.connection" format="none">close</xref>" connection option <bcp14>MUST</bcp14>
   initiate a close of the connection (see below) after it sends the
   response containing "close". The server <bcp14>MUST NOT</bcp14> process
   any further requests received on that connection.
</t>
            <t>
   A client that receives a "<xref target="header.connection" format="none">close</xref>" connection option <bcp14>MUST</bcp14>
   cease sending requests on that connection and close the connection
   after reading the response message containing the "close"; if additional
   pipelined requests had been sent on the connection, the client <bcp14>SHOULD NOT</bcp14>
   assume that they will be processed by the server.
</t>
            <t>
   If a server performs an immediate close of a TCP connection, there is a
   significant risk that the client will not be able to read the last HTTP
   response.  If the server receives additional data from the client on a
   fully closed connection, such as another request that was sent by the
   client before receiving the server's response, the server's TCP stack will
   send a reset packet to the client; unfortunately, the reset packet might
   erase the client's unacknowledged input buffers before they can be read
   and interpreted by the client's HTTP parser.
</t>
            <t>
   To avoid the TCP reset problem, servers typically close a connection in
   stages. First, the server performs a half-close by closing only the write
   side of the read/write connection. The server then continues to read from
   the connection until it receives a corresponding close by the client, or
   until the server is reasonably certain that its own TCP stack has received
   the client's acknowledgement of the packet(s) containing the server's last
   response. Finally, the server fully closes the connection.
</t>
            <t>
   It is unknown whether the reset problem is exclusive to TCP or might also
   be found in other transport connection protocols.
</t>
         </section>
         <section anchor="header.upgrade" title="Upgrade">
            <iref primary="true" item="Upgrade header field"/>
            <t>
   The "Upgrade" header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.
</t>
            <t>
   A client <bcp14>MAY</bcp14> send a list of protocol names in the Upgrade header field
   of a request to invite the server to switch to one or more of the named
   protocols, in order of descending preference, before sending
   the final response. A server <bcp14>MAY</bcp14> ignore a received Upgrade header field
   if it wishes to continue using the current protocol on that connection.
   Upgrade cannot be used to insist on a protocol change.
</t>
            <iref primary="true" item="Grammar" subitem="Upgrade"/>
            <sourcecode type="abnf7230"><![CDATA[  Upgrade          = 1#protocol

  protocol         = protocol-name ["/" protocol-version]
  protocol-name    = token
  protocol-version = token
]]></sourcecode>
            <t>
   Although protocol names are registered with a preferred case,
   recipients <bcp14>SHOULD</bcp14> use case-insensitive comparison when matching each
   protocol-name to supported protocols.
</t>
            <t>
   A server that sends a 101 (Switching Protocols) response
   <bcp14>MUST</bcp14> send an Upgrade header field to indicate the new protocol(s) to
   which the connection is being switched; if multiple protocol layers are
   being switched, the sender <bcp14>MUST</bcp14> list the protocols in layer-ascending
   order. A server <bcp14>MUST NOT</bcp14> switch to a protocol that was not indicated by
   the client in the corresponding request's Upgrade header field.
   A server <bcp14>MAY</bcp14> choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as the
   nature of the request or the current load on the server.
</t>
            <t>
   A server that sends a 426 (Upgrade Required) response
   <bcp14>MUST</bcp14> send an Upgrade header field to indicate the acceptable protocols,
   in order of descending preference.
</t>
            <t>
   A server <bcp14>MAY</bcp14> send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed protocols,
   in order of descending preference, when appropriate for a future request.
</t>
            <t>
   The following is a hypothetical example sent by a client:
</t>
            <artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
  GET /hello.txt HTTP/1.1
  Host: www.example.com
  Connection: upgrade
  Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
  
  ]]></artwork>
            <t>
   The capabilities and nature of the
   application-level communication after the protocol change is entirely
   dependent upon the new protocol(s) chosen. However, immediately after
   sending the 101 (Switching Protocols) response, the server is expected to continue responding to
   the original request as if it had received its equivalent within the new
   protocol (i.e., the server still has an outstanding request to satisfy
   after the protocol has been changed, and is expected to do so without
   requiring the request to be repeated).
</t>
            <t>
   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds
   with a 101 (Switching Protocols) message in HTTP/1.1 and
   then immediately follows that with the new protocol's equivalent of a
   response to a GET on the target resource.  This allows a connection to be
   upgraded to protocols with the same semantics as HTTP without the
   latency cost of an additional round trip.  A server <bcp14>MUST NOT</bcp14> switch
   protocols unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol.
</t>
            <t>
   The following is an example response to the above hypothetical request:
</t>
            <artwork type="message/http; msgtype=&#34;response&#34;"><![CDATA[
  HTTP/1.1 101 Switching Protocols
  Connection: upgrade
  Upgrade: HTTP/2.0
  
  [... data stream switches to HTTP/2.0 with an appropriate response
  (as defined by new protocol) to the "GET /hello.txt" request ...]
  ]]></artwork>
            <t>
   When Upgrade is sent, the sender <bcp14>MUST</bcp14> also send a
   <xref target="header.connection" format="none">Connection</xref> header field (<xref target="header.connection"/>)
   that contains an "upgrade" connection option, in order to prevent Upgrade
   from being accidentally forwarded by intermediaries that might not implement
   the listed protocols.  A server <bcp14>MUST</bcp14> ignore an Upgrade header field that
   is received in an HTTP/1.0 request.
</t>
            <t>
   A client cannot begin using an upgraded protocol on the connection until
   it has completely sent the request message (i.e., the client can't change
   the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an Expect header field
   with the "100-continue" expectation (Section 8.1.1 of <xref target="Semantics"/>), the
   server <bcp14>MUST</bcp14> send a 100 (Continue) response before sending
   a 101 (Switching Protocols) response.
</t>
            <t>
   The Upgrade header field only applies to switching protocols on top of the
   existing connection; it cannot be used to switch the underlying connection
   (transport) protocol, nor to switch the existing communication to a
   different connection. For those purposes, it is more appropriate to use a
   3xx (Redirection) response (Section 9.4 of <xref target="Semantics"/>).
</t>
            <section anchor="upgrade.protocol.names" title="Upgrade Protocol Names">
               <t>
   This specification only defines the protocol name "HTTP" for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of Section 3.5 of <xref target="Semantics"/> and future updates to this
   specification. Additional protocol names ought to be registered using the
   registration procedure defined in <xref target="upgrade.token.registry"/>.
</t>
               <table align="left">
                  <thead>
                     <tr>
                        <th>Name</th>
                        <th>Description</th>
                        <th>Expected Version Tokens</th>
                        <th>Reference</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td>HTTP</td>
                        <td>Hypertext Transfer Protocol</td>
                        <td>any DIGIT.DIGIT (e.g, "2.0")</td>
                        <td>Section 3.5 of <xref target="Semantics"/>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </section>
            <section anchor="upgrade.token.registry" title="Upgrade Token Registry">
               <t>
   The "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" defines
   the namespace for protocol-name tokens used to identify protocols in the
   <xref target="header.upgrade" format="none">Upgrade</xref> header field. The registry is maintained at
   <eref target="https://www.iana.org/assignments/http-upgrade-tokens"/>.
</t>
               <t>
   Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.
</t>
               <t>
   Registrations happen on a "First Come First Served" basis (see
   Section 4.4 of <xref target="RFC8126"/>) and are subject to the
   following rules:
</t>
               <ol>
                  <li>A protocol-name token, once registered, stays registered forever.</li>
                  <li>A protocol-name token is case-insensitive and registered with the
       preferred case to be generated by senders.</li>
                  <li>The registration <bcp14>MUST</bcp14> name a responsible party for the
       registration.</li>
                  <li>The registration <bcp14>MUST</bcp14> name a point of contact.</li>
                  <li>The registration <bcp14>MAY</bcp14> name a set of specifications associated with
       that token. Such specifications need not be publicly available.</li>
                  <li>The registration <bcp14>SHOULD</bcp14> name a set of expected "protocol-version"
       tokens associated with that token at the time of registration.</li>
                  <li>The responsible party <bcp14>MAY</bcp14> change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.</li>
                  <li>The IESG <bcp14>MAY</bcp14> reassign responsibility for a protocol token.
       This will normally only be used in the case when a
       responsible party cannot be contacted.</li>
               </ol>
            </section>
         </section>
      </section>
      <section anchor="enclosing.messages" title="Enclosing Messages as Data">
         <section anchor="media.type.message.http" title="Media Type message/http">
            <iref item="Media Type" subitem="message/http" primary="true"/>
            <iref item="message/http Media Type" primary="true"/>
            <t>
   The message/http media type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for all
   "message" types regarding line length and encodings.
</t>
            <dl>
               <dt>Type name:</dt>
               <dd>message</dd>
               <dt>Subtype name:</dt>
               <dd>http</dd>
               <dt>Required parameters:</dt>
               <dd>N/A</dd>
               <dt>Optional parameters:</dt>
               <dd>
    
                  <t>version, msgtype</t>
    
                  <dl>
                     <dt>version:</dt>
                     <dd>
        The HTTP-version number of the enclosed message
        (e.g., "1.1"). If not present, the version can be
        determined from the first line of the body.
      </dd>
                     <dt>msgtype:</dt>
                     <dd>
        The message type — "request" or "response". If not
        present, the type can be determined from the first
        line of the body.
      </dd>
                  </dl>
  
               </dd>
               <dt>Encoding considerations:</dt>
               <dd>only "7bit", "8bit", or "binary" are permitted</dd>
               <dt>Security considerations:</dt>
               <dd>see <xref target="security.considerations"/>
               </dd>
               <dt>Interoperability considerations:</dt>
               <dd>N/A</dd>
               <dt>Published specification:</dt>
               <dd>This specification (see <xref target="media.type.message.http"/>).</dd>
               <dt>Applications that use this media type:</dt>
               <dd>N/A</dd>
               <dt>Fragment identifier considerations:</dt>
               <dd>N/A</dd>
               <dt>Additional information:</dt>
               <dd>
    
                  <dl>
                     <dt>Magic number(s):</dt>
                     <dd>N/A</dd>
                     <dt>Deprecated alias names for this type:</dt>
                     <dd>N/A</dd>
                     <dt>File extension(s):</dt>
                     <dd>N/A</dd>
                     <dt>Macintosh file type code(s):</dt>
                     <dd>N/A</dd>
                  </dl>
  
               </dd>
               <dt>Person and email address to contact for further information:</dt>
               <dd>See Authors' Addresses section.</dd>
               <dt>Intended usage:</dt>
               <dd>COMMON</dd>
               <dt>Restrictions on usage:</dt>
               <dd>N/A</dd>
               <dt>Author:</dt>
               <dd>See Authors' Addresses section.</dd>
               <dt>Change controller:</dt>
               <dd>IESG</dd>
            </dl>
         </section>
         <section anchor="media.type.application.http" title="Media Type application/http">
            <iref item="Media Type" subitem="application/http" primary="true"/>
            <iref item="application/http Media Type" primary="true"/>
            <t>
   The application/http media type can be used to enclose a pipeline of one or more
   HTTP request or response messages (not intermixed).
</t>
            <dl>
               <dt>Type name:</dt>
               <dd>application</dd>
               <dt>Subtype name:</dt>
               <dd>http</dd>
               <dt>Required parameters:</dt>
               <dd>N/A</dd>
               <dt>Optional parameters:</dt>
               <dd>
    
                  <t>
      version, msgtype
    </t>
    
                  <dl>
                     <dt>version:</dt>
                     <dd>
        The HTTP-version number of the enclosed messages
        (e.g., "1.1"). If not present, the version can be
        determined from the first line of the body.
      </dd>
                     <dt>msgtype:</dt>
                     <dd>
        The message type — "request" or "response". If not
        present, the type can be determined from the first
        line of the body.
      </dd>
                  </dl>
  
               </dd>
               <dt>Encoding considerations:</dt>
               <dd>
    HTTP messages enclosed by this type
    are in "binary" format; use of an appropriate
    Content-Transfer-Encoding is required when
    transmitted via email.
  </dd>
               <dt>Security considerations:</dt>
               <dd>
    see <xref target="security.considerations"/>
  
               </dd>
               <dt>Interoperability considerations:</dt>
               <dd>N/A</dd>
               <dt>Published specification:</dt>
               <dd>
    This specification (see <xref target="media.type.application.http"/>).
  </dd>
               <dt>Applications that use this media type:</dt>
               <dd>N/A</dd>
               <dt>Fragment identifier considerations:</dt>
               <dd>N/A</dd>
               <dt>Additional information:</dt>
               <dd>
    
                  <dl>
                     <dt>Deprecated alias names for this type:</dt>
                     <dd>N/A</dd>
                     <dt>Magic number(s):</dt>
                     <dd>N/A</dd>
                     <dt>File extension(s):</dt>
                     <dd>N/A</dd>
                     <dt>Macintosh file type code(s):</dt>
                     <dd>N/A</dd>
                  </dl>
  
               </dd>
               <dt>Person and email address to contact for further information:</dt>
               <dd>See Authors' Addresses section.</dd>
               <dt>Intended usage:</dt>
               <dd>COMMON</dd>
               <dt>Restrictions on usage:</dt>
               <dd>N/A</dd>
               <dt>Author:</dt>
               <dd>See Authors' Addresses section.</dd>
               <dt>Change controller:</dt>
               <dd>IESG</dd>
            </dl>
         </section>
      </section>
      <section anchor="security.considerations" title="Security Considerations">
         <t>
   This section is meant to inform developers, information providers, and
   users of known security considerations relevant to HTTP message syntax,
   parsing, and routing. Security considerations about HTTP semantics and
   payloads are addressed in <xref target="Semantics"/>.
</t>
         <section anchor="response.splitting" title="Response Splitting">
            <t>
   Response splitting (a.k.a, CRLF injection) is a common technique, used in
   various attacks on Web usage, that exploits the line-based nature of HTTP
   message framing and the ordered association of requests to responses on
   persistent connections <xref target="Klein"/>. This technique can be
   particularly damaging when the requests pass through a shared cache.
</t>
            <t>
   Response splitting exploits a vulnerability in servers (usually within an
   application server) where an attacker can send encoded data within some
   parameter of the request that is later decoded and echoed within any of the
   response header fields of the response. If the decoded data is crafted to
   look like the response has ended and a subsequent response has begun, the
   response has been split and the content within the apparent second response
   is controlled by the attacker. The attacker can then make any other request
   on the same persistent connection and trick the recipients (including
   intermediaries) into believing that the second half of the split is an
   authoritative answer to the second request.
</t>
            <t>
   For example, a parameter within the request-target might be read by an
   application server and reused within a redirect, resulting in the same
   parameter being echoed in the Location header field of the
   response. If the parameter is decoded by the application and not properly
   encoded when placed in the response field, the attacker can send encoded
   CRLF octets and other content that will make the application's single
   response look like two or more responses.
</t>
            <t>
   A common defense against response splitting is to filter requests for data
   that looks like encoded CR and LF (e.g., "%0D" and "%0A"). However, that
   assumes the application server is only performing URI decoding, rather
   than more obscure data transformations like charset transcoding, XML entity
   translation, base64 decoding, sprintf reformatting, etc.  A more effective
   mitigation is to prevent anything other than the server's core protocol
   libraries from sending a CR or LF within the header section, which means
   restricting the output of header fields to APIs that filter for bad octets
   and not allowing application servers to write directly to the protocol
   stream.
</t>
         </section>
         <section anchor="request.smuggling" title="Request Smuggling">
            <t>
   Request smuggling (<xref target="Linhart"/>) is a technique that exploits
   differences in protocol parsing among various recipients to hide additional
   requests (which might otherwise be blocked or disabled by policy) within an
   apparently harmless request.  Like response splitting, request smuggling
   can lead to a variety of attacks on HTTP usage.
</t>
            <t>
   This specification has introduced new requirements on request parsing,
   particularly with regard to message framing in
   <xref target="message.body.length"/>, to reduce the effectiveness of
   request smuggling.
</t>
         </section>
         <section anchor="message.integrity" title="Message Integrity">
            <t>
   HTTP does not define a specific mechanism for ensuring message integrity,
   instead relying on the error-detection ability of underlying transport
   protocols and the use of length or chunk-delimited framing to detect
   completeness. Additional integrity mechanisms, such as hash functions or
   digital signatures applied to the content, can be selectively added to
   messages via extensible metadata header fields. Historically, the lack of
   a single integrity mechanism has been justified by the informal nature of
   most HTTP communication.  However, the prevalence of HTTP as an information
   access mechanism has resulted in its increasing use within environments
   where verification of message integrity is crucial.
</t>
            <t>
   User agents are encouraged to implement configurable means for detecting
   and reporting failures of message integrity such that those means can be
   enabled within environments for which integrity is necessary. For example,
   a browser being used to view medical history or drug interaction
   information needs to indicate to the user when such information is detected
   by the protocol to be incomplete, expired, or corrupted during transfer.
   Such mechanisms might be selectively enabled via user agent extensions or
   the presence of message integrity metadata in a response.
   At a minimum, user agents ought to provide some indication that allows a
   user to distinguish between a complete and incomplete response message
   (<xref target="incomplete.messages"/>) when such verification is desired.
</t>
         </section>
         <section anchor="message.confidentiality" title="Message Confidentiality">
            <t>
   HTTP relies on underlying transport protocols to provide message
   confidentiality when that is desired. HTTP has been specifically designed
   to be independent of the transport protocol, such that it can be used
   over many different forms of encrypted connection, with the selection of
   such transports being identified by the choice of URI scheme or within
   user agent configuration.
</t>
            <t>
   The "https" scheme can be used to identify resources that require a
   confidential connection, as described in Section 2.5.2 of <xref target="Semantics"/>.
</t>
         </section>
      </section>
      <section anchor="IANA.considerations" title="IANA Considerations">
         <t>
   The change controller for the following registrations is:
   "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
         <section anchor="header.field.registration" title="Header Field Registration">
            <t>
   Please update the "Hypertext Transfer Protocol (HTTP) Header Field
   Registry" registry at <eref target="https://www.iana.org/assignments/http-headers"/> with the
   header field names listed in the two tables of <xref target="header.fields"/>.
</t>
         </section>
         <section anchor="media.type.http" title="Media Type Registration">
            <t>
   Please update the "Media Types" registry at
   <eref target="https://www.iana.org/assignments/media-types"/>
   with the registration information in
   <xref target="media.type.message.http"/> and
   <xref target="media.type.application.http"/> for the media types
   "message/http" and "application/http", respectively.
</t>
         </section>
         <section anchor="transfer.coding.registration" title="Transfer Coding Registration">
            <t>
   Please update the "HTTP Transfer Coding Registry" at
   <eref target="https://www.iana.org/assignments/http-parameters/"/>
   with the registration procedure of <xref target="transfer.coding.registry"/>
   and the content coding names summarized in the table of
   <xref target="transfer.codings"/>.
</t>
         </section>
         <section anchor="upgrade.token.registration" title="Upgrade Token Registration">
            <t>
   Please update the
   "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" at
   <eref target="https://www.iana.org/assignments/http-upgrade-tokens"/>
   with the registration procedure of <xref target="upgrade.token.registry"/>
   and the upgrade token names summarized in the table of
   <xref target="upgrade.protocol.names"/>.
</t>
         </section>
      </section>
   </middle>
   <back>
      <references title="Normative References">
         <reference anchor="Semantics"><!--included from draft-ietf-httpbis-semantics-latest.xml-->
            <front>
               <title>HTTP Semantics</title>
               <author fullname="Roy T. Fielding" initials="R." surname="Fielding" role="editor">
                  <organization>Adobe</organization>
                  <address>
                     <postal>
                        <street>345 Park Ave</street>
                        <city>San Jose</city>
                        <region>CA</region>
                        <code>95110</code>
                        <country>USA</country>
                     </postal>
                     <email>fielding@gbiv.com</email>
                     <uri>https://roy.gbiv.com/</uri>
                  </address>
               </author>
               <author fullname="Mark Nottingham" initials="M." surname="Nottingham" role="editor">
                  <organization>Fastly</organization>
                  <address>
                     <email>mnot@mnot.net</email>
                     <uri>https://www.mnot.net/</uri>
                  </address>
               </author>
               <author fullname="Julian F. Reschke" initials="J. F." surname="Reschke" role="editor">
                  <organization abbrev="greenbytes">greenbytes GmbH</organization>
                  <address>
                     <postal>
                        <street>Hafenweg 16</street>
                        <city>Muenster</city>
                        <region>NW</region>
                        <code>48155</code>
                        <country>Germany</country>
                     </postal>
                     <email>julian.reschke@greenbytes.de</email>
                     <uri>https://greenbytes.de/tech/webdav/</uri>
                  </address>
               </author>
               <date year="2019" month="August"/>
            </front>
            <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-semantics-latest"/>
         </reference>
         <reference anchor="Caching"><!--included from draft-ietf-httpbis-cache-latest.xml-->
            <front>
               <title>HTTP Caching</title>
               <author fullname="Roy T. Fielding" initials="R." surname="Fielding" role="editor">
                  <organization>Adobe</organization>
                  <address>
                     <postal>
                        <street>345 Park Ave</street>
                        <city>San Jose</city>
                        <region>CA</region>
                        <code>95110</code>
                        <country>USA</country>
                     </postal>
                     <email>fielding@gbiv.com</email>
                     <uri>https://roy.gbiv.com/</uri>
                  </address>
               </author>
               <author fullname="Mark Nottingham" initials="M." surname="Nottingham" role="editor">
                  <organization>Fastly</organization>
                  <address>
                     <email>mnot@mnot.net</email>
                     <uri>https://www.mnot.net/</uri>
                  </address>
               </author>
               <author fullname="Julian F. Reschke" initials="J. F." surname="Reschke" role="editor">
                  <organization abbrev="greenbytes">greenbytes GmbH</organization>
                  <address>
                     <postal>
                        <street>Hafenweg 16</street>
                        <city>Muenster</city>
                        <region>NW</region>
                        <code>48155</code>
                        <country>Germany</country>
                     </postal>
                     <email>julian.reschke@greenbytes.de</email>
                     <uri>https://greenbytes.de/tech/webdav/</uri>
                  </address>
               </author>
               <date year="2019" month="August"/>
            </front>
            <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-cache-latest"/>
         </reference>
         <reference anchor="RFC3986" target="https://www.rfc-editor.org/info/rfc3986">
            <front>
               <title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic Syntax</title>
               <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
                  <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
                  <address>
                     <email>timbl@w3.org</email>
                     <uri>http://www.w3.org/People/Berners-Lee/</uri>
                  </address>
               </author>
               <author initials="R." surname="Fielding" fullname="Roy T. Fielding">
                  <organization abbrev="Day Software">Day Software</organization>
                  <address>
                     <email>fielding@gbiv.com</email>
                     <uri>http://roy.gbiv.com/</uri>
                  </address>
               </author>
               <author initials="L." surname="Masinter" fullname="Larry Masinter">
                  <organization>Adobe</organization>
                  <address>
                     <email>LMM@acm.org</email>
                     <uri>http://larry.masinter.net/</uri>
                  </address>
               </author>
               <date month="January" year="2005"/>
            </front>
            <seriesInfo name="STD" value="66"/>
            <seriesInfo name="RFC" value="3986"/>
            <seriesInfo name="DOI" value="10.17487/RFC3986"/>
         </reference>
         <reference anchor="RFC5234" target="https://www.rfc-editor.org/info/rfc5234">
            <front>
               <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
               <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
                  <organization>Brandenburg InternetWorking</organization>
                  <address>
                     <email>dcrocker@bbiw.net</email>
                  </address>
               </author>
               <author initials="P." surname="Overell" fullname="Paul Overell">
                  <organization>THUS plc.</organization>
                  <address>
                     <email>paul.overell@thus.net</email>
                  </address>
               </author>
               <date month="January" year="2008"/>
            </front>
            <seriesInfo name="STD" value="68"/>
            <seriesInfo name="RFC" value="5234"/>
            <seriesInfo name="DOI" value="10.17487/RFC5234"/>
         </reference>
         <reference anchor="RFC7405" target="https://www.rfc-editor.org/info/rfc7405">
            <front>
               <title>Case-Sensitive String Support in ABNF</title>
               <author initials="P." surname="Kyzivat" fullname="Dave Kyzivat">
                  <address>
                     <email>pkyzivat@alum.mit.edu</email>
                  </address>
               </author>
               <date month="December" year="2014"/>
            </front>
            <seriesInfo name="RFC" value="7405"/>
            <seriesInfo name="DOI" value="10.17487/RFC7405"/>
         </reference>
         <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
            <front>
               <title>Key words for use in RFCs to Indicate Requirement Levels</title>
               <author initials="S." surname="Bradner" fullname="Scott Bradner">
                  <organization>Harvard University</organization>
                  <address>
                     <email>sob@harvard.edu</email>
                  </address>
               </author>
               <date month="March" year="1997"/>
            </front>
            <seriesInfo name="BCP" value="14"/>
            <seriesInfo name="RFC" value="2119"/>
            <seriesInfo name="DOI" value="10.17487/RFC2119"/>
         </reference>
         <reference anchor="USASCII">
            <front>
               <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
               <author>
                  <organization>American National Standards Institute</organization>
               </author>
               <date year="1986"/>
            </front>
            <seriesInfo name="ANSI" value="X3.4"/>
         </reference>
         <reference anchor="RFC1950" target="https://www.rfc-editor.org/info/rfc1950">
            <front>
               <title>ZLIB Compressed Data Format Specification version 3.3</title>
               <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
                  <organization>Aladdin Enterprises</organization>
                  <address>
                     <email>ghost@aladdin.com</email>
                  </address>
               </author>
               <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly"/>
               <date month="May" year="1996"/>
            </front>
            <seriesInfo name="RFC" value="1950"/>
            <seriesInfo name="DOI" value="10.17487/RFC1950"/>
         </reference>
         <reference anchor="RFC1951" target="https://www.rfc-editor.org/info/rfc1951">
            <front>
               <title>DEFLATE Compressed Data Format Specification version 1.3</title>
               <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
                  <organization>Aladdin Enterprises</organization>
                  <address>
                     <email>ghost@aladdin.com</email>
                  </address>
               </author>
               <date month="May" year="1996"/>
            </front>
            <seriesInfo name="RFC" value="1951"/>
            <seriesInfo name="DOI" value="10.17487/RFC1951"/>
         </reference>
         <reference anchor="RFC1952" target="https://www.rfc-editor.org/info/rfc1952">
            <front>
               <title>GZIP file format specification version 4.3</title>
               <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
                  <organization>Aladdin Enterprises</organization>
                  <address>
                     <email>ghost@aladdin.com</email>
                  </address>
               </author>
               <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly">
                  <address>
                     <email>gzip@prep.ai.mit.edu</email>
                  </address>
               </author>
               <author initials="M." surname="Adler" fullname="Mark Adler">
                  <address>
                     <email>madler@alumni.caltech.edu</email>
                  </address>
               </author>
               <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
                  <address>
                     <email>ghost@aladdin.com</email>
                  </address>
               </author>
               <author initials="G." surname="Randers-Pehrson" fullname="Glenn Randers-Pehrson">
                  <address>
                     <email>randeg@alumni.rpi.edu</email>
                  </address>
               </author>
               <date month="May" year="1996"/>
            </front>
            <seriesInfo name="RFC" value="1952"/>
            <seriesInfo name="DOI" value="10.17487/RFC1952"/>
         </reference>
         <reference anchor="Welch">
            <front>
               <title>A Technique for High-Performance Data Compression</title>
               <author initials="T. A." surname="Welch" fullname="Terry A. Welch"/>
               <date month="June" year="1984"/>
            </front>
            <seriesInfo name="IEEE Computer" value="17(6)"/>
         </reference>
      </references>
      <references title="Informative References">
         <reference anchor="RFC1945" target="https://www.rfc-editor.org/info/rfc1945">
            <front>
               <title abbrev="HTTP/1.0">Hypertext Transfer Protocol -- HTTP/1.0</title>
               <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
                  <organization>MIT, Laboratory for Computer Science</organization>
                  <address>
                     <email>timbl@w3.org</email>
                  </address>
               </author>
               <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
                  <organization>University of California, Irvine, Department of Information and Computer Science</organization>
                  <address>
                     <email>fielding@ics.uci.edu</email>
                  </address>
               </author>
               <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
                  <organization>W3 Consortium, MIT Laboratory for Computer Science</organization>
                  <address>
                     <email>frystyk@w3.org</email>
                  </address>
               </author>
               <date month="May" year="1996"/>
            </front>
            <seriesInfo name="RFC" value="1945"/>
            <seriesInfo name="DOI" value="10.17487/RFC1945"/>
         </reference>
         <reference anchor="RFC2045" target="https://www.rfc-editor.org/info/rfc2045">
            <front>
               <title abbrev="Internet Message Bodies">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
               <author initials="N." surname="Freed" fullname="Ned Freed">
                  <organization>Innosoft International, Inc.</organization>
                  <address>
                     <email>ned@innosoft.com</email>
                  </address>
               </author>
               <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
                  <organization>First Virtual Holdings</organization>
                  <address>
                     <email>nsb@nsb.fv.com</email>
                  </address>
               </author>
               <date month="November" year="1996"/>
            </front>
            <seriesInfo name="RFC" value="2045"/>
            <seriesInfo name="DOI" value="10.17487/RFC2045"/>
         </reference>
         <reference anchor="RFC2046" target="https://www.rfc-editor.org/info/rfc2046">
            <front>
               <title abbrev="Media Types">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</title>
               <author initials="N." surname="Freed" fullname="Ned Freed">
                  <organization>Innosoft International, Inc.</organization>
                  <address>
                     <email>ned@innosoft.com</email>
                  </address>
               </author>
               <author initials="N." surname="Borenstein" fullname="Nathaniel S. Borenstein">
                  <organization>First Virtual Holdings</organization>
                  <address>
                     <email>nsb@nsb.fv.com</email>
                  </address>
               </author>
               <date month="November" year="1996"/>
            </front>
            <seriesInfo name="RFC" value="2046"/>
            <seriesInfo name="DOI" value="10.17487/RFC2046"/>
         </reference>
         <reference anchor="RFC2049" target="https://www.rfc-editor.org/info/rfc2049">
            <front>
               <title abbrev="MIME Conformance">Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples</title>
               <author initials="N." surname="Freed" fullname="Ned Freed">
                  <organization>Innosoft International, Inc.</organization>
                  <address>
                     <email>ned@innosoft.com</email>
                  </address>
               </author>
               <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
                  <organization>First Virtual Holdings</organization>
                  <address>
                     <email>nsb@nsb.fv.com</email>
                  </address>
               </author>
               <date month="November" year="1996"/>
            </front>
            <seriesInfo name="RFC" value="2049"/>
            <seriesInfo name="DOI" value="10.17487/RFC2049"/>
         </reference>
         <reference anchor="RFC2068" target="https://www.rfc-editor.org/info/rfc2068">
            <front>
               <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
               <author initials="R." surname="Fielding" fullname="Roy T. Fielding">
                  <organization>University of California, Irvine, Department of Information and Computer Science</organization>
                  <address>
                     <email>fielding@ics.uci.edu</email>
                  </address>
               </author>
               <author initials="J." surname="Gettys" fullname="Jim Gettys">
                  <organization>MIT Laboratory for Computer Science</organization>
                  <address>
                     <email>jg@w3.org</email>
                  </address>
               </author>
               <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
                  <organization>Digital Equipment Corporation, Western Research Laboratory</organization>
                  <address>
                     <email>mogul@wrl.dec.com</email>
                  </address>
               </author>
               <author initials="H." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
                  <organization>MIT Laboratory for Computer Science</organization>
                  <address>
                     <email>frystyk@w3.org</email>
                  </address>
               </author>
               <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
                  <organization>MIT Laboratory for Computer Science</organization>
                  <address>
                     <email>timbl@w3.org</email>
                  </address>
               </author>
               <date month="January" year="1997"/>
            </front>
            <seriesInfo name="RFC" value="2068"/>
            <seriesInfo name="DOI" value="10.17487/RFC2068"/>
         </reference>
         <reference anchor="RFC2557" target="https://www.rfc-editor.org/info/rfc2557">
            <front>
               <title abbrev="MIME Encapsulation of Aggregate Documents">MIME Encapsulation of Aggregate Documents, such as HTML (MHTML)</title>
               <author initials="F." surname="Palme" fullname="Jacob Palme">
                  <organization>Stockholm University and KTH</organization>
                  <address>
                     <email>jpalme@dsv.su.se</email>
                  </address>
               </author>
               <author initials="A." surname="Hopmann" fullname="Alex Hopmann">
                  <organization>Microsoft Corporation</organization>
                  <address>
                     <email>alexhop@microsoft.com</email>
                  </address>
               </author>
               <author initials="N." surname="Shelness" fullname="Nick Shelness">
                  <organization>Lotus Development Corporation</organization>
                  <address>
                     <email>Shelness@lotus.com</email>
                  </address>
               </author>
               <author initials="E." surname="Stefferud" fullname="Einar Stefferud">
                  <address>
                     <email>stef@nma.com</email>
                  </address>
               </author>
               <date year="1999" month="March"/>
            </front>
            <seriesInfo name="RFC" value="2557"/>
            <seriesInfo name="DOI" value="10.17487/RFC2557"/>
         </reference>
         <reference anchor="RFC5322" target="https://www.rfc-editor.org/info/rfc5322">
            <front>
               <title>Internet Message Format</title>
               <author initials="P." surname="Resnick" fullname="P. Resnick">
                  <organization>Qualcomm Incorporated</organization>
               </author>
               <date year="2008" month="October"/>
            </front>
            <seriesInfo name="RFC" value="5322"/>
            <seriesInfo name="DOI" value="10.17487/RFC5322"/>
         </reference>
         <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265">
            <front>
               <title>HTTP State Management Mechanism</title>
               <author initials="A." surname="Barth" fullname="Adam Barth">
                  <organization abbrev="U.C. Berkeley">
        University of California, Berkeley
      </organization>
                  <address>
                     <email>abarth@eecs.berkeley.edu</email>
                  </address>
               </author>
               <date year="2011" month="April"/>
            </front>
            <seriesInfo name="RFC" value="6265"/>
            <seriesInfo name="DOI" value="10.17487/RFC6265"/>
         </reference>
         <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230">
            <front>
               <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
               <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
                  <organization>Adobe</organization>
                  <address>
                     <email>fielding@gbiv.com</email>
                  </address>
               </author>
               <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
                  <organization abbrev="greenbytes">greenbytes GmbH</organization>
                  <address>
                     <email>julian.reschke@greenbytes.de</email>
                  </address>
               </author>
               <date month="June" year="2014"/>
            </front>
            <seriesInfo name="RFC" value="7230"/>
            <seriesInfo name="DOI" value="10.17487/RFC7230"/>
         </reference>
         <reference anchor="RFC7231" target="https://www.rfc-editor.org/info/rfc7231">
            <front>
               <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
               <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
                  <organization>Adobe</organization>
                  <address>
                     <email>fielding@gbiv.com</email>
                  </address>
               </author>
               <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
                  <organization abbrev="greenbytes">greenbytes GmbH</organization>
                  <address>
                     <email>julian.reschke@greenbytes.de</email>
                  </address>
               </author>
               <date month="June" year="2014"/>
            </front>
            <seriesInfo name="RFC" value="7231"/>
            <seriesInfo name="DOI" value="10.17487/RFC7231"/>
         </reference>
         <reference anchor="RFC8126" target="https://www.rfc-editor.org/info/rfc8126">
            <front>
               <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
               <author initials="M." surname="Cotton" fullname="M. Cotton"/>
               <author initials="B." surname="Leiba" fullname="B. Leiba"/>
               <author initials="T." surname="Narten" fullname="T. Narten"/>
               <date year="2017" month="June"/>
            </front>
            <seriesInfo name="BCP" value="26"/>
            <seriesInfo name="RFC" value="8126"/>
            <seriesInfo name="DOI" value="10.17487/RFC8126"/>
         </reference><!--<reference anchor='BCP97'>
  <front>
    <title>Handling Normative References to Standards-Track Documents</title>
    <author initials='J.' surname='Klensin' fullname='J. Klensin'>
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <author initials='S.' surname='Hartman' fullname='S. Hartman'>
      <organization>MIT</organization>
      <address>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>
    <date year='2007' month='June' />
  </front>
  <seriesInfo name='BCP' value='97' />
  <seriesInfo name='RFC' value='4897' />
</reference>-->
         <reference anchor="Klein" target="http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf">
            <front>
               <title>Divide and Conquer - HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</title>
               <author initials="A." surname="Klein" fullname="Amit Klein">
                  <organization>Sanctum, Inc.</organization>
               </author>
               <date year="2004" month="March"/>
            </front>
         </reference>
         <reference anchor="Linhart" target="http://www.watchfire.com/news/whitepapers.aspx">
            <front>
               <title>HTTP Request Smuggling</title>
               <author initials="C." surname="Linhart" fullname="Chaim Linhart"/>
               <author initials="A." surname="Klein" fullname="Amit Klein"/>
               <author initials="R." surname="Heled" fullname="Ronen Heled"/>
               <author initials="S." surname="Orrin" fullname="Steve Orrin"/>
               <date year="2005" month="June"/>
            </front>
         </reference>
         <reference anchor="Err4667" quote-title="false" target="https://www.rfc-editor.org/errata/eid4667">
            <front>
               <title>Erratum ID 4667</title>
               <author>
                  <organization>RFC Errata</organization>
               </author>
               <date/>
            </front>
            <seriesInfo name="RFC" value="7230"/>
         </reference>
      </references>
      <section anchor="collected.abnf" title="Collected ABNF">
         <t>In the collected ABNF below, list rules are expanded as per Section 11 of <xref target="Semantics"/>.</t>
         <sourcecode type="abnf" name="draft-ietf-httpbis-messaging-latest.parsed-abnf"><![CDATA[BWS = <BWS, see [Semantics], Section 4.3>

Connection = [ connection-option ] *( OWS "," OWS [ connection-option
 ] )

HTTP-message = start-line CRLF *( header-field CRLF ) CRLF [
 message-body ]
HTTP-name = %x48.54.54.50 ; HTTP
HTTP-version = HTTP-name "/" DIGIT "." DIGIT

OWS = <OWS, see [Semantics], Section 4.3>

RWS = <RWS, see [Semantics], Section 4.3>

TE = [ t-codings ] *( OWS "," OWS [ t-codings ] )
Transfer-Encoding = [ transfer-coding ] *( OWS "," OWS [
 transfer-coding ] )

Upgrade = [ protocol ] *( OWS "," OWS [ protocol ] )

absolute-URI = <absolute-URI, see [RFC3986], Section 4.3>
absolute-form = absolute-URI
absolute-path = <absolute-path, see [Semantics], Section 2.4>
asterisk-form = "*"
authority = <authority, see [RFC3986], Section 3.2>
authority-form = authority

chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
chunk-data = 1*OCTET
chunk-ext = *( BWS ";" BWS chunk-ext-name [ BWS "=" BWS chunk-ext-val
 ] )
chunk-ext-name = token
chunk-ext-val = token / quoted-string
chunk-size = 1*HEXDIG
chunked-body = *chunk last-chunk trailer-part CRLF
comment = <comment, see [Semantics], Section 4.2.3>
connection-option = token

field-name = <field-name, see [Semantics], Section 4.2>
field-value = <field-value, see [Semantics], Section 4.2>

header-field = field-name ":" OWS field-value OWS

last-chunk = 1*"0" [ chunk-ext ] CRLF

message-body = *OCTET
method = token

obs-fold = OWS CRLF RWS
obs-text = <obs-text, see [Semantics], Section 4.2.3>
origin-form = absolute-path [ "?" query ]

port = <port, see [RFC3986], Section 3.2.3>
protocol = protocol-name [ "/" protocol-version ]
protocol-name = token
protocol-version = token

query = <query, see [RFC3986], Section 3.4>
quoted-string = <quoted-string, see [Semantics], Section 4.2.3>

rank = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )
reason-phrase = 1*( HTAB / SP / VCHAR / obs-text )
request-line = method SP request-target SP HTTP-version
request-target = origin-form / absolute-form / authority-form /
 asterisk-form

start-line = request-line / status-line
status-code = 3DIGIT
status-line = HTTP-version SP status-code SP [ reason-phrase ]

t-codings = "trailers" / ( transfer-coding [ t-ranking ] )
t-ranking = OWS ";" OWS "q=" rank
token = <token, see [Semantics], Section 4.2.3>
trailer-part = *( header-field CRLF )
transfer-coding = token *( OWS ";" OWS transfer-parameter )
transfer-parameter = token BWS "=" BWS ( token / quoted-string )

uri-host = <host, see [RFC3986], Section 3.2.2>
]]></sourcecode>
      </section>
      <section anchor="differences.between.http.and.mime" title="Differences between HTTP and MIME">
         <t>
   HTTP/1.1 uses many of the constructs defined for the
   Internet Message Format <xref target="RFC5322"/> and the Multipurpose
   Internet Mail Extensions (MIME) <xref target="RFC2045"/> to
   allow a message body to be transmitted in an open variety of
   representations and with extensible header fields. However, RFC 2045
   is focused only on email; applications of HTTP have many characteristics
   that differ from email; hence, HTTP has features that differ from MIME.
   These differences were carefully chosen to optimize performance over binary
   connections, to allow greater freedom in the use of new media types, to
   make date comparisons easier, and to acknowledge the practice of some early
   HTTP servers and clients.
</t>
         <t>
   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.
</t>
         <section anchor="mime-version" title="MIME-Version">
            <iref primary="true" item="MIME-Version header field"/>
            <t>
   HTTP is not a MIME-compliant protocol. However, messages can
   include a single MIME-Version header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full conformance with the MIME protocol (as defined in <xref target="RFC2045"/>).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.
</t>
         </section>
         <section anchor="conversion.to.canonical.form" title="Conversion to Canonical Form">
            <t>
   MIME requires that an Internet mail body part be converted to canonical
   form prior to being transferred, as described in Section 4 of <xref target="RFC2049"/>. Section 6.1.1.2 of <xref target="Semantics"/>
   describes the forms allowed for subtypes of the "text"
   media type when transmitted over HTTP. <xref target="RFC2046"/> requires
   that content with a type of "text" represent line breaks as CRLF and
   forbids the use of CR or LF outside of line break sequences. HTTP allows
   CRLF, bare CR, and bare LF to indicate a line break within text content.
</t>
            <t>
   A proxy or gateway from HTTP to a strict MIME
   environment ought to translate all line breaks within text media
   types to the RFC 2049 canonical form of CRLF. Note, however,
   this might be complicated by the presence of a Content-Encoding
   and by the fact that HTTP allows the use of some charsets
   that do not use octets 13 and 10 to represent CR and LF, respectively.
</t>
            <t>
   Conversion will break any cryptographic
   checksums applied to the original content unless the original content
   is already in canonical form. Therefore, the canonical form is
   recommended for any content that uses such checksums in HTTP.
</t>
         </section>
         <section anchor="conversion.of.date.formats" title="Conversion of Date Formats">
            <t>
   HTTP/1.1 uses a restricted set of date formats (Section 10.1.1.1 of <xref target="Semantics"/>) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols ought to ensure that any Date header field
   present in a message conforms to one of the HTTP/1.1 formats and rewrite
   the date if necessary.
</t>
         </section>
         <section anchor="conversion.content-encoding" title="Conversion of Content-Encoding">
            <t>
   MIME does not include any concept equivalent to HTTP/1.1's
   Content-Encoding header field. Since this acts as a modifier
   on the media type, proxies and gateways from HTTP to MIME-compliant
   protocols ought to either change the value of the Content-Type
   header field or decode the representation before forwarding the message.
   (Some experimental applications of Content-Type for Internet mail have used
   a media-type parameter of ";conversions=&lt;content-coding&gt;" to perform
   a function equivalent to Content-Encoding. However, this parameter is
   not part of the MIME standards).
</t>
         </section>
         <section anchor="conversion.content-transfer-encoding" title="Conversion of Content-Transfer-Encoding">
            <iref item="Content-Transfer-Encoding header field"/>
            <t>
   HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP need to remove
   any Content-Transfer-Encoding prior to delivering the response message to
   an HTTP client.
</t>
            <t>
   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where "safe
   transport" is defined by the limitations of the protocol being used.
   Such a proxy or gateway ought to transform and label the data with an
   appropriate Content-Transfer-Encoding if doing so will improve the
   likelihood of safe transport over the destination protocol.
</t>
         </section>
         <section anchor="mhtml.line.length" title="MHTML and Line Length Limitations">
            <t>
   HTTP implementations that share code with MHTML <xref target="RFC2557"/>
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long lines.
   MHTML messages being transported by HTTP follow all conventions of MHTML,
   including line length limitations and folding, canonicalization, etc.,
   since HTTP transfers message-bodies as payload and, aside from the
   "multipart/byteranges" type (Section 6.3.4 of <xref target="Semantics"/>), does not interpret
   the content or any MIME header lines that might be contained therein.
</t>
         </section>
      </section>
      <section anchor="compatibility" title="HTTP Version History">
         <t>
   HTTP has been in use since 1990. The first version, later referred to as
   HTTP/0.9, was a simple protocol for hypertext data transfer across the
   Internet, using only a single request method (GET) and no metadata.
   HTTP/1.0, as defined by <xref target="RFC1945"/>, added a range of request
   methods and MIME-like messaging, allowing for metadata to be transferred
   and modifiers placed on the request/response semantics. However,
   HTTP/1.0 did not sufficiently take into consideration the effects of
   hierarchical proxies, caching, the need for persistent connections, or
   name-based virtual hosts. The proliferation of incompletely implemented
   applications calling themselves "HTTP/1.0" further necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.
</t>
         <t>
   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only
   those features that can either be safely ignored by an HTTP/1.0
   recipient or only be sent when communicating with a party advertising
   conformance with HTTP/1.1.
</t>
         <t>
   HTTP/1.1 has been designed to make supporting previous versions easy.
   A general-purpose HTTP/1.1 server ought to be able to understand any valid
   request in the format of HTTP/1.0, responding appropriately with an
   HTTP/1.1 message that only uses features understood (or safely ignored) by
   HTTP/1.0 clients. Likewise, an HTTP/1.1 client can be expected to
   understand any valid HTTP/1.0 response.
</t>
         <t>
   Since HTTP/0.9 did not support header fields in a request, there is no
   mechanism for it to support name-based virtual hosts (selection of resource
   by inspection of the Host header field).
   Any server that implements name-based virtual hosts ought to disable
   support for HTTP/0.9. Most requests that appear to be HTTP/0.9 are, in
   fact, badly constructed HTTP/1.x requests caused by a client failing to
   properly encode the request-target.
</t>
         <section anchor="changes.from.1.0" title="Changes from HTTP/1.0">
            <t>
   This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.
</t>
            <section anchor="changes.to.simplify.multihomed.web.servers.and.conserve.ip.addresses" title="Multihomed Web Servers">
               <t>
   The requirements that clients and servers support the Host
   header field (Section 5.4 of <xref target="Semantics"/>), report an error if it is
   missing from an HTTP/1.1 request, and accept absolute URIs
   (<xref target="request.target"/>)
   are among the most important changes defined by HTTP/1.1.
</t>
               <t>
   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The Host header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional requirements
   were placed on all HTTP/1.1 requests in order to ensure complete
   adoption.  At the time of this writing, most HTTP-based services
   are dependent upon the Host header field for targeting requests.
</t>
            </section>
            <section anchor="compatibility.with.http.1.0.persistent.connections" title="Keep-Alive Connections">
               <t>
   In HTTP/1.0, each connection is established by the client prior to the
   request and closed by the server after sending the response. However, some
   implementations implement the explicitly negotiated ("Keep-Alive") version
   of persistent connections described in Section 19.7.1 of <xref target="RFC2068"/>.
</t>
               <t>
   Some clients and servers might wish to be compatible with these previous
   approaches to persistent connections, by explicitly negotiating for them
   with a "Connection: keep-alive" request header field. However, some
   experimental implementations of HTTP/1.0 persistent connections are faulty;
   for example, if an HTTP/1.0 proxy server doesn't understand
   <xref target="header.connection" format="none">Connection</xref>, it will erroneously forward that header field
   to the next inbound server, which would result in a hung connection.
</t>
               <t>
   One attempted solution was the introduction of a Proxy-Connection header
   field, targeted specifically at proxies. In practice, this was also
   unworkable, because proxies are often deployed in multiple layers, bringing
   about the same problem discussed above.
</t>
               <t>
   As a result, clients are encouraged not to send the Proxy-Connection header
   field in any requests.
</t>
               <t>
   Clients are also encouraged to consider the use of Connection: keep-alive
   in requests carefully; while they can enable persistent connections with
   HTTP/1.0 servers, clients using them will need to monitor the
   connection for "hung" requests (which indicate that the client ought stop
   sending the header field), and this mechanism ought not be used by clients
   at all when a proxy is being used.
</t>
            </section>
            <section anchor="introduction.of.transfer-encoding" title="Introduction of Transfer-Encoding">
               <t>
   HTTP/1.1 introduces the <xref target="header.transfer-encoding" format="none">Transfer-Encoding</xref> header field
   (<xref target="header.transfer-encoding"/>).
   Transfer codings need to be decoded prior to forwarding an HTTP message
   over a MIME-compliant protocol.
</t>
            </section>
         </section>
         <section anchor="changes.from.rfc.7230" title="Changes from RFC 7230">
            <t>
  Most of the sections introducing HTTP's design goals, history, architecture,
  conformance criteria, protocol versioning, URIs, message routing, and
  header field values have been moved to <xref target="Semantics"/>.
  This document has been reduced to just the messaging syntax and
  connection management requirements specific to HTTP/1.1.
</t>
            <t>
  Furthermore:
</t>
            <t>
  In the ABNF for chunked extensions, re-introduce (bad) whitespace around
  ";" and "=". Whitespace was removed in <xref target="RFC7230"/>,
  but later this change was found to break existing implementations (see 
  <xref target="Err4667"/>).
  (<xref target="chunked.extension"/>)
</t>
            <t>
  Disallow transfer coding parameters called "q" in order to avoid
  conflicts with the use of ranks in the <xref target="header.te" format="none">TE</xref> header field.
  (<xref target="transfer.coding.registry"/>)
</t>
         </section>
      </section>
      <section anchor="change.log" title="Change Log">
         <t>This section is to be removed before publishing as an RFC.</t>
         <section anchor="changes.since.publication.as.rfc" title="Between RFC7230 and draft 00">
            <t>
  The changes were purely editorial:
</t>
            <ul>
               <li>Change boilerplate and abstract to indicate the "draft" status, and update references to ancestor specifications.</li>
               <li>Adjust historical notes.</li>
               <li>Update links to sibling specifications.</li>
               <li>Replace sections listing changes from RFC 2616 by new empty sections referring to RFC 723x.</li>
               <li>Remove acknowledgements specific to RFC 723x.</li>
               <li>Move "Acknowledgements" to the very end and make them unnumbered.</li>
            </ul>
         </section>
         <section anchor="changes.since.00" title="Since draft-ietf-httpbis-messaging-00">
            <t>
  The changes in this draft are editorial, with respect to HTTP as a whole,
  to move all core HTTP semantics into <xref target="Semantics"/>:
</t>
            <ul>
               <li>Moved introduction, architecture, conformance, and ABNF extensions from
      <xref target="RFC7230" format="none">RFC 7230 (Messaging)</xref> to
      semantics <xref target="Semantics"/>.</li>
               <li>Moved discussion of MIME differences from
      <xref target="RFC7231" format="none">RFC 7231 (Semantics)</xref> to
      <xref target="differences.between.http.and.mime"/>
      since they mostly cover transforming 1.1 messages.</li>
               <li>Moved all extensibility tips, registration procedures, and registry
      tables from the IANA considerations to normative sections, reducing the
      IANA considerations to just instructions that will be removed prior to
      publication as an RFC.</li>
            </ul>
         </section>
         <section anchor="changes.since.01" title="Since draft-ietf-httpbis-messaging-01">
            <ul>
               <li>Cite RFC 8126 instead of RFC 5226 (<eref target="https://github.com/httpwg/http-core/issues/75"/>)</li>
               <li>Resolved erratum 4779, no change needed here (<eref target="https://github.com/httpwg/http-core/issues/87"/>, <eref target="https://www.rfc-editor.org/errata/eid4779"/>)</li>
               <li>In <xref target="transfer.codings"/>, fixed prose claiming transfer parameters allow bare names (<eref target="https://github.com/httpwg/http-core/issues/88"/>, <eref target="https://www.rfc-editor.org/errata/eid4839"/>)</li>
               <li>Resolved erratum 4225, no change needed here (<eref target="https://github.com/httpwg/http-core/issues/90"/>, <eref target="https://www.rfc-editor.org/errata/eid4225"/>)</li>
               <li>Replace "response code" with "response status code" (<eref target="https://github.com/httpwg/http-core/issues/94"/>, <eref target="https://www.rfc-editor.org/errata/eid4050"/>)</li>
               <li>In <xref target="persistent.connections"/>, clarify statement about HTTP/1.0 keep-alive (<eref target="https://github.com/httpwg/http-core/issues/96"/>, <eref target="https://www.rfc-editor.org/errata/eid4205"/>)</li>
               <li>In <xref target="chunked.extension"/>, re-introduce (bad) whitespace around ";" and "=" (<eref target="https://github.com/httpwg/http-core/issues/101"/>,
  <eref target="https://www.rfc-editor.org/errata/eid4667"/>, <eref target="https://www.rfc-editor.org/errata/eid4825"/>)</li>
               <li>In <xref target="transfer.coding.registry"/>, state that transfer codings should not use parameters named "q" (<eref target="https://github.com/httpwg/http-core/issues/15"/>, <eref target="https://www.rfc-editor.org/errata/eid4683"/>)</li>
               <li>In <xref target="transfer.codings"/>, mark coding name "trailers" as reserved in the IANA registry (<eref target="https://github.com/httpwg/http-core/issues/108"/>)</li>
            </ul>
         </section>
         <section anchor="changes.since.02" title="Since draft-ietf-httpbis-messaging-02">
            <ul>
               <li>In <xref target="status.line"/>, explain why the reason phrase should be ignored by clients (<eref target="https://github.com/httpwg/http-core/issues/60"/>).</li>
               <li>Add <xref target="associating.response.to.request"/> to explain how request/response correlation is performed (<eref target="https://github.com/httpwg/http-core/issues/145"/>)</li>
            </ul>
         </section>
         <section anchor="changes.since.03" title="Since draft-ietf-httpbis-messaging-03">
            <ul>
               <li>In <xref target="associating.response.to.request"/>, caution against treating data on a connection as part of a not-yet-issued request (<eref target="https://github.com/httpwg/http-core/issues/26"/>)</li>
               <li>In <xref target="transfer.codings"/>, remove the predefined codings from the ABNF and make it generic instead (<eref target="https://github.com/httpwg/http-core/issues/66"/>)</li>
               <li>Use RFC 7405 ABNF notation for case-sensitive string constants (<eref target="https://github.com/httpwg/http-core/issues/133"/>)</li>
            </ul>
         </section>
         <section anchor="changes.since.04" title="Since draft-ietf-httpbis-messaging-04">
            <ul>
               <li>In <xref target="header.upgrade"/>, clarify that protocol-name is to be matched case-insensitively (<eref target="https://github.com/httpwg/http-core/issues/8"/>)</li>
               <li>In <xref target="line.folding"/>, add leading optional whitespace to obs-fold ABNF (<eref target="https://github.com/httpwg/http-core/issues/19"/>, <eref target="https://www.rfc-editor.org/errata/eid4189"/>)</li>
               <li>In <xref target="status.line"/>, add clarifications about empty reason phrases (<eref target="https://github.com/httpwg/http-core/issues/197"/>)</li>
               <li>Move discussion of retries from <xref target="persistent.retrying.requests"/> into <xref target="Semantics"/> (<eref target="https://github.com/httpwg/http-core/issues/230"/>)</li>
            </ul>
         </section>
         <section anchor="changes.since.05" title="Since draft-ietf-httpbis-messaging-05">
            <ul>
               <li>In <xref target="message.format"/> and related Sections, move the trailing CRLF from the line grammars into the message format (<eref target="https://github.com/httpwg/http-core/issues/62"/>)</li>
            </ul>
         </section>
      </section>
      <section anchor="acks" numbered="false" title="Acknowledgments">
         <t>
  See Appendix "Acknowledgments" of <xref target="Semantics"/>.
</t>
      </section>
   </back>
</rfc>